   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"IO1.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC,"aw",%nobits
  18              		.align	2
  21              	DeviceDataPrv__DEFAULT_RTOS_ALLOC:
  22 0000 00000000 		.space	24
  22      00000000 
  22      00000000 
  22      00000000 
  22      00000000 
  23              		.section	.text.IO1_Init,"ax",%progbits
  24              		.align	2
  25              		.global	IO1_Init
  26              		.code	16
  27              		.thumb_func
  29              	IO1_Init:
  30              	.LFB0:
  31              		.file 1 "../Generated_Code/IO1.c"
   1:../Generated_Code/IO1.c **** /** ###################################################################
   2:../Generated_Code/IO1.c **** **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
   3:../Generated_Code/IO1.c **** **     Filename    : IO1.c
   4:../Generated_Code/IO1.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/IO1.c **** **     Processor   : MKL25Z128VLK4
   6:../Generated_Code/IO1.c **** **     Component   : Serial_LDD
   7:../Generated_Code/IO1.c **** **     Version     : Component 01.165, Driver 01.10, CPU db: 3.00.000
   8:../Generated_Code/IO1.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/IO1.c **** **     Date/Time   : 2013-05-26, 03:04, # CodeGen: 85
  10:../Generated_Code/IO1.c **** **     Abstract    :
  11:../Generated_Code/IO1.c **** **         This component "Serial_LDD" implements an asynchronous serial
  12:../Generated_Code/IO1.c **** **         communication. The component supports different settings of
  13:../Generated_Code/IO1.c **** **         parity, word width, stop-bit and communication speed,
  14:../Generated_Code/IO1.c **** **         user can select interrupt or polling handler.
  15:../Generated_Code/IO1.c **** **         Communication speed can be changed also in runtime.
  16:../Generated_Code/IO1.c **** **         The component requires one on-chip asynchronous serial communication channel.
  17:../Generated_Code/IO1.c **** **     Settings    :
  18:../Generated_Code/IO1.c **** **          Component name                                 : IO1
  19:../Generated_Code/IO1.c **** **          Device                                         : UART0
  20:../Generated_Code/IO1.c **** **          Interrupt service/event                        : Disabled
  21:../Generated_Code/IO1.c **** **          Settings                                       : 
  22:../Generated_Code/IO1.c **** **            Data width                                   : 8 bits
  23:../Generated_Code/IO1.c **** **            Parity                                       : None
  24:../Generated_Code/IO1.c **** **            Stop bits                                    : 1
  25:../Generated_Code/IO1.c **** **            Loop mode                                    : Normal
  26:../Generated_Code/IO1.c **** **            Baud rate                                    : 9600 baud
  27:../Generated_Code/IO1.c **** **            Wakeup condition                             : Idle line wakeup
  28:../Generated_Code/IO1.c **** **            Stop in wait mode                            : no
  29:../Generated_Code/IO1.c **** **            Idle line mode                               : Starts after start bit
  30:../Generated_Code/IO1.c **** **            Transmitter output                           : Not inverted
  31:../Generated_Code/IO1.c **** **            Receiver input                               : Not inverted
  32:../Generated_Code/IO1.c **** **            Break generation length                      : 10/11 bits
  33:../Generated_Code/IO1.c **** **            Receiver                                     : Enabled
  34:../Generated_Code/IO1.c **** **              RxD                                        : TSI0_CH2/PTA1/UART0_RX/TPM2_CH0
  35:../Generated_Code/IO1.c **** **              RxD pin signal                             : 
  36:../Generated_Code/IO1.c **** **            Transmitter                                  : Enabled
  37:../Generated_Code/IO1.c **** **              TxD                                        : TSI0_CH3/PTA2/UART0_TX/TPM2_CH1
  38:../Generated_Code/IO1.c **** **              TxD pin signal                             : 
  39:../Generated_Code/IO1.c **** **            Flow control                                 : None
  40:../Generated_Code/IO1.c **** **          Initialization                                 : 
  41:../Generated_Code/IO1.c **** **            Enabled in init. code                        : yes
  42:../Generated_Code/IO1.c **** **            Auto initialization                          : yes
  43:../Generated_Code/IO1.c **** **            Event mask                                   : 
  44:../Generated_Code/IO1.c **** **              OnBlockSent                                : Disabled
  45:../Generated_Code/IO1.c **** **              OnBlockReceived                            : Disabled
  46:../Generated_Code/IO1.c **** **              OnTxComplete                               : Disabled
  47:../Generated_Code/IO1.c **** **              OnError                                    : Disabled
  48:../Generated_Code/IO1.c **** **              OnBreak                                    : Disabled
  49:../Generated_Code/IO1.c **** **          CPU clock/configuration selection              : 
  50:../Generated_Code/IO1.c **** **            Clock configuration 0                        : This component enabled
  51:../Generated_Code/IO1.c **** **            Clock configuration 1                        : This component enabled
  52:../Generated_Code/IO1.c **** **            Clock configuration 2                        : This component enabled
  53:../Generated_Code/IO1.c **** **            Clock configuration 3                        : This component enabled
  54:../Generated_Code/IO1.c **** **            Clock configuration 4                        : This component enabled
  55:../Generated_Code/IO1.c **** **            Clock configuration 5                        : This component enabled
  56:../Generated_Code/IO1.c **** **            Clock configuration 6                        : This component enabled
  57:../Generated_Code/IO1.c **** **            Clock configuration 7                        : This component enabled
  58:../Generated_Code/IO1.c **** **     Contents    :
  59:../Generated_Code/IO1.c **** **         Init         - LDD_TDeviceData* IO1_Init(LDD_TUserData *UserDataPtr);
  60:../Generated_Code/IO1.c **** **         ReceiveBlock - LDD_TError IO1_ReceiveBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData...
  61:../Generated_Code/IO1.c **** **         Main         - void IO1_Main(LDD_TDeviceData *DeviceDataPtr);
  62:../Generated_Code/IO1.c **** **
  63:../Generated_Code/IO1.c **** **     Copyright : 1997 - 2012 Freescale, Inc. All Rights Reserved.
  64:../Generated_Code/IO1.c **** **     
  65:../Generated_Code/IO1.c **** **     http      : www.freescale.com
  66:../Generated_Code/IO1.c **** **     mail      : support@freescale.com
  67:../Generated_Code/IO1.c **** ** ###################################################################*/
  68:../Generated_Code/IO1.c **** 
  69:../Generated_Code/IO1.c **** /* MODULE IO1. */
  70:../Generated_Code/IO1.c **** /*lint -save  -e926 -e927 -e928 -e929 -e572 Disable MISRA rule (11.4,12.8) checking. */
  71:../Generated_Code/IO1.c **** 
  72:../Generated_Code/IO1.c **** /* {Default RTOS Adapter} No RTOS includes */
  73:../Generated_Code/IO1.c **** #include "IO1.h"
  74:../Generated_Code/IO1.c **** #include "UART0_PDD.h"
  75:../Generated_Code/IO1.c **** 
  76:../Generated_Code/IO1.c **** #define AVAILABLE_EVENTS_MASK 0x00U
  77:../Generated_Code/IO1.c **** 
  78:../Generated_Code/IO1.c **** /* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
  79:../Generated_Code/IO1.c **** static IO1_TDeviceData DeviceDataPrv__DEFAULT_RTOS_ALLOC;
  80:../Generated_Code/IO1.c **** 
  81:../Generated_Code/IO1.c **** /*
  82:../Generated_Code/IO1.c **** ** ===================================================================
  83:../Generated_Code/IO1.c **** **     Method      :  IO1_Init (component Serial_LDD)
  84:../Generated_Code/IO1.c **** **
  85:../Generated_Code/IO1.c **** **     Description :
  86:../Generated_Code/IO1.c **** **         Initializes the device. Allocates memory for the device data
  87:../Generated_Code/IO1.c **** **         structure, allocates interrupt vectors and sets interrupt
  88:../Generated_Code/IO1.c **** **         priority, sets pin routing, sets timing, etc. If the "Enable
  89:../Generated_Code/IO1.c **** **         in init. code" is set to "yes" value then the device is also
  90:../Generated_Code/IO1.c **** **         enabled(see the description of the Enable() method). In this
  91:../Generated_Code/IO1.c **** **         case the Enable() method is not necessary and needn't to be
  92:../Generated_Code/IO1.c **** **         generated. 
  93:../Generated_Code/IO1.c **** **     Parameters  :
  94:../Generated_Code/IO1.c **** **         NAME            - DESCRIPTION
  95:../Generated_Code/IO1.c **** **       * UserDataPtr     - Pointer to the user or
  96:../Generated_Code/IO1.c **** **                           RTOS specific data. This pointer will be
  97:../Generated_Code/IO1.c **** **                           passed as an event or callback parameter.
  98:../Generated_Code/IO1.c **** **     Returns     :
  99:../Generated_Code/IO1.c **** **         ---             - Device data structure pointer.
 100:../Generated_Code/IO1.c **** ** ===================================================================
 101:../Generated_Code/IO1.c **** */
 102:../Generated_Code/IO1.c **** LDD_TDeviceData* IO1_Init(LDD_TUserData *UserDataPtr)
 103:../Generated_Code/IO1.c **** {
  32              		.loc 1 103 0
  33              		.cfi_startproc
  34 0000 80B5     		push	{r7, lr}
  35              	.LCFI0:
  36              		.cfi_def_cfa_offset 8
  37              		.cfi_offset 7, -8
  38              		.cfi_offset 14, -4
  39 0002 84B0     		sub	sp, sp, #16
  40              	.LCFI1:
  41              		.cfi_def_cfa_offset 24
  42 0004 00AF     		add	r7, sp, #0
  43              	.LCFI2:
  44              		.cfi_def_cfa_register 7
  45 0006 7860     		str	r0, [r7, #4]
 104:../Generated_Code/IO1.c ****   /* Allocate device structure */
 105:../Generated_Code/IO1.c ****   IO1_TDeviceDataPtr DeviceDataPrv;
 106:../Generated_Code/IO1.c ****   /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer 
 107:../Generated_Code/IO1.c ****   DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;
  46              		.loc 1 107 0
  47 0008 4F4B     		ldr	r3, .L2
  48 000a FB60     		str	r3, [r7, #12]
 108:../Generated_Code/IO1.c **** 
 109:../Generated_Code/IO1.c ****   /* Clear the receive counters and pointer */
 110:../Generated_Code/IO1.c ****   DeviceDataPrv->InpRecvDataNum = 0x00U; /* Clear the counter of received characters */
  49              		.loc 1 110 0
  50 000c FB68     		ldr	r3, [r7, #12]
  51 000e 0022     		mov	r2, #0
  52 0010 5A80     		strh	r2, [r3, #2]
 111:../Generated_Code/IO1.c ****   DeviceDataPrv->InpDataNumReq = 0x00U; /* Clear the counter of characters to receive by ReceiveBlo
  53              		.loc 1 111 0
  54 0012 FB68     		ldr	r3, [r7, #12]
  55 0014 0022     		mov	r2, #0
  56 0016 1A81     		strh	r2, [r3, #8]
 112:../Generated_Code/IO1.c ****   DeviceDataPrv->InpDataPtr = NULL;    /* Clear the buffer pointer for received characters */
  57              		.loc 1 112 0
  58 0018 FB68     		ldr	r3, [r7, #12]
  59 001a 0022     		mov	r2, #0
  60 001c 5A60     		str	r2, [r3, #4]
 113:../Generated_Code/IO1.c ****   /* Clear the transmit counters and pointer */
 114:../Generated_Code/IO1.c ****   DeviceDataPrv->OutSentDataNum = 0x00U; /* Clear the counter of sent characters */
  61              		.loc 1 114 0
  62 001e FB68     		ldr	r3, [r7, #12]
  63 0020 0022     		mov	r2, #0
  64 0022 5A81     		strh	r2, [r3, #10]
 115:../Generated_Code/IO1.c ****   DeviceDataPrv->OutDataNumReq = 0x00U; /* Clear the counter of characters to be send by SendBlock(
  65              		.loc 1 115 0
  66 0024 FB68     		ldr	r3, [r7, #12]
  67 0026 0022     		mov	r2, #0
  68 0028 1A82     		strh	r2, [r3, #16]
 116:../Generated_Code/IO1.c ****   DeviceDataPrv->OutDataPtr = NULL;    /* Clear the buffer pointer for data to be transmitted */
  69              		.loc 1 116 0
  70 002a FB68     		ldr	r3, [r7, #12]
  71 002c 0022     		mov	r2, #0
  72 002e DA60     		str	r2, [r3, #12]
 117:../Generated_Code/IO1.c ****   DeviceDataPrv->UserDataPtr = UserDataPtr; /* Store the RTOS device structure */
  73              		.loc 1 117 0
  74 0030 FB68     		ldr	r3, [r7, #12]
  75 0032 7A68     		ldr	r2, [r7, #4]
  76 0034 5A61     		str	r2, [r3, #20]
 118:../Generated_Code/IO1.c ****   /* SIM_SCGC4: UART0=1 */
 119:../Generated_Code/IO1.c ****   SIM_SCGC4 |= SIM_SCGC4_UART0_MASK;                                                   
  77              		.loc 1 119 0
  78 0036 454A     		ldr	r2, .L2+4
  79 0038 4449     		ldr	r1, .L2+4
  80 003a 454B     		ldr	r3, .L2+8
  81 003c CB58     		ldr	r3, [r1, r3]
  82 003e 8021     		mov	r1, #128
  83 0040 C900     		lsl	r1, r1, #3
  84 0042 1943     		orr	r1, r3
  85 0044 424B     		ldr	r3, .L2+8
  86 0046 D150     		str	r1, [r2, r3]
 120:../Generated_Code/IO1.c ****   /* PORTA_PCR1: ISF=0,MUX=2 */
 121:../Generated_Code/IO1.c ****   PORTA_PCR1 = (uint32_t)((PORTA_PCR1 & (uint32_t)~(uint32_t)(
  87              		.loc 1 121 0
  88 0048 424B     		ldr	r3, .L2+12
  89 004a 424A     		ldr	r2, .L2+12
  90 004c 5268     		ldr	r2, [r2, #4]
  91 004e 111C     		mov	r1, r2
  92 0050 414A     		ldr	r2, .L2+16
  93 0052 0A40     		and	r2, r1
  94 0054 8021     		mov	r1, #128
  95 0056 8900     		lsl	r1, r1, #2
  96 0058 0A43     		orr	r2, r1
  97 005a 5A60     		str	r2, [r3, #4]
 122:../Generated_Code/IO1.c ****                 PORT_PCR_ISF_MASK |
 123:../Generated_Code/IO1.c ****                 PORT_PCR_MUX(0x05)
 124:../Generated_Code/IO1.c ****                )) | (uint32_t)(
 125:../Generated_Code/IO1.c ****                 PORT_PCR_MUX(0x02)
 126:../Generated_Code/IO1.c ****                ));                                                  
 127:../Generated_Code/IO1.c ****   /* PORTA_PCR2: ISF=0,MUX=2 */
 128:../Generated_Code/IO1.c ****   PORTA_PCR2 = (uint32_t)((PORTA_PCR2 & (uint32_t)~(uint32_t)(
  98              		.loc 1 128 0
  99 005c 3D4B     		ldr	r3, .L2+12
 100 005e 3D4A     		ldr	r2, .L2+12
 101 0060 9268     		ldr	r2, [r2, #8]
 102 0062 111C     		mov	r1, r2
 103 0064 3C4A     		ldr	r2, .L2+16
 104 0066 0A40     		and	r2, r1
 105 0068 8021     		mov	r1, #128
 106 006a 8900     		lsl	r1, r1, #2
 107 006c 0A43     		orr	r2, r1
 108 006e 9A60     		str	r2, [r3, #8]
 129:../Generated_Code/IO1.c ****                 PORT_PCR_ISF_MASK |
 130:../Generated_Code/IO1.c ****                 PORT_PCR_MUX(0x05)
 131:../Generated_Code/IO1.c ****                )) | (uint32_t)(
 132:../Generated_Code/IO1.c ****                 PORT_PCR_MUX(0x02)
 133:../Generated_Code/IO1.c ****                ));                                                  
 134:../Generated_Code/IO1.c ****   UART0_PDD_EnableTransmitter(UART0_BASE_PTR, PDD_DISABLE); /* Disable transmitter. */
 109              		.loc 1 134 0
 110 0070 3A4B     		ldr	r3, .L2+20
 111 0072 3A4A     		ldr	r2, .L2+20
 112 0074 D278     		ldrb	r2, [r2, #3]
 113 0076 D2B2     		uxtb	r2, r2
 114 0078 0821     		mov	r1, #8
 115 007a 8A43     		bic	r2, r1
 116 007c D2B2     		uxtb	r2, r2
 117 007e DA70     		strb	r2, [r3, #3]
 135:../Generated_Code/IO1.c ****   UART0_PDD_EnableReceiver(UART0_BASE_PTR, PDD_DISABLE); /* Disable receiver. */
 118              		.loc 1 135 0
 119 0080 364B     		ldr	r3, .L2+20
 120 0082 364A     		ldr	r2, .L2+20
 121 0084 D278     		ldrb	r2, [r2, #3]
 122 0086 D2B2     		uxtb	r2, r2
 123 0088 0421     		mov	r1, #4
 124 008a 8A43     		bic	r2, r1
 125 008c D2B2     		uxtb	r2, r2
 126 008e DA70     		strb	r2, [r3, #3]
 136:../Generated_Code/IO1.c ****   DeviceDataPrv->SerFlag = 0x00U;      /* Reset flags */
 127              		.loc 1 136 0
 128 0090 FB68     		ldr	r3, [r7, #12]
 129 0092 0022     		mov	r2, #0
 130 0094 1A80     		strh	r2, [r3]
 137:../Generated_Code/IO1.c ****   /* UART0_C1: LOOPS=0,DOZEEN=0,RSRC=0,M=0,WAKE=0,ILT=0,PE=0,PT=0 */
 138:../Generated_Code/IO1.c ****   UART0_C1 = 0x00U;                    /*  Set the C1 register */
 131              		.loc 1 138 0
 132 0096 314B     		ldr	r3, .L2+20
 133 0098 0022     		mov	r2, #0
 134 009a 9A70     		strb	r2, [r3, #2]
 139:../Generated_Code/IO1.c ****   /* UART0_C3: R8T9=0,R9T8=0,TXDIR=0,TXINV=0,ORIE=0,NEIE=0,FEIE=0,PEIE=0 */
 140:../Generated_Code/IO1.c ****   UART0_C3 = 0x00U;                    /*  Set the C3 register */
 135              		.loc 1 140 0
 136 009c 2F4B     		ldr	r3, .L2+20
 137 009e 0022     		mov	r2, #0
 138 00a0 9A71     		strb	r2, [r3, #6]
 141:../Generated_Code/IO1.c ****   /* UART0_S2: LBKDIF=0,RXEDGIF=0,MSBF=0,RXINV=0,RWUID=0,BRK13=0,LBKDE=0,RAF=0 */
 142:../Generated_Code/IO1.c ****   UART0_S2 = 0x00U;                    /*  Set the S2 register */
 139              		.loc 1 142 0
 140 00a2 2E4B     		ldr	r3, .L2+20
 141 00a4 0022     		mov	r2, #0
 142 00a6 5A71     		strb	r2, [r3, #5]
 143:../Generated_Code/IO1.c ****   UART0_PDD_SetClockSource(UART0_BASE_PTR, UART0_PDD_PLL_FLL_CLOCK);
 143              		.loc 1 143 0
 144 00a8 284A     		ldr	r2, .L2+4
 145 00aa 2849     		ldr	r1, .L2+4
 146 00ac 2C4B     		ldr	r3, .L2+24
 147 00ae CB58     		ldr	r3, [r1, r3]
 148 00b0 191C     		mov	r1, r3
 149 00b2 2C4B     		ldr	r3, .L2+28
 150 00b4 0B40     		and	r3, r1
 151 00b6 8021     		mov	r1, #128
 152 00b8 C904     		lsl	r1, r1, #19
 153 00ba 1943     		orr	r1, r3
 154 00bc 284B     		ldr	r3, .L2+24
 155 00be D150     		str	r1, [r2, r3]
 144:../Generated_Code/IO1.c ****   UART0_PDD_SetBaudRate(UART0_BASE_PTR, 625U); /* Set the baud rate register. */
 156              		.loc 1 144 0
 157 00c0 264B     		ldr	r3, .L2+20
 158 00c2 264A     		ldr	r2, .L2+20
 159 00c4 1278     		ldrb	r2, [r2]
 160 00c6 D2B2     		uxtb	r2, r2
 161 00c8 D2B2     		uxtb	r2, r2
 162 00ca 1F21     		mov	r1, #31
 163 00cc 8A43     		bic	r2, r1
 164 00ce D2B2     		uxtb	r2, r2
 165 00d0 0221     		mov	r1, #2
 166 00d2 0A43     		orr	r2, r1
 167 00d4 D2B2     		uxtb	r2, r2
 168 00d6 D2B2     		uxtb	r2, r2
 169 00d8 1A70     		strb	r2, [r3]
 170 00da 204B     		ldr	r3, .L2+20
 171 00dc 7122     		mov	r2, #113
 172 00de 5A70     		strb	r2, [r3, #1]
 145:../Generated_Code/IO1.c ****   UART0_PDD_SetOversamplingRatio(UART0_BASE_PTR, 3U);
 173              		.loc 1 145 0
 174 00e0 1E4B     		ldr	r3, .L2+20
 175 00e2 1E4A     		ldr	r2, .L2+20
 176 00e4 927A     		ldrb	r2, [r2, #10]
 177 00e6 D2B2     		uxtb	r2, r2
 178 00e8 D2B2     		uxtb	r2, r2
 179 00ea 1F21     		mov	r1, #31
 180 00ec 8A43     		bic	r2, r1
 181 00ee D2B2     		uxtb	r2, r2
 182 00f0 0321     		mov	r1, #3
 183 00f2 0A43     		orr	r2, r1
 184 00f4 D2B2     		uxtb	r2, r2
 185 00f6 D2B2     		uxtb	r2, r2
 186 00f8 9A72     		strb	r2, [r3, #10]
 146:../Generated_Code/IO1.c ****   UART0_PDD_EnableSamplingOnBothEdges(UART0_BASE_PTR, PDD_ENABLE);
 187              		.loc 1 146 0
 188 00fa 184B     		ldr	r3, .L2+20
 189 00fc 174A     		ldr	r2, .L2+20
 190 00fe D27A     		ldrb	r2, [r2, #11]
 191 0100 D2B2     		uxtb	r2, r2
 192 0102 D2B2     		uxtb	r2, r2
 193 0104 0221     		mov	r1, #2
 194 0106 0A43     		orr	r2, r1
 195 0108 D2B2     		uxtb	r2, r2
 196 010a D2B2     		uxtb	r2, r2
 197 010c DA72     		strb	r2, [r3, #11]
 147:../Generated_Code/IO1.c ****   UART0_PDD_EnableTransmitter(UART0_BASE_PTR, PDD_ENABLE); /* Enable transmitter */
 198              		.loc 1 147 0
 199 010e 134B     		ldr	r3, .L2+20
 200 0110 124A     		ldr	r2, .L2+20
 201 0112 D278     		ldrb	r2, [r2, #3]
 202 0114 D2B2     		uxtb	r2, r2
 203 0116 D2B2     		uxtb	r2, r2
 204 0118 0821     		mov	r1, #8
 205 011a 0A43     		orr	r2, r1
 206 011c D2B2     		uxtb	r2, r2
 207 011e D2B2     		uxtb	r2, r2
 208 0120 DA70     		strb	r2, [r3, #3]
 148:../Generated_Code/IO1.c ****   UART0_PDD_EnableReceiver(UART0_BASE_PTR, PDD_ENABLE); /* Enable receiver */
 209              		.loc 1 148 0
 210 0122 0E4B     		ldr	r3, .L2+20
 211 0124 0D4A     		ldr	r2, .L2+20
 212 0126 D278     		ldrb	r2, [r2, #3]
 213 0128 D2B2     		uxtb	r2, r2
 214 012a D2B2     		uxtb	r2, r2
 215 012c 0421     		mov	r1, #4
 216 012e 0A43     		orr	r2, r1
 217 0130 D2B2     		uxtb	r2, r2
 218 0132 D2B2     		uxtb	r2, r2
 219 0134 DA70     		strb	r2, [r3, #3]
 149:../Generated_Code/IO1.c ****   /* Registration of the device structure */
 150:../Generated_Code/IO1.c ****   PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_IO1_ID,DeviceDataPrv);
 220              		.loc 1 150 0
 221 0136 0C4B     		ldr	r3, .L2+32
 222 0138 FA68     		ldr	r2, [r7, #12]
 223 013a 1A60     		str	r2, [r3]
 151:../Generated_Code/IO1.c ****   return ((LDD_TDeviceData *)DeviceDataPrv);
 224              		.loc 1 151 0
 225 013c FB68     		ldr	r3, [r7, #12]
 152:../Generated_Code/IO1.c **** }
 226              		.loc 1 152 0
 227 013e 181C     		mov	r0, r3
 228 0140 BD46     		mov	sp, r7
 229 0142 04B0     		add	sp, sp, #16
 230              		@ sp needed for prologue
 231 0144 80BD     		pop	{r7, pc}
 232              	.L3:
 233 0146 C046     		.align	2
 234              	.L2:
 235 0148 00000000 		.word	DeviceDataPrv__DEFAULT_RTOS_ALLOC
 236 014c 00700440 		.word	1074032640
 237 0150 34100000 		.word	4148
 238 0154 00900440 		.word	1074040832
 239 0158 FFF8FFFE 		.word	-16779009
 240 015c 00A00640 		.word	1074176000
 241 0160 04100000 		.word	4100
 242 0164 FFFFFFF3 		.word	-201326593
 243 0168 00000000 		.word	PE_LDD_DeviceDataList
 244              		.cfi_endproc
 245              	.LFE0:
 247              		.section	.text.IO1_ReceiveBlock,"ax",%progbits
 248              		.align	2
 249              		.global	IO1_ReceiveBlock
 250              		.code	16
 251              		.thumb_func
 253              	IO1_ReceiveBlock:
 254              	.LFB1:
 153:../Generated_Code/IO1.c **** 
 154:../Generated_Code/IO1.c **** /*
 155:../Generated_Code/IO1.c **** ** ===================================================================
 156:../Generated_Code/IO1.c **** **     Method      :  IO1_ReceiveBlock (component Serial_LDD)
 157:../Generated_Code/IO1.c **** **
 158:../Generated_Code/IO1.c **** **     Description :
 159:../Generated_Code/IO1.c **** **         Specifies the number of data to receive. The method returns
 160:../Generated_Code/IO1.c **** **         ERR_BUSY until the specified number of characters is
 161:../Generated_Code/IO1.c **** **         received. Method <CancelBlockReception> can be used to
 162:../Generated_Code/IO1.c **** **         cancel a running receive operation.
 163:../Generated_Code/IO1.c **** **     Parameters  :
 164:../Generated_Code/IO1.c **** **         NAME            - DESCRIPTION
 165:../Generated_Code/IO1.c **** **       * DeviceDataPtr   - Device data structure
 166:../Generated_Code/IO1.c **** **                           pointer returned by <Init> method.
 167:../Generated_Code/IO1.c **** **       * BufferPtr       - Pointer to a buffer where
 168:../Generated_Code/IO1.c **** **                           received characters will be stored.
 169:../Generated_Code/IO1.c **** **         Size            - Number of characters to receive
 170:../Generated_Code/IO1.c **** **     Returns     :
 171:../Generated_Code/IO1.c **** **         ---             - Error code, possible codes:
 172:../Generated_Code/IO1.c **** **                           ERR_OK - OK
 173:../Generated_Code/IO1.c **** **                           ERR_SPEED - The component does not work in
 174:../Generated_Code/IO1.c **** **                           the active clock configuration.
 175:../Generated_Code/IO1.c **** **                           ERR_DISABLED - The component or device is
 176:../Generated_Code/IO1.c **** **                           disabled.
 177:../Generated_Code/IO1.c **** **                           ERR_BUSY - The previous receive request is
 178:../Generated_Code/IO1.c **** **                           pending.
 179:../Generated_Code/IO1.c **** ** ===================================================================
 180:../Generated_Code/IO1.c **** */
 181:../Generated_Code/IO1.c **** LDD_TError IO1_ReceiveBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, uint16_t Size)
 182:../Generated_Code/IO1.c **** {
 255              		.loc 1 182 0
 256              		.cfi_startproc
 257 0000 80B5     		push	{r7, lr}
 258              	.LCFI3:
 259              		.cfi_def_cfa_offset 8
 260              		.cfi_offset 7, -8
 261              		.cfi_offset 14, -4
 262 0002 86B0     		sub	sp, sp, #24
 263              	.LCFI4:
 264              		.cfi_def_cfa_offset 32
 265 0004 00AF     		add	r7, sp, #0
 266              	.LCFI5:
 267              		.cfi_def_cfa_register 7
 268 0006 F860     		str	r0, [r7, #12]
 269 0008 B960     		str	r1, [r7, #8]
 270 000a BB1D     		add	r3, r7, #6
 271 000c 1A80     		strh	r2, [r3]
 183:../Generated_Code/IO1.c ****   IO1_TDeviceDataPtr DeviceDataPrv = (IO1_TDeviceDataPtr)DeviceDataPtr;
 272              		.loc 1 183 0
 273 000e FB68     		ldr	r3, [r7, #12]
 274 0010 7B61     		str	r3, [r7, #20]
 184:../Generated_Code/IO1.c **** 
 185:../Generated_Code/IO1.c ****   if (Size == 0U) {                    /* Is the parameter Size within an expected range? */
 275              		.loc 1 185 0
 276 0012 BB1D     		add	r3, r7, #6
 277 0014 1B88     		ldrh	r3, [r3]
 278 0016 002B     		cmp	r3, #0
 279 0018 01D1     		bne	.L5
 186:../Generated_Code/IO1.c ****     return ERR_PARAM_SIZE;             /* If no then error */
 280              		.loc 1 186 0
 281 001a 8423     		mov	r3, #132
 282 001c 10E0     		b	.L6
 283              	.L5:
 187:../Generated_Code/IO1.c ****   }
 188:../Generated_Code/IO1.c ****   if (DeviceDataPrv->InpDataNumReq != 0x00U) { /* Is the previous receive operation pending? */
 284              		.loc 1 188 0
 285 001e 7B69     		ldr	r3, [r7, #20]
 286 0020 1B89     		ldrh	r3, [r3, #8]
 287 0022 002B     		cmp	r3, #0
 288 0024 01D0     		beq	.L7
 189:../Generated_Code/IO1.c ****     return ERR_BUSY;                   /* If yes then error */
 289              		.loc 1 189 0
 290 0026 0823     		mov	r3, #8
 291 0028 0AE0     		b	.L6
 292              	.L7:
 190:../Generated_Code/IO1.c ****   }
 191:../Generated_Code/IO1.c ****   DeviceDataPrv->InpDataPtr = BufferPtr; /* Store a pointer to the input data. */
 293              		.loc 1 191 0
 294 002a 7B69     		ldr	r3, [r7, #20]
 295 002c BA68     		ldr	r2, [r7, #8]
 296 002e 5A60     		str	r2, [r3, #4]
 192:../Generated_Code/IO1.c ****   DeviceDataPrv->InpDataNumReq = Size; /* Store a number of characters to be received. */
 297              		.loc 1 192 0
 298 0030 7B69     		ldr	r3, [r7, #20]
 299 0032 BA1D     		add	r2, r7, #6
 300 0034 1288     		ldrh	r2, [r2]
 301 0036 1A81     		strh	r2, [r3, #8]
 193:../Generated_Code/IO1.c ****   DeviceDataPrv->InpRecvDataNum = 0x00U; /* Set number of received characters to zero. */
 302              		.loc 1 193 0
 303 0038 7B69     		ldr	r3, [r7, #20]
 304 003a 0022     		mov	r2, #0
 305 003c 5A80     		strh	r2, [r3, #2]
 194:../Generated_Code/IO1.c ****   return ERR_OK;                       /* OK */
 306              		.loc 1 194 0
 307 003e 0023     		mov	r3, #0
 308              	.L6:
 195:../Generated_Code/IO1.c **** }
 309              		.loc 1 195 0
 310 0040 181C     		mov	r0, r3
 311 0042 BD46     		mov	sp, r7
 312 0044 06B0     		add	sp, sp, #24
 313              		@ sp needed for prologue
 314 0046 80BD     		pop	{r7, pc}
 315              		.cfi_endproc
 316              	.LFE1:
 318              		.section	.text.InterruptRx,"ax",%progbits
 319              		.align	2
 320              		.code	16
 321              		.thumb_func
 323              	InterruptRx:
 324              	.LFB2:
 196:../Generated_Code/IO1.c **** 
 197:../Generated_Code/IO1.c **** /*
 198:../Generated_Code/IO1.c **** ** ===================================================================
 199:../Generated_Code/IO1.c **** **     Method      :  InterruptRx (component Serial_LDD)
 200:../Generated_Code/IO1.c **** **
 201:../Generated_Code/IO1.c **** **     Description :
 202:../Generated_Code/IO1.c **** **         The method services the receive interrupt of the selected 
 203:../Generated_Code/IO1.c **** **         peripheral(s) and eventually invokes the bean's event(s).
 204:../Generated_Code/IO1.c **** **         This method is internal. It is used by Processor Expert only.
 205:../Generated_Code/IO1.c **** ** ===================================================================
 206:../Generated_Code/IO1.c **** */
 207:../Generated_Code/IO1.c **** static void InterruptRx(IO1_TDeviceDataPtr DeviceDataPrv)
 208:../Generated_Code/IO1.c **** {
 325              		.loc 1 208 0
 326              		.cfi_startproc
 327 0000 90B5     		push	{r4, r7, lr}
 328              	.LCFI6:
 329              		.cfi_def_cfa_offset 12
 330              		.cfi_offset 4, -12
 331              		.cfi_offset 7, -8
 332              		.cfi_offset 14, -4
 333 0002 83B0     		sub	sp, sp, #12
 334              	.LCFI7:
 335              		.cfi_def_cfa_offset 24
 336 0004 00AF     		add	r7, sp, #0
 337              	.LCFI8:
 338              		.cfi_def_cfa_register 7
 339 0006 7860     		str	r0, [r7, #4]
 209:../Generated_Code/IO1.c ****   register uint16_t Data;              /* Temporary variable for data */
 210:../Generated_Code/IO1.c **** 
 211:../Generated_Code/IO1.c ****   Data = (uint16_t)UART0_PDD_GetChar8(UART0_BASE_PTR); /* Read an 8-bit character from the receiver
 340              		.loc 1 211 0
 341 0008 104B     		ldr	r3, .L10
 342 000a DB79     		ldrb	r3, [r3, #7]
 343 000c DBB2     		uxtb	r3, r3
 344 000e 1C1C     		mov	r4, r3
 212:../Generated_Code/IO1.c ****   if (DeviceDataPrv->InpDataNumReq != 0x00U) { /* Is the receive block operation pending? */
 345              		.loc 1 212 0
 346 0010 7B68     		ldr	r3, [r7, #4]
 347 0012 1B89     		ldrh	r3, [r3, #8]
 348 0014 002B     		cmp	r3, #0
 349 0016 15D0     		beq	.L8
 213:../Generated_Code/IO1.c ****     *(DeviceDataPrv->InpDataPtr++) = (uint8_t)Data; /* Put an 8-bit character to the receive buffer
 350              		.loc 1 213 0
 351 0018 7B68     		ldr	r3, [r7, #4]
 352 001a 5B68     		ldr	r3, [r3, #4]
 353 001c E2B2     		uxtb	r2, r4
 354 001e 1A70     		strb	r2, [r3]
 355 0020 5A1C     		add	r2, r3, #1
 356 0022 7B68     		ldr	r3, [r7, #4]
 357 0024 5A60     		str	r2, [r3, #4]
 214:../Generated_Code/IO1.c ****     DeviceDataPrv->InpRecvDataNum++;   /* Increment received char. counter */
 358              		.loc 1 214 0
 359 0026 7B68     		ldr	r3, [r7, #4]
 360 0028 5B88     		ldrh	r3, [r3, #2]
 361 002a 0133     		add	r3, r3, #1
 362 002c 9AB2     		uxth	r2, r3
 363 002e 7B68     		ldr	r3, [r7, #4]
 364 0030 5A80     		strh	r2, [r3, #2]
 215:../Generated_Code/IO1.c ****     if (DeviceDataPrv->InpRecvDataNum == DeviceDataPrv->InpDataNumReq) { /* Is the requested number
 365              		.loc 1 215 0
 366 0032 7B68     		ldr	r3, [r7, #4]
 367 0034 5A88     		ldrh	r2, [r3, #2]
 368 0036 7B68     		ldr	r3, [r7, #4]
 369 0038 1B89     		ldrh	r3, [r3, #8]
 370 003a 9A42     		cmp	r2, r3
 371 003c 02D1     		bne	.L8
 216:../Generated_Code/IO1.c ****       DeviceDataPrv->InpDataNumReq = 0x00U; /* If yes then clear number of requested characters to 
 372              		.loc 1 216 0
 373 003e 7B68     		ldr	r3, [r7, #4]
 374 0040 0022     		mov	r2, #0
 375 0042 1A81     		strh	r2, [r3, #8]
 376              	.L8:
 217:../Generated_Code/IO1.c ****     }
 218:../Generated_Code/IO1.c ****   }
 219:../Generated_Code/IO1.c **** }
 377              		.loc 1 219 0
 378 0044 BD46     		mov	sp, r7
 379 0046 03B0     		add	sp, sp, #12
 380              		@ sp needed for prologue
 381 0048 90BD     		pop	{r4, r7, pc}
 382              	.L11:
 383 004a C046     		.align	2
 384              	.L10:
 385 004c 00A00640 		.word	1074176000
 386              		.cfi_endproc
 387              	.LFE2:
 389              		.section	.text.InterruptTx,"ax",%progbits
 390              		.align	2
 391              		.code	16
 392              		.thumb_func
 394              	InterruptTx:
 395              	.LFB3:
 220:../Generated_Code/IO1.c **** 
 221:../Generated_Code/IO1.c **** /*
 222:../Generated_Code/IO1.c **** ** ===================================================================
 223:../Generated_Code/IO1.c **** **     Method      :  InterruptTx (component Serial_LDD)
 224:../Generated_Code/IO1.c **** **
 225:../Generated_Code/IO1.c **** **     Description :
 226:../Generated_Code/IO1.c **** **         The method services the receive interrupt of the selected 
 227:../Generated_Code/IO1.c **** **         peripheral(s) and eventually invokes the bean's event(s).
 228:../Generated_Code/IO1.c **** **         This method is internal. It is used by Processor Expert only.
 229:../Generated_Code/IO1.c **** ** ===================================================================
 230:../Generated_Code/IO1.c **** */
 231:../Generated_Code/IO1.c **** static void InterruptTx(IO1_TDeviceDataPtr DeviceDataPrv)
 232:../Generated_Code/IO1.c **** {
 396              		.loc 1 232 0
 397              		.cfi_startproc
 398 0000 80B5     		push	{r7, lr}
 399              	.LCFI9:
 400              		.cfi_def_cfa_offset 8
 401              		.cfi_offset 7, -8
 402              		.cfi_offset 14, -4
 403 0002 82B0     		sub	sp, sp, #8
 404              	.LCFI10:
 405              		.cfi_def_cfa_offset 16
 406 0004 00AF     		add	r7, sp, #0
 407              	.LCFI11:
 408              		.cfi_def_cfa_register 7
 409 0006 7860     		str	r0, [r7, #4]
 233:../Generated_Code/IO1.c **** 
 234:../Generated_Code/IO1.c ****   if (DeviceDataPrv->OutSentDataNum < DeviceDataPrv->OutDataNumReq) { /* Is number of sent characte
 410              		.loc 1 234 0
 411 0008 7B68     		ldr	r3, [r7, #4]
 412 000a 5A89     		ldrh	r2, [r3, #10]
 413 000c 7B68     		ldr	r3, [r7, #4]
 414 000e 1B8A     		ldrh	r3, [r3, #16]
 415 0010 9A42     		cmp	r2, r3
 416 0012 17D2     		bcs	.L13
 235:../Generated_Code/IO1.c ****     UART0_PDD_PutChar8(UART0_BASE_PTR, *(DeviceDataPrv->OutDataPtr++)); /* Put a 8-bit character to
 417              		.loc 1 235 0
 418 0014 104A     		ldr	r2, .L15
 419 0016 7B68     		ldr	r3, [r7, #4]
 420 0018 DB68     		ldr	r3, [r3, #12]
 421 001a 1978     		ldrb	r1, [r3]
 422 001c D171     		strb	r1, [r2, #7]
 423 001e 5A1C     		add	r2, r3, #1
 424 0020 7B68     		ldr	r3, [r7, #4]
 425 0022 DA60     		str	r2, [r3, #12]
 236:../Generated_Code/IO1.c ****     DeviceDataPrv->OutSentDataNum++;   /* Increment the counter of sent characters. */
 426              		.loc 1 236 0
 427 0024 7B68     		ldr	r3, [r7, #4]
 428 0026 5B89     		ldrh	r3, [r3, #10]
 429 0028 0133     		add	r3, r3, #1
 430 002a 9AB2     		uxth	r2, r3
 431 002c 7B68     		ldr	r3, [r7, #4]
 432 002e 5A81     		strh	r2, [r3, #10]
 237:../Generated_Code/IO1.c ****     if (DeviceDataPrv->OutSentDataNum == DeviceDataPrv->OutDataNumReq) {
 433              		.loc 1 237 0
 434 0030 7B68     		ldr	r3, [r7, #4]
 435 0032 5A89     		ldrh	r2, [r3, #10]
 436 0034 7B68     		ldr	r3, [r7, #4]
 437 0036 1B8A     		ldrh	r3, [r3, #16]
 438 0038 9A42     		cmp	r2, r3
 439 003a 0AD1     		bne	.L12
 238:../Generated_Code/IO1.c ****       DeviceDataPrv->OutDataNumReq = 0x00U; /* Clear the counter of characters to be send by SendBl
 440              		.loc 1 238 0
 441 003c 7B68     		ldr	r3, [r7, #4]
 442 003e 0022     		mov	r2, #0
 443 0040 1A82     		strh	r2, [r3, #16]
 444 0042 06E0     		b	.L12
 445              	.L13:
 239:../Generated_Code/IO1.c ****     }
 240:../Generated_Code/IO1.c ****   } else {
 241:../Generated_Code/IO1.c ****     DeviceDataPrv->SerFlag &= (uint16_t)(~(uint16_t)ENABLED_TX_INT); /* Clear the flag ENABLED_TX_I
 446              		.loc 1 241 0
 447 0044 7B68     		ldr	r3, [r7, #4]
 448 0046 1B88     		ldrh	r3, [r3]
 449 0048 0122     		mov	r2, #1
 450 004a 9343     		bic	r3, r2
 451 004c 9AB2     		uxth	r2, r3
 452 004e 7B68     		ldr	r3, [r7, #4]
 453 0050 1A80     		strh	r2, [r3]
 454              	.L12:
 242:../Generated_Code/IO1.c ****   }
 243:../Generated_Code/IO1.c **** }
 455              		.loc 1 243 0
 456 0052 BD46     		mov	sp, r7
 457 0054 02B0     		add	sp, sp, #8
 458              		@ sp needed for prologue
 459 0056 80BD     		pop	{r7, pc}
 460              	.L16:
 461              		.align	2
 462              	.L15:
 463 0058 00A00640 		.word	1074176000
 464              		.cfi_endproc
 465              	.LFE3:
 467              		.section	.text.IO1_Main,"ax",%progbits
 468              		.align	2
 469              		.global	IO1_Main
 470              		.code	16
 471              		.thumb_func
 473              	IO1_Main:
 474              	.LFB4:
 244:../Generated_Code/IO1.c **** 
 245:../Generated_Code/IO1.c **** /*
 246:../Generated_Code/IO1.c **** ** ===================================================================
 247:../Generated_Code/IO1.c **** **     Method      :  IO1_Main (component Serial_LDD)
 248:../Generated_Code/IO1.c **** **
 249:../Generated_Code/IO1.c **** **     Description :
 250:../Generated_Code/IO1.c **** **         This method is available only in the polling mode (Interrupt
 251:../Generated_Code/IO1.c **** **         service/event = 'no'). If interrupt service is disabled this
 252:../Generated_Code/IO1.c **** **         method replaces the interrupt handler. This method should be
 253:../Generated_Code/IO1.c **** **         called if Receive/SendBlock was invoked before in order to
 254:../Generated_Code/IO1.c **** **         run the reception/transmission. The end of the
 255:../Generated_Code/IO1.c **** **         receiving/transmitting is indicated by OnBlockSent or
 256:../Generated_Code/IO1.c **** **         OnBlockReceived event. 
 257:../Generated_Code/IO1.c **** **     Parameters  :
 258:../Generated_Code/IO1.c **** **         NAME            - DESCRIPTION
 259:../Generated_Code/IO1.c **** **       * DeviceDataPtr   - Device data structure
 260:../Generated_Code/IO1.c **** **                           pointer returned by <Init> method.
 261:../Generated_Code/IO1.c **** **     Returns     : Nothing
 262:../Generated_Code/IO1.c **** ** ===================================================================
 263:../Generated_Code/IO1.c **** */
 264:../Generated_Code/IO1.c **** void IO1_Main(LDD_TDeviceData *DeviceDataPtr)
 265:../Generated_Code/IO1.c **** {
 475              		.loc 1 265 0
 476              		.cfi_startproc
 477 0000 90B5     		push	{r4, r7, lr}
 478              	.LCFI12:
 479              		.cfi_def_cfa_offset 12
 480              		.cfi_offset 4, -12
 481              		.cfi_offset 7, -8
 482              		.cfi_offset 14, -4
 483 0002 85B0     		sub	sp, sp, #20
 484              	.LCFI13:
 485              		.cfi_def_cfa_offset 32
 486 0004 00AF     		add	r7, sp, #0
 487              	.LCFI14:
 488              		.cfi_def_cfa_register 7
 489 0006 7860     		str	r0, [r7, #4]
 266:../Generated_Code/IO1.c ****   IO1_TDeviceDataPtr DeviceDataPrv = (IO1_TDeviceDataPtr)DeviceDataPtr;
 490              		.loc 1 266 0
 491 0008 7B68     		ldr	r3, [r7, #4]
 492 000a FB60     		str	r3, [r7, #12]
 267:../Generated_Code/IO1.c ****   register uint16_t StatReg = UART0_PDD_ReadInterruptStatusReg(UART0_BASE_PTR); /* Read status regi
 493              		.loc 1 267 0
 494 000c 164B     		ldr	r3, .L21
 495 000e 1B79     		ldrb	r3, [r3, #4]
 496 0010 DBB2     		uxtb	r3, r3
 497 0012 1C1C     		mov	r4, r3
 268:../Generated_Code/IO1.c **** 
 269:../Generated_Code/IO1.c ****   if (StatReg & (UART0_S1_NF_MASK | UART0_S1_OR_MASK | UART0_S1_FE_MASK | UART0_S1_PF_MASK)) { /* I
 498              		.loc 1 269 0
 499 0014 221C     		mov	r2, r4
 500 0016 0F23     		mov	r3, #15
 501 0018 1340     		and	r3, r2
 502 001a 09D0     		beq	.L18
 270:../Generated_Code/IO1.c ****     UART0_PDD_ClearInterruptFlags(UART0_BASE_PTR, (UART0_S1_NF_MASK | UART0_S1_OR_MASK | UART0_S1_F
 503              		.loc 1 270 0
 504 001c 124B     		ldr	r3, .L21
 505 001e 0F22     		mov	r2, #15
 506 0020 1A71     		strb	r2, [r3, #4]
 271:../Generated_Code/IO1.c ****     (void)UART0_PDD_GetChar8(UART0_BASE_PTR); /* Dummy read 8-bit character from receiver */
 507              		.loc 1 271 0
 508 0022 114B     		ldr	r3, .L21
 509 0024 DB79     		ldrb	r3, [r3, #7]
 272:../Generated_Code/IO1.c ****     StatReg &= (uint16_t)(~(uint16_t)UART0_S1_RDRF_MASK); /* Clear the receive data flag to discard
 510              		.loc 1 272 0
 511 0026 2023     		mov	r3, #32
 512 0028 221C     		mov	r2, r4
 513 002a 9A43     		bic	r2, r3
 514 002c 131C     		mov	r3, r2
 515 002e 9CB2     		uxth	r4, r3
 516              	.L18:
 273:../Generated_Code/IO1.c ****   }
 274:../Generated_Code/IO1.c ****   if (StatReg & UART0_S1_RDRF_MASK) {  /* Is the receiver's interrupt flag set? */
 517              		.loc 1 274 0
 518 0030 221C     		mov	r2, r4
 519 0032 2023     		mov	r3, #32
 520 0034 1340     		and	r3, r2
 521 0036 03D0     		beq	.L19
 275:../Generated_Code/IO1.c ****     InterruptRx(DeviceDataPrv);        /* If yes, then invoke the internal service routine. This ro
 522              		.loc 1 275 0
 523 0038 FB68     		ldr	r3, [r7, #12]
 524 003a 181C     		mov	r0, r3
 525 003c FFF7FEFF 		bl	InterruptRx
 526              	.L19:
 276:../Generated_Code/IO1.c ****   }
 277:../Generated_Code/IO1.c ****   if (DeviceDataPrv->SerFlag & ENABLED_TX_INT) { /* Is the transmitter interrupt enabled? */
 527              		.loc 1 277 0
 528 0040 FB68     		ldr	r3, [r7, #12]
 529 0042 1B88     		ldrh	r3, [r3]
 530 0044 1A1C     		mov	r2, r3
 531 0046 0123     		mov	r3, #1
 532 0048 1340     		and	r3, r2
 533 004a DBB2     		uxtb	r3, r3
 534 004c 002B     		cmp	r3, #0
 535 004e 07D0     		beq	.L17
 278:../Generated_Code/IO1.c ****     if (StatReg & UART0_S1_TDRE_MASK) { /* Is the transmitter empty? */
 536              		.loc 1 278 0
 537 0050 221C     		mov	r2, r4
 538 0052 8023     		mov	r3, #128
 539 0054 1340     		and	r3, r2
 540 0056 03D0     		beq	.L17
 279:../Generated_Code/IO1.c ****       InterruptTx(DeviceDataPrv);      /* If yes, then invoke the internal service routine. This ro
 541              		.loc 1 279 0
 542 0058 FB68     		ldr	r3, [r7, #12]
 543 005a 181C     		mov	r0, r3
 544 005c FFF7FEFF 		bl	InterruptTx
 545              	.L17:
 280:../Generated_Code/IO1.c ****     }
 281:../Generated_Code/IO1.c ****   }
 282:../Generated_Code/IO1.c **** }
 546              		.loc 1 282 0
 547 0060 BD46     		mov	sp, r7
 548 0062 05B0     		add	sp, sp, #20
 549              		@ sp needed for prologue
 550 0064 90BD     		pop	{r4, r7, pc}
 551              	.L22:
 552 0066 C046     		.align	2
 553              	.L21:
 554 0068 00A00640 		.word	1074176000
 555              		.cfi_endproc
 556              	.LFE4:
 558              		.text
 559              	.Letext0:
 560              		.file 2 "C:/Freescale/CW MCU v10.3/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 561              		.file 3 "../Generated_Code/PE_LDD.h"
 562              		.file 4 "../Generated_Code/IO_Map.h"
 563              		.file 5 "../Generated_Code/IO1.h"
DEFINED SYMBOLS
                            *ABS*:00000000 IO1.c
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccaXzYdD.s:18     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccaXzYdD.s:21     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 DeviceDataPrv__DEFAULT_RTOS_ALLOC
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccaXzYdD.s:24     .text.IO1_Init:00000000 $t
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccaXzYdD.s:29     .text.IO1_Init:00000000 IO1_Init
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccaXzYdD.s:235    .text.IO1_Init:00000148 $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccaXzYdD.s:248    .text.IO1_ReceiveBlock:00000000 $t
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccaXzYdD.s:253    .text.IO1_ReceiveBlock:00000000 IO1_ReceiveBlock
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccaXzYdD.s:319    .text.InterruptRx:00000000 $t
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccaXzYdD.s:323    .text.InterruptRx:00000000 InterruptRx
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccaXzYdD.s:385    .text.InterruptRx:0000004c $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccaXzYdD.s:390    .text.InterruptTx:00000000 $t
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccaXzYdD.s:394    .text.InterruptTx:00000000 InterruptTx
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccaXzYdD.s:463    .text.InterruptTx:00000058 $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccaXzYdD.s:468    .text.IO1_Main:00000000 $t
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccaXzYdD.s:473    .text.IO1_Main:00000000 IO1_Main
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccaXzYdD.s:554    .text.IO1_Main:00000068 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
PE_LDD_DeviceDataList

   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"I2C2.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC,"aw",%nobits
  18              		.align	2
  21              	DeviceDataPrv__DEFAULT_RTOS_ALLOC:
  22 0000 00000000 		.space	24
  22      00000000 
  22      00000000 
  22      00000000 
  22      00000000 
  23              		.section	.bss.INT_I2C0__DEFAULT_RTOS_ISRPARAM,"aw",%nobits
  24              		.align	2
  27              	INT_I2C0__DEFAULT_RTOS_ISRPARAM:
  28 0000 00000000 		.space	4
  29              		.section	.text.I2C2_Interrupt,"ax",%progbits
  30              		.align	2
  31              		.global	I2C2_Interrupt
  32              		.code	16
  33              		.thumb_func
  35              	I2C2_Interrupt:
  36              	.LFB0:
  37              		.file 1 "../Generated_Code/I2C2.c"
   1:../Generated_Code/I2C2.c **** /** ###################################################################
   2:../Generated_Code/I2C2.c **** **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
   3:../Generated_Code/I2C2.c **** **     Filename    : I2C2.c
   4:../Generated_Code/I2C2.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/I2C2.c **** **     Processor   : MKL25Z128VLK4
   6:../Generated_Code/I2C2.c **** **     Component   : I2C_LDD
   7:../Generated_Code/I2C2.c **** **     Version     : Component 01.011, Driver 01.06, CPU db: 3.00.000
   8:../Generated_Code/I2C2.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/I2C2.c **** **     Date/Time   : 2013-05-10, 22:48, # CodeGen: 0
  10:../Generated_Code/I2C2.c **** **     Abstract    :
  11:../Generated_Code/I2C2.c **** **          This component encapsulates the internal I2C communication
  12:../Generated_Code/I2C2.c **** **          interface. The implementation of the interface is based
  13:../Generated_Code/I2C2.c **** **          on the Philips I2C-bus specification version 2.0.
  14:../Generated_Code/I2C2.c **** **          Interface features:
  15:../Generated_Code/I2C2.c **** **          MASTER mode
  16:../Generated_Code/I2C2.c **** **            - Multi master communication
  17:../Generated_Code/I2C2.c **** **            - The combined format of communication possible
  18:../Generated_Code/I2C2.c **** **              (see SendStop parameter in MasterSend/ReceiveBlock method)
  19:../Generated_Code/I2C2.c **** **            - 7-bit slave addressing (10-bit addressing can be made as well)
  20:../Generated_Code/I2C2.c **** **            - Acknowledge polling provided
  21:../Generated_Code/I2C2.c **** **            - No wait state initiated when a slave device holds the SCL line low
  22:../Generated_Code/I2C2.c **** **            - Holding of the SCL line low by slave device recognized as 'not available bus'
  23:../Generated_Code/I2C2.c **** **            - Invalid start/stop condition detection provided
  24:../Generated_Code/I2C2.c **** **          SLAVE mode
  25:../Generated_Code/I2C2.c **** **            - 7-bit slave addressing
  26:../Generated_Code/I2C2.c **** **            - General call address detection provided
  27:../Generated_Code/I2C2.c **** **     Settings    :
  28:../Generated_Code/I2C2.c **** **          Component name                                 : I2C2
  29:../Generated_Code/I2C2.c **** **          I2C channel                                    : I2C0
  30:../Generated_Code/I2C2.c **** **          Interrupt service                              : Enabled
  31:../Generated_Code/I2C2.c **** **            Interrupt                                    : INT_I2C0
  32:../Generated_Code/I2C2.c **** **            Interrupt priority                           : maximal priority
  33:../Generated_Code/I2C2.c **** **          Settings                                       : 
  34:../Generated_Code/I2C2.c **** **            Mode selection                               : MASTER
  35:../Generated_Code/I2C2.c **** **            MASTER mode                                  : Enabled
  36:../Generated_Code/I2C2.c **** **              Initialization                             : 
  37:../Generated_Code/I2C2.c **** **                Address mode                             : 7-bit addressing
  38:../Generated_Code/I2C2.c **** **                Target slave address init                : 1D
  39:../Generated_Code/I2C2.c **** **            SLAVE mode                                   : Disabled
  40:../Generated_Code/I2C2.c **** **            Pins                                         : 
  41:../Generated_Code/I2C2.c **** **              SDA pin                                    : 
  42:../Generated_Code/I2C2.c **** **                SDA pin                                  : PTE25/TPM0_CH1/I2C0_SDA
  43:../Generated_Code/I2C2.c **** **                SDA pin signal                           : 
  44:../Generated_Code/I2C2.c **** **              SCL pin                                    : 
  45:../Generated_Code/I2C2.c **** **                SCL pin                                  : PTE24/TPM0_CH0/I2C0_SCL
  46:../Generated_Code/I2C2.c **** **                SCL pin signal                           : 
  47:../Generated_Code/I2C2.c **** **              High drive select                          : Disabled
  48:../Generated_Code/I2C2.c **** **              Input Glitch filter                        : 0
  49:../Generated_Code/I2C2.c **** **            Internal frequency (multiplier factor)       : 24 MHz
  50:../Generated_Code/I2C2.c **** **            Bits 0-2 of Frequency divider register       : 000
  51:../Generated_Code/I2C2.c **** **            Bits 3-5 of Frequency divider register       : 000
  52:../Generated_Code/I2C2.c **** **            SCL frequency                                : 1200 kHz
  53:../Generated_Code/I2C2.c **** **            SDA Hold                                     : 0.292 us
  54:../Generated_Code/I2C2.c **** **            SCL start Hold                               : 0.25 us
  55:../Generated_Code/I2C2.c **** **            SCL stop Hold                                : 0.458 us
  56:../Generated_Code/I2C2.c **** **            Control acknowledge bit                      : Disabled
  57:../Generated_Code/I2C2.c **** **            Low timeout                                  : Disabled
  58:../Generated_Code/I2C2.c **** **          Initialization                                 : 
  59:../Generated_Code/I2C2.c **** **            Enabled in init code                         : yes
  60:../Generated_Code/I2C2.c **** **            Auto initialization                          : no
  61:../Generated_Code/I2C2.c **** **            Event mask                                   : 
  62:../Generated_Code/I2C2.c **** **              OnMasterBlockSent                          : Enabled
  63:../Generated_Code/I2C2.c **** **              OnMasterBlockReceived                      : Enabled
  64:../Generated_Code/I2C2.c **** **              OnMasterByteReceived                       : Disabled
  65:../Generated_Code/I2C2.c **** **              OnSlaveBlockSent                           : Disabled
  66:../Generated_Code/I2C2.c **** **              OnSlaveBlockReceived                       : Disabled
  67:../Generated_Code/I2C2.c **** **              OnSlaveByteReceived                        : Disabled
  68:../Generated_Code/I2C2.c **** **              OnSlaveRxRequest                           : Disabled
  69:../Generated_Code/I2C2.c **** **              OnSlaveTxRequest                           : Disabled
  70:../Generated_Code/I2C2.c **** **              OnSlaveGeneralCallAddr                     : Disabled
  71:../Generated_Code/I2C2.c **** **              OnSlaveSmBusCallAddr                       : Disabled
  72:../Generated_Code/I2C2.c **** **              OnSlaveSmBusAlertResponse                  : Disabled
  73:../Generated_Code/I2C2.c **** **              OnError                                    : Enabled
  74:../Generated_Code/I2C2.c **** **              OnBusStopDetected                          : Disabled
  75:../Generated_Code/I2C2.c **** **          CPU clock/configuration selection              : 
  76:../Generated_Code/I2C2.c **** **            Clock configuration 0                        : This component enabled
  77:../Generated_Code/I2C2.c **** **            Clock configuration 1                        : This component disabled
  78:../Generated_Code/I2C2.c **** **            Clock configuration 2                        : This component disabled
  79:../Generated_Code/I2C2.c **** **            Clock configuration 3                        : This component disabled
  80:../Generated_Code/I2C2.c **** **            Clock configuration 4                        : This component disabled
  81:../Generated_Code/I2C2.c **** **            Clock configuration 5                        : This component disabled
  82:../Generated_Code/I2C2.c **** **            Clock configuration 6                        : This component disabled
  83:../Generated_Code/I2C2.c **** **            Clock configuration 7                        : This component disabled
  84:../Generated_Code/I2C2.c **** **     Contents    :
  85:../Generated_Code/I2C2.c **** **         Init               - LDD_TDeviceData* I2C2_Init(LDD_TUserData *UserDataPtr);
  86:../Generated_Code/I2C2.c **** **         Deinit             - void I2C2_Deinit(LDD_TDeviceData *DeviceDataPtr);
  87:../Generated_Code/I2C2.c **** **         MasterSendBlock    - LDD_TError I2C2_MasterSendBlock(LDD_TDeviceData *DeviceDataPtr, LDD
  88:../Generated_Code/I2C2.c **** **         MasterReceiveBlock - LDD_TError I2C2_MasterReceiveBlock(LDD_TDeviceData *DeviceDataPtr, 
  89:../Generated_Code/I2C2.c **** **         SelectSlaveDevice  - LDD_TError I2C2_SelectSlaveDevice(LDD_TDeviceData *DeviceDataPtr,..
  90:../Generated_Code/I2C2.c **** **         GetError           - LDD_TError I2C2_GetError(LDD_TDeviceData *DeviceDataPtr, LDD_I2C_TE
  91:../Generated_Code/I2C2.c **** **
  92:../Generated_Code/I2C2.c **** **     Copyright : 1997 - 2012 Freescale, Inc. All Rights Reserved.
  93:../Generated_Code/I2C2.c **** **     
  94:../Generated_Code/I2C2.c **** **     http      : www.freescale.com
  95:../Generated_Code/I2C2.c **** **     mail      : support@freescale.com
  96:../Generated_Code/I2C2.c **** ** ###################################################################*/
  97:../Generated_Code/I2C2.c **** 
  98:../Generated_Code/I2C2.c **** /* MODULE I2C2. */
  99:../Generated_Code/I2C2.c **** 
 100:../Generated_Code/I2C2.c **** #include "Events.h"
 101:../Generated_Code/I2C2.c **** #include "I2C2.h"
 102:../Generated_Code/I2C2.c **** #include "PORT_PDD.h"
 103:../Generated_Code/I2C2.c **** #include "I2C_PDD.h"
 104:../Generated_Code/I2C2.c **** /* {Default RTOS Adapter} No RTOS includes */
 105:../Generated_Code/I2C2.c **** #include "IO_Map.h"
 106:../Generated_Code/I2C2.c **** 
 107:../Generated_Code/I2C2.c **** 
 108:../Generated_Code/I2C2.c **** /* SerFlag bits */
 109:../Generated_Code/I2C2.c **** #define MASTER_IN_PROGRES       0x01U  /* Communication is in progress (Master) */
 110:../Generated_Code/I2C2.c **** #define ADDR_COMPLETE           0x02U  /* 10-bit address transmission complete   */
 111:../Generated_Code/I2C2.c **** #define REP_ADDR_COMPLETE       0x04U  /* repeated address transmission complete */
 112:../Generated_Code/I2C2.c **** #define GENERAL_CALL            0x08U  /* General call flag */
 113:../Generated_Code/I2C2.c **** #define ADDR_10                 0x10U  /* 10-bit addr flag */
 114:../Generated_Code/I2C2.c **** #define ADDR_7                  0x20U  /* 7-bit addr flag */
 115:../Generated_Code/I2C2.c **** 
 116:../Generated_Code/I2C2.c **** typedef struct {
 117:../Generated_Code/I2C2.c ****   uint8_t SerFlag;                     /* Flags for serial communication */
 118:../Generated_Code/I2C2.c ****                                        /* Bits: 0 - Running int from TX */
 119:../Generated_Code/I2C2.c ****                                        /*       1 - 10-bit address transmission complete   */
 120:../Generated_Code/I2C2.c ****                                        /*       2 - repeated address transmission complete */
 121:../Generated_Code/I2C2.c ****                                        /*       3 - General Call flag */
 122:../Generated_Code/I2C2.c ****                                        /*       4 - 10-bit addr flag */
 123:../Generated_Code/I2C2.c ****                                        /*       5 - 7-bit addr flag */
 124:../Generated_Code/I2C2.c ****   LDD_I2C_TSendStop SendStop;          /* Enable/Disable generate send stop condition after transmi
 125:../Generated_Code/I2C2.c ****   LDD_I2C_TErrorMask ErrorMask;        /* Variable for errors mask value */
 126:../Generated_Code/I2C2.c ****   uint8_t SlaveAddr;                   /* Variable for Slave address */
 127:../Generated_Code/I2C2.c ****   uint8_t SlaveAddrHigh;               /* Variable for High byte of the Slave address (10-bit addre
 128:../Generated_Code/I2C2.c ****   LDD_I2C_TSize InpLenM;               /* The counter of input bufer's content */
 129:../Generated_Code/I2C2.c ****   uint8_t *InpPtrM;                    /* Pointer to input buffer for Master mode */
 130:../Generated_Code/I2C2.c ****   LDD_I2C_TSize OutLenM;               /* The counter of output bufer's content */
 131:../Generated_Code/I2C2.c ****   uint8_t *OutPtrM;                    /* Pointer to output buffer for Master mode */
 132:../Generated_Code/I2C2.c ****   LDD_TUserData *UserData;             /* RTOS device data structure */
 133:../Generated_Code/I2C2.c **** } I2C2_TDeviceData;
 134:../Generated_Code/I2C2.c **** 
 135:../Generated_Code/I2C2.c **** typedef I2C2_TDeviceData *I2C2_TDeviceDataPtr; /* Pointer to the device data structure. */
 136:../Generated_Code/I2C2.c **** 
 137:../Generated_Code/I2C2.c **** /* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
 138:../Generated_Code/I2C2.c **** static I2C2_TDeviceData DeviceDataPrv__DEFAULT_RTOS_ALLOC;
 139:../Generated_Code/I2C2.c **** /* {Default RTOS Adapter} Global variable used for passing a parameter into ISR */
 140:../Generated_Code/I2C2.c **** static I2C2_TDeviceDataPtr INT_I2C0__DEFAULT_RTOS_ISRPARAM;
 141:../Generated_Code/I2C2.c **** 
 142:../Generated_Code/I2C2.c **** #define AVAILABLE_EVENTS_MASK (LDD_I2C_ON_MASTER_BLOCK_SENT | LDD_I2C_ON_MASTER_BLOCK_RECEIVED | LD
 143:../Generated_Code/I2C2.c **** 
 144:../Generated_Code/I2C2.c **** /*
 145:../Generated_Code/I2C2.c **** ** ===================================================================
 146:../Generated_Code/I2C2.c **** **     Method      :  I2C2_Interrupt (component I2C_LDD)
 147:../Generated_Code/I2C2.c **** **
 148:../Generated_Code/I2C2.c **** **     Description :
 149:../Generated_Code/I2C2.c **** **         The method services the interrupt of the selected peripheral(s)
 150:../Generated_Code/I2C2.c **** **         and eventually invokes event(s) of the component.
 151:../Generated_Code/I2C2.c **** **         This method is internal. It is used by Processor Expert only.
 152:../Generated_Code/I2C2.c **** ** ===================================================================
 153:../Generated_Code/I2C2.c **** */
 154:../Generated_Code/I2C2.c **** 
 155:../Generated_Code/I2C2.c **** PE_ISR(I2C2_Interrupt)
 156:../Generated_Code/I2C2.c **** {
  38              		.loc 1 156 0
  39              		.cfi_startproc
  40 0000 90B5     		push	{r4, r7, lr}
  41              	.LCFI0:
  42              		.cfi_def_cfa_offset 12
  43              		.cfi_offset 4, -12
  44              		.cfi_offset 7, -8
  45              		.cfi_offset 14, -4
  46 0002 83B0     		sub	sp, sp, #12
  47              	.LCFI1:
  48              		.cfi_def_cfa_offset 24
  49 0004 00AF     		add	r7, sp, #0
  50              	.LCFI2:
  51              		.cfi_def_cfa_register 7
 157:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} ISR parameter is passed through the global variable */
 158:../Generated_Code/I2C2.c ****   I2C2_TDeviceDataPtr DeviceDataPrv = INT_I2C0__DEFAULT_RTOS_ISRPARAM;
  52              		.loc 1 158 0
  53 0006 AB4B     		ldr	r3, .L16
  54 0008 1B68     		ldr	r3, [r3]
  55 000a 3B60     		str	r3, [r7]
 159:../Generated_Code/I2C2.c ****   LDD_I2C_TErrorMask ErrorMask = 0x00U; /* Temporary variable for error mask */
  56              		.loc 1 159 0
  57 000c BB1D     		add	r3, r7, #6
  58 000e 0022     		mov	r2, #0
  59 0010 1A80     		strh	r2, [r3]
 160:../Generated_Code/I2C2.c ****   register uint8_t Status;             /* Temporary variable for status register */
 161:../Generated_Code/I2C2.c **** 
 162:../Generated_Code/I2C2.c ****   Status = I2C_PDD_ReadStatusReg(I2C0_BASE_PTR); /* Safe status register */
  60              		.loc 1 162 0
  61 0012 A94B     		ldr	r3, .L16+4
  62 0014 DB78     		ldrb	r3, [r3, #3]
  63 0016 DCB2     		uxtb	r4, r3
 163:../Generated_Code/I2C2.c ****   I2C_PDD_ClearInterruptFlags(I2C0_BASE_PTR, (Status)); /* Clear interrupt flag */
  64              		.loc 1 163 0
  65 0018 A74B     		ldr	r3, .L16+4
  66 001a A74A     		ldr	r2, .L16+4
  67 001c D278     		ldrb	r2, [r2, #3]
  68 001e D2B2     		uxtb	r2, r2
  69 0020 D2B2     		uxtb	r2, r2
  70 0022 1221     		mov	r1, #18
  71 0024 8A43     		bic	r2, r1
  72 0026 D1B2     		uxtb	r1, r2
  73 0028 E2B2     		uxtb	r2, r4
  74 002a 0A43     		orr	r2, r1
  75 002c D2B2     		uxtb	r2, r2
  76 002e D2B2     		uxtb	r2, r2
  77 0030 DA70     		strb	r2, [r3, #3]
 164:../Generated_Code/I2C2.c ****   if (I2C_PDD_GetMasterMode(I2C0_BASE_PTR) == I2C_PDD_MASTER_MODE) { /* Is device in master mode? *
  78              		.loc 1 164 0
  79 0032 A14B     		ldr	r3, .L16+4
  80 0034 9B78     		ldrb	r3, [r3, #2]
  81 0036 DBB2     		uxtb	r3, r3
  82 0038 1A1C     		mov	r2, r3
  83 003a 2023     		mov	r3, #32
  84 003c 1340     		and	r3, r2
  85 003e 00D1     		bne	.LCB35
  86 0040 01E1     		b	.L2	@long jump
  87              	.LCB35:
 165:../Generated_Code/I2C2.c ****     if (I2C_PDD_GetTransmitMode(I2C0_BASE_PTR) == I2C_PDD_TX_DIRECTION) { /* Is device in Tx mode? 
  88              		.loc 1 165 0
  89 0042 9D4B     		ldr	r3, .L16+4
  90 0044 9B78     		ldrb	r3, [r3, #2]
  91 0046 DBB2     		uxtb	r3, r3
  92 0048 1A1C     		mov	r2, r3
  93 004a 1023     		mov	r3, #16
  94 004c 1340     		and	r3, r2
  95 004e 00D1     		bne	.LCB43
  96 0050 B8E0     		b	.L3	@long jump
  97              	.LCB43:
 166:../Generated_Code/I2C2.c ****       if ((Status & I2C_PDD_RX_ACKNOWLEDGE) != 0x00U){ /* NACK received? */
  98              		.loc 1 166 0
  99 0052 221C     		mov	r2, r4
 100 0054 0123     		mov	r3, #1
 101 0056 1340     		and	r3, r2
 102 0058 DBB2     		uxtb	r3, r3
 103 005a 002B     		cmp	r3, #0
 104 005c 2AD0     		beq	.L4
 167:../Generated_Code/I2C2.c ****         I2C_PDD_SetMasterMode(I2C0_BASE_PTR, I2C_PDD_SLAVE_MODE); /* Switch device to slave mode (s
 105              		.loc 1 167 0
 106 005e 964B     		ldr	r3, .L16+4
 107 0060 954A     		ldr	r2, .L16+4
 108 0062 9278     		ldrb	r2, [r2, #2]
 109 0064 D2B2     		uxtb	r2, r2
 110 0066 2021     		mov	r1, #32
 111 0068 8A43     		bic	r2, r1
 112 006a D2B2     		uxtb	r2, r2
 113 006c 9A70     		strb	r2, [r3, #2]
 168:../Generated_Code/I2C2.c ****         I2C_PDD_SetTransmitMode(I2C0_BASE_PTR, I2C_PDD_RX_DIRECTION); /* Switch to Rx mode */
 114              		.loc 1 168 0
 115 006e 924B     		ldr	r3, .L16+4
 116 0070 914A     		ldr	r2, .L16+4
 117 0072 9278     		ldrb	r2, [r2, #2]
 118 0074 D2B2     		uxtb	r2, r2
 119 0076 1021     		mov	r1, #16
 120 0078 8A43     		bic	r2, r1
 121 007a D2B2     		uxtb	r2, r2
 122 007c 9A70     		strb	r2, [r3, #2]
 169:../Generated_Code/I2C2.c ****         DeviceDataPrv->OutLenM = 0x00U; /* No character for sending */
 123              		.loc 1 169 0
 124 007e 3B68     		ldr	r3, [r7]
 125 0080 0022     		mov	r2, #0
 126 0082 9A81     		strh	r2, [r3, #12]
 170:../Generated_Code/I2C2.c ****         DeviceDataPrv->InpLenM = 0x00U; /* No character for reception */
 127              		.loc 1 170 0
 128 0084 3B68     		ldr	r3, [r7]
 129 0086 0022     		mov	r2, #0
 130 0088 DA80     		strh	r2, [r3, #6]
 171:../Generated_Code/I2C2.c ****         DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* No character for sending or rec
 131              		.loc 1 171 0
 132 008a 3B68     		ldr	r3, [r7]
 133 008c 1B78     		ldrb	r3, [r3]
 134 008e 0122     		mov	r2, #1
 135 0090 9343     		bic	r3, r2
 136 0092 DAB2     		uxtb	r2, r3
 137 0094 3B68     		ldr	r3, [r7]
 138 0096 1A70     		strb	r2, [r3]
 172:../Generated_Code/I2C2.c ****         DeviceDataPrv->SerFlag |= (ADDR_COMPLETE | REP_ADDR_COMPLETE); /* Set the flag */
 139              		.loc 1 172 0
 140 0098 3B68     		ldr	r3, [r7]
 141 009a 1B78     		ldrb	r3, [r3]
 142 009c 0622     		mov	r2, #6
 143 009e 1343     		orr	r3, r2
 144 00a0 DAB2     		uxtb	r2, r3
 145 00a2 3B68     		ldr	r3, [r7]
 146 00a4 1A70     		strb	r2, [r3]
 173:../Generated_Code/I2C2.c ****         ErrorMask |= LDD_I2C_MASTER_NACK; /* Set the Master Nack error mask */
 147              		.loc 1 173 0
 148 00a6 BB1D     		add	r3, r7, #6
 149 00a8 BA1D     		add	r2, r7, #6
 150 00aa 1288     		ldrh	r2, [r2]
 151 00ac 0821     		mov	r1, #8
 152 00ae 0A43     		orr	r2, r1
 153 00b0 1A80     		strh	r2, [r3]
 154 00b2 EAE0     		b	.L5
 155              	.L4:
 174:../Generated_Code/I2C2.c ****       } else {
 175:../Generated_Code/I2C2.c ****         if ((DeviceDataPrv->SerFlag & ADDR_COMPLETE) != 0x00U) { /* If 10-bit addr has been complet
 156              		.loc 1 175 0
 157 00b4 3B68     		ldr	r3, [r7]
 158 00b6 1B78     		ldrb	r3, [r3]
 159 00b8 1A1C     		mov	r2, r3
 160 00ba 0223     		mov	r3, #2
 161 00bc 1340     		and	r3, r2
 162 00be 00D1     		bne	.LCB102
 163 00c0 74E0     		b	.L6	@long jump
 164              	.LCB102:
 176:../Generated_Code/I2C2.c ****           if (DeviceDataPrv->OutLenM != 0x00U) { /* Is any char. for transmitting? */
 165              		.loc 1 176 0
 166 00c2 3B68     		ldr	r3, [r7]
 167 00c4 9B89     		ldrh	r3, [r3, #12]
 168 00c6 002B     		cmp	r3, #0
 169 00c8 0ED0     		beq	.L7
 177:../Generated_Code/I2C2.c ****             DeviceDataPrv->OutLenM--;  /* Decrease number of chars for the transmit */
 170              		.loc 1 177 0
 171 00ca 3B68     		ldr	r3, [r7]
 172 00cc 9B89     		ldrh	r3, [r3, #12]
 173 00ce 013B     		sub	r3, r3, #1
 174 00d0 9AB2     		uxth	r2, r3
 175 00d2 3B68     		ldr	r3, [r7]
 176 00d4 9A81     		strh	r2, [r3, #12]
 178:../Generated_Code/I2C2.c ****             I2C_PDD_WriteDataReg(I2C0_BASE_PTR, *(DeviceDataPrv->OutPtrM)++); /* Send character */
 177              		.loc 1 178 0
 178 00d6 784A     		ldr	r2, .L16+4
 179 00d8 3B68     		ldr	r3, [r7]
 180 00da 1B69     		ldr	r3, [r3, #16]
 181 00dc 1978     		ldrb	r1, [r3]
 182 00de 1171     		strb	r1, [r2, #4]
 183 00e0 5A1C     		add	r2, r3, #1
 184 00e2 3B68     		ldr	r3, [r7]
 185 00e4 1A61     		str	r2, [r3, #16]
 186 00e6 D0E0     		b	.L5
 187              	.L7:
 179:../Generated_Code/I2C2.c ****           }
 180:../Generated_Code/I2C2.c ****           else {
 181:../Generated_Code/I2C2.c ****             if (DeviceDataPrv->InpLenM != 0x00U) { /* Is any char. for reception? */
 188              		.loc 1 181 0
 189 00e8 3B68     		ldr	r3, [r7]
 190 00ea DB88     		ldrh	r3, [r3, #6]
 191 00ec 002B     		cmp	r3, #0
 192 00ee 3CD0     		beq	.L8
 182:../Generated_Code/I2C2.c ****               if ((DeviceDataPrv->SerFlag & REP_ADDR_COMPLETE) != 0x00U) { /* If repeated start and
 193              		.loc 1 182 0
 194 00f0 3B68     		ldr	r3, [r7]
 195 00f2 1B78     		ldrb	r3, [r3]
 196 00f4 1A1C     		mov	r2, r3
 197 00f6 0423     		mov	r3, #4
 198 00f8 1340     		and	r3, r2
 199 00fa 1FD0     		beq	.L9
 183:../Generated_Code/I2C2.c ****                 if (DeviceDataPrv->InpLenM == 0x01U) { /* If only one char to receive */
 200              		.loc 1 183 0
 201 00fc 3B68     		ldr	r3, [r7]
 202 00fe DB88     		ldrh	r3, [r3, #6]
 203 0100 012B     		cmp	r3, #1
 204 0102 08D1     		bne	.L10
 184:../Generated_Code/I2C2.c ****                   I2C_PDD_EnableTransmitAcknowledge(I2C0_BASE_PTR, PDD_DISABLE); /* then transmit A
 205              		.loc 1 184 0
 206 0104 6C4B     		ldr	r3, .L16+4
 207 0106 6C4A     		ldr	r2, .L16+4
 208 0108 9278     		ldrb	r2, [r2, #2]
 209 010a D2B2     		uxtb	r2, r2
 210 010c 0821     		mov	r1, #8
 211 010e 0A43     		orr	r2, r1
 212 0110 D2B2     		uxtb	r2, r2
 213 0112 9A70     		strb	r2, [r3, #2]
 214 0114 07E0     		b	.L11
 215              	.L10:
 185:../Generated_Code/I2C2.c ****                 } else {
 186:../Generated_Code/I2C2.c ****                   I2C_PDD_EnableTransmitAcknowledge(I2C0_BASE_PTR, PDD_ENABLE); /* else transmit AC
 216              		.loc 1 186 0
 217 0116 684B     		ldr	r3, .L16+4
 218 0118 674A     		ldr	r2, .L16+4
 219 011a 9278     		ldrb	r2, [r2, #2]
 220 011c D2B2     		uxtb	r2, r2
 221 011e 0821     		mov	r1, #8
 222 0120 8A43     		bic	r2, r1
 223 0122 D2B2     		uxtb	r2, r2
 224 0124 9A70     		strb	r2, [r3, #2]
 225              	.L11:
 187:../Generated_Code/I2C2.c ****                 }
 188:../Generated_Code/I2C2.c ****                 I2C_PDD_SetTransmitMode(I2C0_BASE_PTR, I2C_PDD_RX_DIRECTION); /* Switch to Rx mode 
 226              		.loc 1 188 0
 227 0126 644B     		ldr	r3, .L16+4
 228 0128 634A     		ldr	r2, .L16+4
 229 012a 9278     		ldrb	r2, [r2, #2]
 230 012c D2B2     		uxtb	r2, r2
 231 012e 1021     		mov	r1, #16
 232 0130 8A43     		bic	r2, r1
 233 0132 D2B2     		uxtb	r2, r2
 234 0134 9A70     		strb	r2, [r3, #2]
 189:../Generated_Code/I2C2.c ****                 (void)I2C_PDD_ReadDataReg(I2C0_BASE_PTR); /* Dummy read character */
 235              		.loc 1 189 0
 236 0136 604B     		ldr	r3, .L16+4
 237 0138 1B79     		ldrb	r3, [r3, #4]
 238 013a A6E0     		b	.L5
 239              	.L9:
 190:../Generated_Code/I2C2.c ****               } else {                 /* Repeated address has not been completed for 10-bit addres
 191:../Generated_Code/I2C2.c ****                 I2C_PDD_RepeatStart(I2C0_BASE_PTR); /* Repeat start cycle generated */
 240              		.loc 1 191 0
 241 013c 5E4B     		ldr	r3, .L16+4
 242 013e 5E4A     		ldr	r2, .L16+4
 243 0140 9278     		ldrb	r2, [r2, #2]
 244 0142 D2B2     		uxtb	r2, r2
 245 0144 0421     		mov	r1, #4
 246 0146 0A43     		orr	r2, r1
 247 0148 D2B2     		uxtb	r2, r2
 248 014a 9A70     		strb	r2, [r3, #2]
 192:../Generated_Code/I2C2.c ****                 I2C_PDD_WriteDataReg(I2C0_BASE_PTR, (uint8_t)(DeviceDataPrv->SlaveAddrHigh | 0x01U)
 249              		.loc 1 192 0
 250 014c 5A4B     		ldr	r3, .L16+4
 251 014e 3A68     		ldr	r2, [r7]
 252 0150 5279     		ldrb	r2, [r2, #5]
 253 0152 0121     		mov	r1, #1
 254 0154 0A43     		orr	r2, r1
 255 0156 D2B2     		uxtb	r2, r2
 256 0158 1A71     		strb	r2, [r3, #4]
 193:../Generated_Code/I2C2.c ****                 DeviceDataPrv->SerFlag |= REP_ADDR_COMPLETE;
 257              		.loc 1 193 0
 258 015a 3B68     		ldr	r3, [r7]
 259 015c 1B78     		ldrb	r3, [r3]
 260 015e 0422     		mov	r2, #4
 261 0160 1343     		orr	r3, r2
 262 0162 DAB2     		uxtb	r2, r3
 263 0164 3B68     		ldr	r3, [r7]
 264 0166 1A70     		strb	r2, [r3]
 265 0168 8FE0     		b	.L5
 266              	.L8:
 194:../Generated_Code/I2C2.c ****               }
 195:../Generated_Code/I2C2.c ****             }
 196:../Generated_Code/I2C2.c ****             else {
 197:../Generated_Code/I2C2.c ****               DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* Clear flag "busy" */
 267              		.loc 1 197 0
 268 016a 3B68     		ldr	r3, [r7]
 269 016c 1B78     		ldrb	r3, [r3]
 270 016e 0122     		mov	r2, #1
 271 0170 9343     		bic	r3, r2
 272 0172 DAB2     		uxtb	r2, r3
 273 0174 3B68     		ldr	r3, [r7]
 274 0176 1A70     		strb	r2, [r3]
 198:../Generated_Code/I2C2.c ****               if (DeviceDataPrv->SendStop == LDD_I2C_SEND_STOP) {
 275              		.loc 1 198 0
 276 0178 3B68     		ldr	r3, [r7]
 277 017a 5B78     		ldrb	r3, [r3, #1]
 278 017c 012B     		cmp	r3, #1
 279 017e 0FD1     		bne	.L12
 199:../Generated_Code/I2C2.c ****                 I2C_PDD_SetMasterMode(I2C0_BASE_PTR, I2C_PDD_SLAVE_MODE); /* Switch device to slave
 280              		.loc 1 199 0
 281 0180 4D4B     		ldr	r3, .L16+4
 282 0182 4D4A     		ldr	r2, .L16+4
 283 0184 9278     		ldrb	r2, [r2, #2]
 284 0186 D2B2     		uxtb	r2, r2
 285 0188 2021     		mov	r1, #32
 286 018a 8A43     		bic	r2, r1
 287 018c D2B2     		uxtb	r2, r2
 288 018e 9A70     		strb	r2, [r3, #2]
 200:../Generated_Code/I2C2.c ****                 I2C_PDD_SetTransmitMode(I2C0_BASE_PTR, I2C_PDD_RX_DIRECTION); /* Switch to Rx mode 
 289              		.loc 1 200 0
 290 0190 494B     		ldr	r3, .L16+4
 291 0192 494A     		ldr	r2, .L16+4
 292 0194 9278     		ldrb	r2, [r2, #2]
 293 0196 D2B2     		uxtb	r2, r2
 294 0198 1021     		mov	r1, #16
 295 019a 8A43     		bic	r2, r1
 296 019c D2B2     		uxtb	r2, r2
 297 019e 9A70     		strb	r2, [r3, #2]
 298              	.L12:
 201:../Generated_Code/I2C2.c ****               }
 202:../Generated_Code/I2C2.c ****               I2C2_OnMasterBlockSent(DeviceDataPrv->UserData); /* Invoke OnMasterBlockSent event */
 299              		.loc 1 202 0
 300 01a0 3B68     		ldr	r3, [r7]
 301 01a2 5B69     		ldr	r3, [r3, #20]
 302 01a4 181C     		mov	r0, r3
 303 01a6 FFF7FEFF 		bl	I2C2_OnMasterBlockSent
 304 01aa 6EE0     		b	.L5
 305              	.L6:
 203:../Generated_Code/I2C2.c ****             }
 204:../Generated_Code/I2C2.c ****           }
 205:../Generated_Code/I2C2.c ****         } else {
 206:../Generated_Code/I2C2.c ****           I2C_PDD_WriteDataReg(I2C0_BASE_PTR, DeviceDataPrv->SlaveAddr); /* Send second part of the
 306              		.loc 1 206 0
 307 01ac 424B     		ldr	r3, .L16+4
 308 01ae 3A68     		ldr	r2, [r7]
 309 01b0 1279     		ldrb	r2, [r2, #4]
 310 01b2 1A71     		strb	r2, [r3, #4]
 207:../Generated_Code/I2C2.c ****           DeviceDataPrv->SerFlag |= (ADDR_COMPLETE); /* Address complete */
 311              		.loc 1 207 0
 312 01b4 3B68     		ldr	r3, [r7]
 313 01b6 1B78     		ldrb	r3, [r3]
 314 01b8 0222     		mov	r2, #2
 315 01ba 1343     		orr	r3, r2
 316 01bc DAB2     		uxtb	r2, r3
 317 01be 3B68     		ldr	r3, [r7]
 318 01c0 1A70     		strb	r2, [r3]
 319 01c2 62E0     		b	.L5
 320              	.L3:
 208:../Generated_Code/I2C2.c ****         }
 209:../Generated_Code/I2C2.c ****       }
 210:../Generated_Code/I2C2.c ****     }
 211:../Generated_Code/I2C2.c ****     else {
 212:../Generated_Code/I2C2.c ****       DeviceDataPrv->InpLenM--;        /* Decrease number of chars for the receive */
 321              		.loc 1 212 0
 322 01c4 3B68     		ldr	r3, [r7]
 323 01c6 DB88     		ldrh	r3, [r3, #6]
 324 01c8 013B     		sub	r3, r3, #1
 325 01ca 9AB2     		uxth	r2, r3
 326 01cc 3B68     		ldr	r3, [r7]
 327 01ce DA80     		strh	r2, [r3, #6]
 213:../Generated_Code/I2C2.c ****       if (DeviceDataPrv->InpLenM != 0x00U) { /* Is any char. for reception? */
 328              		.loc 1 213 0
 329 01d0 3B68     		ldr	r3, [r7]
 330 01d2 DB88     		ldrh	r3, [r3, #6]
 331 01d4 002B     		cmp	r3, #0
 332 01d6 0CD0     		beq	.L13
 214:../Generated_Code/I2C2.c ****         if (DeviceDataPrv->InpLenM == 0x01U) {
 333              		.loc 1 214 0
 334 01d8 3B68     		ldr	r3, [r7]
 335 01da DB88     		ldrh	r3, [r3, #6]
 336 01dc 012B     		cmp	r3, #1
 337 01de 1FD1     		bne	.L14
 215:../Generated_Code/I2C2.c ****           I2C_PDD_EnableTransmitAcknowledge(I2C0_BASE_PTR, PDD_DISABLE); /* Transmit NACK */
 338              		.loc 1 215 0
 339 01e0 354B     		ldr	r3, .L16+4
 340 01e2 354A     		ldr	r2, .L16+4
 341 01e4 9278     		ldrb	r2, [r2, #2]
 342 01e6 D2B2     		uxtb	r2, r2
 343 01e8 0821     		mov	r1, #8
 344 01ea 0A43     		orr	r2, r1
 345 01ec D2B2     		uxtb	r2, r2
 346 01ee 9A70     		strb	r2, [r3, #2]
 347 01f0 16E0     		b	.L14
 348              	.L13:
 216:../Generated_Code/I2C2.c ****         }
 217:../Generated_Code/I2C2.c ****       } else {
 218:../Generated_Code/I2C2.c ****         DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* Clear flag "busy" */
 349              		.loc 1 218 0
 350 01f2 3B68     		ldr	r3, [r7]
 351 01f4 1B78     		ldrb	r3, [r3]
 352 01f6 0122     		mov	r2, #1
 353 01f8 9343     		bic	r3, r2
 354 01fa DAB2     		uxtb	r2, r3
 355 01fc 3B68     		ldr	r3, [r7]
 356 01fe 1A70     		strb	r2, [r3]
 219:../Generated_Code/I2C2.c ****         I2C_PDD_SetMasterMode(I2C0_BASE_PTR, I2C_PDD_SLAVE_MODE); /* If no, switch device to slave 
 357              		.loc 1 219 0
 358 0200 2D4B     		ldr	r3, .L16+4
 359 0202 2D4A     		ldr	r2, .L16+4
 360 0204 9278     		ldrb	r2, [r2, #2]
 361 0206 D2B2     		uxtb	r2, r2
 362 0208 2021     		mov	r1, #32
 363 020a 8A43     		bic	r2, r1
 364 020c D2B2     		uxtb	r2, r2
 365 020e 9A70     		strb	r2, [r3, #2]
 220:../Generated_Code/I2C2.c ****         I2C_PDD_EnableTransmitAcknowledge(I2C0_BASE_PTR, PDD_ENABLE); /* Transmit ACK */
 366              		.loc 1 220 0
 367 0210 294B     		ldr	r3, .L16+4
 368 0212 294A     		ldr	r2, .L16+4
 369 0214 9278     		ldrb	r2, [r2, #2]
 370 0216 D2B2     		uxtb	r2, r2
 371 0218 0821     		mov	r1, #8
 372 021a 8A43     		bic	r2, r1
 373 021c D2B2     		uxtb	r2, r2
 374 021e 9A70     		strb	r2, [r3, #2]
 375              	.L14:
 221:../Generated_Code/I2C2.c ****       }
 222:../Generated_Code/I2C2.c ****       *(DeviceDataPrv->InpPtrM)++ = I2C_PDD_ReadDataReg(I2C0_BASE_PTR); /* Receive character */
 376              		.loc 1 222 0
 377 0220 3B68     		ldr	r3, [r7]
 378 0222 9B68     		ldr	r3, [r3, #8]
 379 0224 244A     		ldr	r2, .L16+4
 380 0226 1279     		ldrb	r2, [r2, #4]
 381 0228 D2B2     		uxtb	r2, r2
 382 022a 1A70     		strb	r2, [r3]
 383 022c 5A1C     		add	r2, r3, #1
 384 022e 3B68     		ldr	r3, [r7]
 385 0230 9A60     		str	r2, [r3, #8]
 223:../Generated_Code/I2C2.c ****       if (DeviceDataPrv->InpLenM == 0x00U) { /* Is any char. for reception? */
 386              		.loc 1 223 0
 387 0232 3B68     		ldr	r3, [r7]
 388 0234 DB88     		ldrh	r3, [r3, #6]
 389 0236 002B     		cmp	r3, #0
 390 0238 27D1     		bne	.L5
 224:../Generated_Code/I2C2.c ****         I2C2_OnMasterBlockReceived(DeviceDataPrv->UserData); /* Invoke OnMasterBlockReceived event 
 391              		.loc 1 224 0
 392 023a 3B68     		ldr	r3, [r7]
 393 023c 5B69     		ldr	r3, [r3, #20]
 394 023e 181C     		mov	r0, r3
 395 0240 FFF7FEFF 		bl	I2C2_OnMasterBlockReceived
 396 0244 21E0     		b	.L5
 397              	.L2:
 225:../Generated_Code/I2C2.c ****       }
 226:../Generated_Code/I2C2.c ****     }
 227:../Generated_Code/I2C2.c ****   } else {
 228:../Generated_Code/I2C2.c ****     if ((Status & I2C_PDD_ARBIT_LOST) != 0x00U) { /* Arbitration lost? */
 398              		.loc 1 228 0
 399 0246 221C     		mov	r2, r4
 400 0248 1023     		mov	r3, #16
 401 024a 1340     		and	r3, r2
 402 024c 1DD0     		beq	.L5
 229:../Generated_Code/I2C2.c ****       DeviceDataPrv->OutLenM = 0x00U;  /* Any character is not for sent */
 403              		.loc 1 229 0
 404 024e 3B68     		ldr	r3, [r7]
 405 0250 0022     		mov	r2, #0
 406 0252 9A81     		strh	r2, [r3, #12]
 230:../Generated_Code/I2C2.c ****       DeviceDataPrv->InpLenM = 0x00U;  /* Any character is not for reception */
 407              		.loc 1 230 0
 408 0254 3B68     		ldr	r3, [r7]
 409 0256 0022     		mov	r2, #0
 410 0258 DA80     		strh	r2, [r3, #6]
 231:../Generated_Code/I2C2.c ****       DeviceDataPrv->SendStop = LDD_I2C_SEND_STOP; /* Set variable for sending stop condition (for 
 411              		.loc 1 231 0
 412 025a 3B68     		ldr	r3, [r7]
 413 025c 0122     		mov	r2, #1
 414 025e 5A70     		strb	r2, [r3, #1]
 232:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* Any character is not for sent or 
 415              		.loc 1 232 0
 416 0260 3B68     		ldr	r3, [r7]
 417 0262 1B78     		ldrb	r3, [r3]
 418 0264 0122     		mov	r2, #1
 419 0266 9343     		bic	r3, r2
 420 0268 DAB2     		uxtb	r2, r3
 421 026a 3B68     		ldr	r3, [r7]
 422 026c 1A70     		strb	r2, [r3]
 233:../Generated_Code/I2C2.c ****       I2C_PDD_SetTransmitMode(I2C0_BASE_PTR, I2C_PDD_RX_DIRECTION); /* Switch to Rx mode */
 423              		.loc 1 233 0
 424 026e 124B     		ldr	r3, .L16+4
 425 0270 114A     		ldr	r2, .L16+4
 426 0272 9278     		ldrb	r2, [r2, #2]
 427 0274 D2B2     		uxtb	r2, r2
 428 0276 1021     		mov	r1, #16
 429 0278 8A43     		bic	r2, r1
 430 027a D2B2     		uxtb	r2, r2
 431 027c 9A70     		strb	r2, [r3, #2]
 234:../Generated_Code/I2C2.c ****       ErrorMask |= LDD_I2C_ARBIT_LOST; /* Set the ArbitLost error mask */
 432              		.loc 1 234 0
 433 027e BB1D     		add	r3, r7, #6
 434 0280 BA1D     		add	r2, r7, #6
 435 0282 1288     		ldrh	r2, [r2]
 436 0284 0421     		mov	r1, #4
 437 0286 0A43     		orr	r2, r1
 438 0288 1A80     		strh	r2, [r3]
 439              	.L5:
 235:../Generated_Code/I2C2.c ****     }
 236:../Generated_Code/I2C2.c ****   }
 237:../Generated_Code/I2C2.c ****   if (ErrorMask != 0x00U) {            /* Is any error mask set? */
 440              		.loc 1 237 0
 441 028a BB1D     		add	r3, r7, #6
 442 028c 1B88     		ldrh	r3, [r3]
 443 028e 002B     		cmp	r3, #0
 444 0290 0CD0     		beq	.L1
 238:../Generated_Code/I2C2.c ****     DeviceDataPrv->ErrorMask |= ErrorMask; /* Update list of error mask value */
 445              		.loc 1 238 0
 446 0292 3B68     		ldr	r3, [r7]
 447 0294 5A88     		ldrh	r2, [r3, #2]
 448 0296 BB1D     		add	r3, r7, #6
 449 0298 1B88     		ldrh	r3, [r3]
 450 029a 1343     		orr	r3, r2
 451 029c 9AB2     		uxth	r2, r3
 452 029e 3B68     		ldr	r3, [r7]
 453 02a0 5A80     		strh	r2, [r3, #2]
 239:../Generated_Code/I2C2.c ****     I2C2_OnError(DeviceDataPrv->UserData); /* If yes then invoke user event */
 454              		.loc 1 239 0
 455 02a2 3B68     		ldr	r3, [r7]
 456 02a4 5B69     		ldr	r3, [r3, #20]
 457 02a6 181C     		mov	r0, r3
 458 02a8 FFF7FEFF 		bl	I2C2_OnError
 459              	.L1:
 240:../Generated_Code/I2C2.c ****   }
 241:../Generated_Code/I2C2.c **** }
 460              		.loc 1 241 0
 461 02ac BD46     		mov	sp, r7
 462 02ae 03B0     		add	sp, sp, #12
 463              		@ sp needed for prologue
 464 02b0 90BD     		pop	{r4, r7, pc}
 465              	.L17:
 466 02b2 C046     		.align	2
 467              	.L16:
 468 02b4 00000000 		.word	INT_I2C0__DEFAULT_RTOS_ISRPARAM
 469 02b8 00600640 		.word	1074159616
 470              		.cfi_endproc
 471              	.LFE0:
 473              		.section	.text.I2C2_Init,"ax",%progbits
 474              		.align	2
 475              		.global	I2C2_Init
 476              		.code	16
 477              		.thumb_func
 479              	I2C2_Init:
 480              	.LFB1:
 242:../Generated_Code/I2C2.c **** 
 243:../Generated_Code/I2C2.c **** /*
 244:../Generated_Code/I2C2.c **** ** ===================================================================
 245:../Generated_Code/I2C2.c **** **     Method      :  I2C2_Init (component I2C_LDD)
 246:../Generated_Code/I2C2.c **** **
 247:../Generated_Code/I2C2.c **** **     Description :
 248:../Generated_Code/I2C2.c **** **         Initializes the device. Allocates memory for the device data
 249:../Generated_Code/I2C2.c **** **         structure, allocates interrupt vectors and sets interrupt
 250:../Generated_Code/I2C2.c **** **         priority, sets pin routing, sets timing, etc.
 251:../Generated_Code/I2C2.c **** **         If the "Enable in init. code" is set to "yes" value then the
 252:../Generated_Code/I2C2.c **** **         device is also enabled(see the description of the Enable()
 253:../Generated_Code/I2C2.c **** **         method). In this case the Enable() method is not necessary
 254:../Generated_Code/I2C2.c **** **         and needn't to be generated. 
 255:../Generated_Code/I2C2.c **** **         This method can be called only once. Before the second call
 256:../Generated_Code/I2C2.c **** **         of Init() the Deinit() must be called first.
 257:../Generated_Code/I2C2.c **** **     Parameters  :
 258:../Generated_Code/I2C2.c **** **         NAME            - DESCRIPTION
 259:../Generated_Code/I2C2.c **** **       * UserDataPtr     - Pointer to the user or
 260:../Generated_Code/I2C2.c **** **                           RTOS specific data. This pointer will be
 261:../Generated_Code/I2C2.c **** **                           passed as an event or callback parameter.
 262:../Generated_Code/I2C2.c **** **     Returns     :
 263:../Generated_Code/I2C2.c **** **         ---             - Pointer to the device data structure. 
 264:../Generated_Code/I2C2.c **** ** ===================================================================
 265:../Generated_Code/I2C2.c **** */
 266:../Generated_Code/I2C2.c **** LDD_TDeviceData* I2C2_Init(LDD_TUserData *UserDataPtr)
 267:../Generated_Code/I2C2.c **** {
 481              		.loc 1 267 0
 482              		.cfi_startproc
 483 0000 80B5     		push	{r7, lr}
 484              	.LCFI3:
 485              		.cfi_def_cfa_offset 8
 486              		.cfi_offset 7, -8
 487              		.cfi_offset 14, -4
 488 0002 84B0     		sub	sp, sp, #16
 489              	.LCFI4:
 490              		.cfi_def_cfa_offset 24
 491 0004 00AF     		add	r7, sp, #0
 492              	.LCFI5:
 493              		.cfi_def_cfa_register 7
 494 0006 7860     		str	r0, [r7, #4]
 268:../Generated_Code/I2C2.c ****   /* Allocate HAL device structure */
 269:../Generated_Code/I2C2.c ****   I2C2_TDeviceData *DeviceDataPrv;
 270:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer 
 271:../Generated_Code/I2C2.c ****   DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;
 495              		.loc 1 271 0
 496 0008 3C4B     		ldr	r3, .L19
 497 000a FB60     		str	r3, [r7, #12]
 272:../Generated_Code/I2C2.c **** 
 273:../Generated_Code/I2C2.c ****   DeviceDataPrv->UserData = UserDataPtr; /* Store the RTOS device structure */
 498              		.loc 1 273 0
 499 000c FB68     		ldr	r3, [r7, #12]
 500 000e 7A68     		ldr	r2, [r7, #4]
 501 0010 5A61     		str	r2, [r3, #20]
 274:../Generated_Code/I2C2.c **** 
 275:../Generated_Code/I2C2.c ****   /* Allocate interrupt vector */
 276:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the glo
 277:../Generated_Code/I2C2.c ****   INT_I2C0__DEFAULT_RTOS_ISRPARAM = DeviceDataPrv;
 502              		.loc 1 277 0
 503 0012 3B4B     		ldr	r3, .L19+4
 504 0014 FA68     		ldr	r2, [r7, #12]
 505 0016 1A60     		str	r2, [r3]
 278:../Generated_Code/I2C2.c ****   DeviceDataPrv->SerFlag = ADDR_7;     /* Reset all flags start with 7-bit address mode */
 506              		.loc 1 278 0
 507 0018 FB68     		ldr	r3, [r7, #12]
 508 001a 2022     		mov	r2, #32
 509 001c 1A70     		strb	r2, [r3]
 279:../Generated_Code/I2C2.c ****   DeviceDataPrv->SlaveAddr = 0x3AU;    /* Set variable for slave address */
 510              		.loc 1 279 0
 511 001e FB68     		ldr	r3, [r7, #12]
 512 0020 3A22     		mov	r2, #58
 513 0022 1A71     		strb	r2, [r3, #4]
 280:../Generated_Code/I2C2.c ****   DeviceDataPrv->SendStop = LDD_I2C_SEND_STOP; /* Set variable for sending stop condition (for mast
 514              		.loc 1 280 0
 515 0024 FB68     		ldr	r3, [r7, #12]
 516 0026 0122     		mov	r2, #1
 517 0028 5A70     		strb	r2, [r3, #1]
 281:../Generated_Code/I2C2.c ****   DeviceDataPrv->InpLenM = 0x00U;      /* Set zero counter of data of reception */
 518              		.loc 1 281 0
 519 002a FB68     		ldr	r3, [r7, #12]
 520 002c 0022     		mov	r2, #0
 521 002e DA80     		strh	r2, [r3, #6]
 282:../Generated_Code/I2C2.c ****   DeviceDataPrv->OutLenM = 0x00U;      /* Set zero counter of data of transmission */
 522              		.loc 1 282 0
 523 0030 FB68     		ldr	r3, [r7, #12]
 524 0032 0022     		mov	r2, #0
 525 0034 9A81     		strh	r2, [r3, #12]
 283:../Generated_Code/I2C2.c ****   DeviceDataPrv->ErrorMask = 0x00U;    /* Clear variable for errors mask value */
 526              		.loc 1 283 0
 527 0036 FB68     		ldr	r3, [r7, #12]
 528 0038 0022     		mov	r2, #0
 529 003a 5A80     		strh	r2, [r3, #2]
 284:../Generated_Code/I2C2.c ****   /* SIM_SCGC4: I2C0=1 */
 285:../Generated_Code/I2C2.c ****   SIM_SCGC4 |= SIM_SCGC4_I2C0_MASK;                                                   
 530              		.loc 1 285 0
 531 003c 314A     		ldr	r2, .L19+8
 532 003e 3149     		ldr	r1, .L19+8
 533 0040 314B     		ldr	r3, .L19+12
 534 0042 CB58     		ldr	r3, [r1, r3]
 535 0044 4021     		mov	r1, #64
 536 0046 1943     		orr	r1, r3
 537 0048 2F4B     		ldr	r3, .L19+12
 538 004a D150     		str	r1, [r2, r3]
 286:../Generated_Code/I2C2.c ****   /* I2C0_C1: IICEN=0,IICIE=0,MST=0,TX=0,TXAK=0,RSTA=0,WUEN=0,DMAEN=0 */
 287:../Generated_Code/I2C2.c ****   I2C0_C1 = 0x00U;                     /* Clear control register */
 539              		.loc 1 287 0
 540 004c 2F4B     		ldr	r3, .L19+16
 541 004e 0022     		mov	r2, #0
 542 0050 9A70     		strb	r2, [r3, #2]
 288:../Generated_Code/I2C2.c ****   /* I2C0_FLT: SHEN=0,STOPF=1,STOPIE=0,FLT=0 */
 289:../Generated_Code/I2C2.c ****   I2C0_FLT = I2C_FLT_STOPF_MASK;       /* Clear bus status interrupt flags */
 543              		.loc 1 289 0
 544 0052 2E4B     		ldr	r3, .L19+16
 545 0054 4022     		mov	r2, #64
 546 0056 9A71     		strb	r2, [r3, #6]
 290:../Generated_Code/I2C2.c ****   /* I2C0_S: TCF=0,IAAS=0,BUSY=0,ARBL=0,RAM=0,SRW=0,IICIF=1,RXAK=0 */
 291:../Generated_Code/I2C2.c ****   I2C0_S = I2C_S_IICIF_MASK;           /* Clear interrupt flag */
 547              		.loc 1 291 0
 548 0058 2C4B     		ldr	r3, .L19+16
 549 005a 0222     		mov	r2, #2
 550 005c DA70     		strb	r2, [r3, #3]
 292:../Generated_Code/I2C2.c ****   /* PORTE_PCR25: ISF=0,MUX=5 */
 293:../Generated_Code/I2C2.c ****   PORTE_PCR25 = (uint32_t)((PORTE_PCR25 & (uint32_t)~(uint32_t)(
 551              		.loc 1 293 0
 552 005e 2C4B     		ldr	r3, .L19+20
 553 0060 2B4A     		ldr	r2, .L19+20
 554 0062 526E     		ldr	r2, [r2, #100]
 555 0064 111C     		mov	r1, r2
 556 0066 2B4A     		ldr	r2, .L19+24
 557 0068 0A40     		and	r2, r1
 558 006a A021     		mov	r1, #160
 559 006c C900     		lsl	r1, r1, #3
 560 006e 0A43     		orr	r2, r1
 561 0070 5A66     		str	r2, [r3, #100]
 294:../Generated_Code/I2C2.c ****                  PORT_PCR_ISF_MASK |
 295:../Generated_Code/I2C2.c ****                  PORT_PCR_MUX(0x02)
 296:../Generated_Code/I2C2.c ****                 )) | (uint32_t)(
 297:../Generated_Code/I2C2.c ****                  PORT_PCR_MUX(0x05)
 298:../Generated_Code/I2C2.c ****                 ));                                                  
 299:../Generated_Code/I2C2.c ****   /* PORTE_PCR24: ISF=0,MUX=5 */
 300:../Generated_Code/I2C2.c ****   PORTE_PCR24 = (uint32_t)((PORTE_PCR24 & (uint32_t)~(uint32_t)(
 562              		.loc 1 300 0
 563 0072 274B     		ldr	r3, .L19+20
 564 0074 264A     		ldr	r2, .L19+20
 565 0076 126E     		ldr	r2, [r2, #96]
 566 0078 111C     		mov	r1, r2
 567 007a 264A     		ldr	r2, .L19+24
 568 007c 0A40     		and	r2, r1
 569 007e A021     		mov	r1, #160
 570 0080 C900     		lsl	r1, r1, #3
 571 0082 0A43     		orr	r2, r1
 572 0084 1A66     		str	r2, [r3, #96]
 301:../Generated_Code/I2C2.c ****                  PORT_PCR_ISF_MASK |
 302:../Generated_Code/I2C2.c ****                  PORT_PCR_MUX(0x02)
 303:../Generated_Code/I2C2.c ****                 )) | (uint32_t)(
 304:../Generated_Code/I2C2.c ****                  PORT_PCR_MUX(0x05)
 305:../Generated_Code/I2C2.c ****                 ));                                                  
 306:../Generated_Code/I2C2.c ****   /* NVIC_IPR2: PRI_8=0 */
 307:../Generated_Code/I2C2.c ****   NVIC_IPR2 &= (uint32_t)~(uint32_t)(NVIC_IP_PRI_8(0xFF));                                         
 573              		.loc 1 307 0
 574 0086 244A     		ldr	r2, .L19+28
 575 0088 2349     		ldr	r1, .L19+28
 576 008a C223     		mov	r3, #194
 577 008c 9B00     		lsl	r3, r3, #2
 578 008e CB58     		ldr	r3, [r1, r3]
 579 0090 FF21     		mov	r1, #255
 580 0092 181C     		mov	r0, r3
 581 0094 8843     		bic	r0, r1
 582 0096 011C     		mov	r1, r0
 583 0098 C223     		mov	r3, #194
 584 009a 9B00     		lsl	r3, r3, #2
 585 009c D150     		str	r1, [r2, r3]
 308:../Generated_Code/I2C2.c ****   /* NVIC_ISER: SETENA|=0x0100 */
 309:../Generated_Code/I2C2.c ****   NVIC_ISER |= NVIC_ISER_SETENA(0x0100);                                                   
 586              		.loc 1 309 0
 587 009e 1E4B     		ldr	r3, .L19+28
 588 00a0 1D4A     		ldr	r2, .L19+28
 589 00a2 1268     		ldr	r2, [r2]
 590 00a4 8021     		mov	r1, #128
 591 00a6 4900     		lsl	r1, r1, #1
 592 00a8 0A43     		orr	r2, r1
 593 00aa 1A60     		str	r2, [r3]
 310:../Generated_Code/I2C2.c ****   /* I2C0_C2: GCAEN=0,ADEXT=0,HDRS=0,SBRC=0,RMEN=0,AD=0 */
 311:../Generated_Code/I2C2.c ****   I2C0_C2 = 0x00U;                                                   
 594              		.loc 1 311 0
 595 00ac 174B     		ldr	r3, .L19+16
 596 00ae 0022     		mov	r2, #0
 597 00b0 5A71     		strb	r2, [r3, #5]
 312:../Generated_Code/I2C2.c ****   /* I2C0_FLT: SHEN=0,STOPF=0,STOPIE=0,FLT=0 */
 313:../Generated_Code/I2C2.c ****   I2C0_FLT = 0x00U;                    /* Set glitch filter register */
 598              		.loc 1 313 0
 599 00b2 164B     		ldr	r3, .L19+16
 600 00b4 0022     		mov	r2, #0
 601 00b6 9A71     		strb	r2, [r3, #6]
 314:../Generated_Code/I2C2.c ****   /* I2C0_SMB: FACK=0,ALERTEN=0,SIICAEN=0,TCKSEL=0,SLTF=1,SHTF1=0,SHTF2=0,SHTF2IE=0 */
 315:../Generated_Code/I2C2.c ****   I2C0_SMB = I2C_SMB_SLTF_MASK;                                                   
 602              		.loc 1 315 0
 603 00b8 144B     		ldr	r3, .L19+16
 604 00ba 0822     		mov	r2, #8
 605 00bc 1A72     		strb	r2, [r3, #8]
 316:../Generated_Code/I2C2.c ****   /* I2C0_F: MULT=0,ICR=0 */
 317:../Generated_Code/I2C2.c ****   I2C0_F = 0x00U;                      /* Set prescaler bits */
 606              		.loc 1 317 0
 607 00be 134B     		ldr	r3, .L19+16
 608 00c0 0022     		mov	r2, #0
 609 00c2 5A70     		strb	r2, [r3, #1]
 318:../Generated_Code/I2C2.c ****   I2C_PDD_EnableDevice(I2C0_BASE_PTR, PDD_ENABLE); /* Enable device */
 610              		.loc 1 318 0
 611 00c4 114B     		ldr	r3, .L19+16
 612 00c6 114A     		ldr	r2, .L19+16
 613 00c8 9278     		ldrb	r2, [r2, #2]
 614 00ca D2B2     		uxtb	r2, r2
 615 00cc D2B2     		uxtb	r2, r2
 616 00ce 8021     		mov	r1, #128
 617 00d0 4942     		neg	r1, r1
 618 00d2 0A43     		orr	r2, r1
 619 00d4 D2B2     		uxtb	r2, r2
 620 00d6 D2B2     		uxtb	r2, r2
 621 00d8 9A70     		strb	r2, [r3, #2]
 319:../Generated_Code/I2C2.c ****   I2C_PDD_EnableInterrupt(I2C0_BASE_PTR); /* Enable interrupt */
 622              		.loc 1 319 0
 623 00da 0C4B     		ldr	r3, .L19+16
 624 00dc 0B4A     		ldr	r2, .L19+16
 625 00de 9278     		ldrb	r2, [r2, #2]
 626 00e0 D2B2     		uxtb	r2, r2
 627 00e2 4021     		mov	r1, #64
 628 00e4 0A43     		orr	r2, r1
 629 00e6 D2B2     		uxtb	r2, r2
 630 00e8 9A70     		strb	r2, [r3, #2]
 320:../Generated_Code/I2C2.c ****   /* Registration of the device structure */
 321:../Generated_Code/I2C2.c ****   PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_I2C2_ID,DeviceDataPrv);
 631              		.loc 1 321 0
 632 00ea 0C4B     		ldr	r3, .L19+32
 633 00ec FA68     		ldr	r2, [r7, #12]
 634 00ee 5A60     		str	r2, [r3, #4]
 322:../Generated_Code/I2C2.c ****   return ((LDD_TDeviceData *)DeviceDataPrv); /* Return pointer to the data data structure */
 635              		.loc 1 322 0
 636 00f0 FB68     		ldr	r3, [r7, #12]
 323:../Generated_Code/I2C2.c **** }
 637              		.loc 1 323 0
 638 00f2 181C     		mov	r0, r3
 639 00f4 BD46     		mov	sp, r7
 640 00f6 04B0     		add	sp, sp, #16
 641              		@ sp needed for prologue
 642 00f8 80BD     		pop	{r7, pc}
 643              	.L20:
 644 00fa C046     		.align	2
 645              	.L19:
 646 00fc 00000000 		.word	DeviceDataPrv__DEFAULT_RTOS_ALLOC
 647 0100 00000000 		.word	INT_I2C0__DEFAULT_RTOS_ISRPARAM
 648 0104 00700440 		.word	1074032640
 649 0108 34100000 		.word	4148
 650 010c 00600640 		.word	1074159616
 651 0110 00D00440 		.word	1074057216
 652 0114 FFF8FFFE 		.word	-16779009
 653 0118 00E100E0 		.word	-536813312
 654 011c 00000000 		.word	PE_LDD_DeviceDataList
 655              		.cfi_endproc
 656              	.LFE1:
 658              		.section	.text.I2C2_Deinit,"ax",%progbits
 659              		.align	2
 660              		.global	I2C2_Deinit
 661              		.code	16
 662              		.thumb_func
 664              	I2C2_Deinit:
 665              	.LFB2:
 324:../Generated_Code/I2C2.c **** 
 325:../Generated_Code/I2C2.c **** /*
 326:../Generated_Code/I2C2.c **** ** ===================================================================
 327:../Generated_Code/I2C2.c **** **     Method      :  I2C2_Deinit (component I2C_LDD)
 328:../Generated_Code/I2C2.c **** **
 329:../Generated_Code/I2C2.c **** **     Description :
 330:../Generated_Code/I2C2.c **** **         Deinitializes the device. Switches off the device, frees the
 331:../Generated_Code/I2C2.c **** **         device data structure memory, interrupts vectors, etc.
 332:../Generated_Code/I2C2.c **** **     Parameters  :
 333:../Generated_Code/I2C2.c **** **         NAME            - DESCRIPTION
 334:../Generated_Code/I2C2.c **** **       * DeviceDataPtr   - Device data structure
 335:../Generated_Code/I2C2.c **** **                           pointer returned by <Init> method.
 336:../Generated_Code/I2C2.c **** **     Returns     : Nothing
 337:../Generated_Code/I2C2.c **** ** ===================================================================
 338:../Generated_Code/I2C2.c **** */
 339:../Generated_Code/I2C2.c **** void I2C2_Deinit(LDD_TDeviceData *DeviceDataPtr)
 340:../Generated_Code/I2C2.c **** {
 666              		.loc 1 340 0
 667              		.cfi_startproc
 668 0000 80B5     		push	{r7, lr}
 669              	.LCFI6:
 670              		.cfi_def_cfa_offset 8
 671              		.cfi_offset 7, -8
 672              		.cfi_offset 14, -4
 673 0002 82B0     		sub	sp, sp, #8
 674              	.LCFI7:
 675              		.cfi_def_cfa_offset 16
 676 0004 00AF     		add	r7, sp, #0
 677              	.LCFI8:
 678              		.cfi_def_cfa_register 7
 679 0006 7860     		str	r0, [r7, #4]
 341:../Generated_Code/I2C2.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 342:../Generated_Code/I2C2.c **** 
 343:../Generated_Code/I2C2.c ****   /* I2C0_C1: IICEN=0,IICIE=0,MST=0,TX=0,TXAK=0,RSTA=0,WUEN=0,DMAEN=0 */
 344:../Generated_Code/I2C2.c ****   I2C0_C1 = 0x00U;                     /* Reset I2C Control register */
 680              		.loc 1 344 0
 681 0008 094B     		ldr	r3, .L22
 682 000a 0022     		mov	r2, #0
 683 000c 9A70     		strb	r2, [r3, #2]
 345:../Generated_Code/I2C2.c ****   /* Restoring the interrupt vector */
 346:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Restore interrupt vector: IVT is static, no code is generated */
 347:../Generated_Code/I2C2.c ****   /* Unregistration of the device structure */
 348:../Generated_Code/I2C2.c ****   PE_LDD_UnregisterDeviceStructure(PE_LDD_COMPONENT_I2C2_ID);
 684              		.loc 1 348 0
 685 000e 094B     		ldr	r3, .L22+4
 686 0010 0022     		mov	r2, #0
 687 0012 5A60     		str	r2, [r3, #4]
 349:../Generated_Code/I2C2.c ****   /* Deallocation of the device structure */
 350:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Driver memory deallocation: Dynamic allocation is simulated, no dealloc
 351:../Generated_Code/I2C2.c ****   /* SIM_SCGC4: I2C0=0 */
 352:../Generated_Code/I2C2.c ****   SIM_SCGC4 &= (uint32_t)~(uint32_t)(SIM_SCGC4_I2C0_MASK);                                         
 688              		.loc 1 352 0
 689 0014 084A     		ldr	r2, .L22+8
 690 0016 0849     		ldr	r1, .L22+8
 691 0018 084B     		ldr	r3, .L22+12
 692 001a CB58     		ldr	r3, [r1, r3]
 693 001c 4021     		mov	r1, #64
 694 001e 181C     		mov	r0, r3
 695 0020 8843     		bic	r0, r1
 696 0022 011C     		mov	r1, r0
 697 0024 054B     		ldr	r3, .L22+12
 698 0026 D150     		str	r1, [r2, r3]
 353:../Generated_Code/I2C2.c **** }
 699              		.loc 1 353 0
 700 0028 BD46     		mov	sp, r7
 701 002a 02B0     		add	sp, sp, #8
 702              		@ sp needed for prologue
 703 002c 80BD     		pop	{r7, pc}
 704              	.L23:
 705 002e C046     		.align	2
 706              	.L22:
 707 0030 00600640 		.word	1074159616
 708 0034 00000000 		.word	PE_LDD_DeviceDataList
 709 0038 00700440 		.word	1074032640
 710 003c 34100000 		.word	4148
 711              		.cfi_endproc
 712              	.LFE2:
 714              		.section	.text.I2C2_MasterSendBlock,"ax",%progbits
 715              		.align	2
 716              		.global	I2C2_MasterSendBlock
 717              		.code	16
 718              		.thumb_func
 720              	I2C2_MasterSendBlock:
 721              	.LFB3:
 354:../Generated_Code/I2C2.c **** 
 355:../Generated_Code/I2C2.c **** /*
 356:../Generated_Code/I2C2.c **** ** ===================================================================
 357:../Generated_Code/I2C2.c **** **     Method      :  I2C2_MasterSendBlock (component I2C_LDD)
 358:../Generated_Code/I2C2.c **** **
 359:../Generated_Code/I2C2.c **** **     Description :
 360:../Generated_Code/I2C2.c **** **         This method writes one (7-bit addressing) or two (10-bit
 361:../Generated_Code/I2C2.c **** **         addressing) slave address bytes inclusive of R/W bit = 0 to
 362:../Generated_Code/I2C2.c **** **         the I2C bus and then writes the block of characters to the
 363:../Generated_Code/I2C2.c **** **         bus. The slave address must be specified before, by the
 364:../Generated_Code/I2C2.c **** **         "SelectSlaveDevice" method or in component initialization
 365:../Generated_Code/I2C2.c **** **         section, "Target slave address init" property. If the method
 366:../Generated_Code/I2C2.c **** **         returns ERR_OK, it doesn't mean that transmission was
 367:../Generated_Code/I2C2.c **** **         successful. The state of transmission is detectable by means
 368:../Generated_Code/I2C2.c **** **         of events (OnMasterSendComplete or OnError). Data to be sent
 369:../Generated_Code/I2C2.c **** **         are not copied to an internal buffer and remains in the
 370:../Generated_Code/I2C2.c **** **         original location. Therefore the content of the buffer
 371:../Generated_Code/I2C2.c **** **         should not be changed until the transmission is complete.
 372:../Generated_Code/I2C2.c **** **         Event "OnMasterBlockSent"can be used to detect the end of
 373:../Generated_Code/I2C2.c **** **         the transmission. This method is available only for the
 374:../Generated_Code/I2C2.c **** **         MASTER or MASTER - SLAVE mode.
 375:../Generated_Code/I2C2.c **** **     Parameters  :
 376:../Generated_Code/I2C2.c **** **         NAME            - DESCRIPTION
 377:../Generated_Code/I2C2.c **** **       * DeviceDataPtr   - Device data structure
 378:../Generated_Code/I2C2.c **** **                           pointer returned by <Init> method.
 379:../Generated_Code/I2C2.c **** **       * BufferPtr       - Pointer to the block of data
 380:../Generated_Code/I2C2.c **** **                           to send.
 381:../Generated_Code/I2C2.c **** **         Size            - Size of the data block.
 382:../Generated_Code/I2C2.c **** **         SendStop        - Parameter for generating I2C
 383:../Generated_Code/I2C2.c **** **                           Stop condition
 384:../Generated_Code/I2C2.c **** **                           LDD_I2C_SEND_STOP - Stop condition is
 385:../Generated_Code/I2C2.c **** **                           generated on end transmission.
 386:../Generated_Code/I2C2.c **** **                           LDD_I2C_NO_SEND_STOP - Stop condition isn't
 387:../Generated_Code/I2C2.c **** **                           generated on end transmission.
 388:../Generated_Code/I2C2.c **** **     Returns     :
 389:../Generated_Code/I2C2.c **** **         ---             - Error code, possible codes:
 390:../Generated_Code/I2C2.c **** **                           ERR_OK - OK
 391:../Generated_Code/I2C2.c **** **                           ERR_DISABLED -  Device is disabled
 392:../Generated_Code/I2C2.c **** **                           ERR_SPEED - This device does not work in
 393:../Generated_Code/I2C2.c **** **                           the active clock configuration
 394:../Generated_Code/I2C2.c **** **                           ERR_BUSY - The I2C device is now running
 395:../Generated_Code/I2C2.c **** ** ===================================================================
 396:../Generated_Code/I2C2.c **** */
 397:../Generated_Code/I2C2.c **** LDD_TError I2C2_MasterSendBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, LDD_I2C_TSize
 398:../Generated_Code/I2C2.c **** {
 722              		.loc 1 398 0
 723              		.cfi_startproc
 724 0000 80B5     		push	{r7, lr}
 725              	.LCFI9:
 726              		.cfi_def_cfa_offset 8
 727              		.cfi_offset 7, -8
 728              		.cfi_offset 14, -4
 729 0002 86B0     		sub	sp, sp, #24
 730              	.LCFI10:
 731              		.cfi_def_cfa_offset 32
 732 0004 00AF     		add	r7, sp, #0
 733              	.LCFI11:
 734              		.cfi_def_cfa_register 7
 735 0006 F860     		str	r0, [r7, #12]
 736 0008 B960     		str	r1, [r7, #8]
 737 000a 111C     		mov	r1, r2
 738 000c 1A1C     		mov	r2, r3
 739 000e BB1D     		add	r3, r7, #6
 740 0010 1980     		strh	r1, [r3]
 741 0012 7B1D     		add	r3, r7, #5
 742 0014 1A70     		strb	r2, [r3]
 399:../Generated_Code/I2C2.c ****   I2C2_TDeviceData *DeviceDataPrv = (I2C2_TDeviceData *)DeviceDataPtr;
 743              		.loc 1 399 0
 744 0016 FB68     		ldr	r3, [r7, #12]
 745 0018 7B61     		str	r3, [r7, #20]
 400:../Generated_Code/I2C2.c **** 
 401:../Generated_Code/I2C2.c ****   if (Size == 0x00U) {                 /* Test variable Size on zero */
 746              		.loc 1 401 0
 747 001a BB1D     		add	r3, r7, #6
 748 001c 1B88     		ldrh	r3, [r3]
 749 001e 002B     		cmp	r3, #0
 750 0020 01D1     		bne	.L25
 402:../Generated_Code/I2C2.c ****     return ERR_OK;                     /* If zero then OK */
 751              		.loc 1 402 0
 752 0022 0023     		mov	r3, #0
 753 0024 AEE0     		b	.L26
 754              	.L25:
 403:../Generated_Code/I2C2.c ****   }
 404:../Generated_Code/I2C2.c ****   if (DeviceDataPrv->SendStop == LDD_I2C_SEND_STOP) {
 755              		.loc 1 404 0
 756 0026 7B69     		ldr	r3, [r7, #20]
 757 0028 5B78     		ldrb	r3, [r3, #1]
 758 002a 012B     		cmp	r3, #1
 759 002c 14D1     		bne	.L27
 405:../Generated_Code/I2C2.c ****     if ((I2C_PDD_GetBusStatus(I2C0_BASE_PTR) == I2C_PDD_BUS_BUSY) || /* Is the bus busy? */  \
 760              		.loc 1 405 0
 761 002e 574B     		ldr	r3, .L38
 762 0030 DB78     		ldrb	r3, [r3, #3]
 763 0032 DBB2     		uxtb	r3, r3
 764 0034 1A1C     		mov	r2, r3
 765 0036 2023     		mov	r3, #32
 766 0038 1340     		and	r3, r2
 767 003a 0BD1     		bne	.L28
 406:../Generated_Code/I2C2.c ****        ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || \
 768              		.loc 1 406 0 discriminator 1
 769 003c 7B69     		ldr	r3, [r7, #20]
 770 003e 1B78     		ldrb	r3, [r3]
 771 0040 1A1C     		mov	r2, r3
 772 0042 0123     		mov	r3, #1
 773 0044 1340     		and	r3, r2
 774 0046 DBB2     		uxtb	r3, r3
 405:../Generated_Code/I2C2.c ****     if ((I2C_PDD_GetBusStatus(I2C0_BASE_PTR) == I2C_PDD_BUS_BUSY) || /* Is the bus busy? */  \
 775              		.loc 1 405 0 discriminator 1
 776 0048 002B     		cmp	r3, #0
 777 004a 03D1     		bne	.L28
 407:../Generated_Code/I2C2.c ****        (DeviceDataPrv->OutLenM != 0x00U))  {
 778              		.loc 1 407 0
 779 004c 7B69     		ldr	r3, [r7, #20]
 780 004e 9B89     		ldrh	r3, [r3, #12]
 406:../Generated_Code/I2C2.c ****        ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || \
 781              		.loc 1 406 0
 782 0050 002B     		cmp	r3, #0
 783 0052 0FD0     		beq	.L29
 784              	.L28:
 408:../Generated_Code/I2C2.c ****       return ERR_BUSY;                 /* If yes then error */
 785              		.loc 1 408 0
 786 0054 0823     		mov	r3, #8
 787 0056 95E0     		b	.L26
 788              	.L27:
 409:../Generated_Code/I2C2.c ****     }
 410:../Generated_Code/I2C2.c ****   } else {
 411:../Generated_Code/I2C2.c ****     if (((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || /* Is the bus busy? */  \
 789              		.loc 1 411 0
 790 0058 7B69     		ldr	r3, [r7, #20]
 791 005a 1B78     		ldrb	r3, [r3]
 792 005c 1A1C     		mov	r2, r3
 793 005e 0123     		mov	r3, #1
 794 0060 1340     		and	r3, r2
 795 0062 DBB2     		uxtb	r3, r3
 796 0064 002B     		cmp	r3, #0
 797 0066 03D1     		bne	.L30
 412:../Generated_Code/I2C2.c ****       (DeviceDataPrv->OutLenM != 0x00U))  {
 798              		.loc 1 412 0 discriminator 1
 799 0068 7B69     		ldr	r3, [r7, #20]
 800 006a 9B89     		ldrh	r3, [r3, #12]
 411:../Generated_Code/I2C2.c ****     if (((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || /* Is the bus busy? */  \
 801              		.loc 1 411 0 discriminator 1
 802 006c 002B     		cmp	r3, #0
 803 006e 01D0     		beq	.L29
 804              	.L30:
 413:../Generated_Code/I2C2.c ****       return ERR_BUSY;                 /* If yes then error */
 805              		.loc 1 413 0
 806 0070 0823     		mov	r3, #8
 807 0072 87E0     		b	.L26
 808              	.L29:
 414:../Generated_Code/I2C2.c ****     }
 415:../Generated_Code/I2C2.c ****   }
 416:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Critical section begin, general PE function is used */
 417:../Generated_Code/I2C2.c ****   EnterCritical();
 809              		.loc 1 417 0
 810 0074 464B     		ldr	r3, .L38+4
 811 0076 1B78     		ldrb	r3, [r3]
 812 0078 DBB2     		uxtb	r3, r3
 813 007a 0133     		add	r3, r3, #1
 814 007c DBB2     		uxtb	r3, r3
 815 007e 444A     		ldr	r2, .L38+4
 816 0080 191C     		add	r1, r3, #0
 817 0082 1170     		strb	r1, [r2]
 818 0084 012B     		cmp	r3, #1
 819 0086 04D1     		bne	.L31
 820              		.loc 1 417 0 is_stmt 0 discriminator 1
 821 0088 424B     		ldr	r3, .L38+8
 822              	@ 417 "../Generated_Code/I2C2.c" 1
 823 008a EFF31080 		MRS R0, PRIMASK
 824 008e 72B6     		CPSID i
 825 0090 1870     		STRB R0, [r3]
 826              	@ 0 "" 2
 827              		.code	16
 828              	.L31:
 418:../Generated_Code/I2C2.c ****   DeviceDataPrv->SerFlag |= MASTER_IN_PROGRES; /* Set flag "busy" */
 829              		.loc 1 418 0 is_stmt 1
 830 0092 7B69     		ldr	r3, [r7, #20]
 831 0094 1B78     		ldrb	r3, [r3]
 832 0096 0122     		mov	r2, #1
 833 0098 1343     		orr	r3, r2
 834 009a DAB2     		uxtb	r2, r3
 835 009c 7B69     		ldr	r3, [r7, #20]
 836 009e 1A70     		strb	r2, [r3]
 419:../Generated_Code/I2C2.c ****   DeviceDataPrv->OutPtrM = (uint8_t *)BufferPtr; /* Save pointer to data for transmitting */
 837              		.loc 1 419 0
 838 00a0 7B69     		ldr	r3, [r7, #20]
 839 00a2 BA68     		ldr	r2, [r7, #8]
 840 00a4 1A61     		str	r2, [r3, #16]
 420:../Generated_Code/I2C2.c ****   DeviceDataPrv->OutLenM = Size;       /* Set the counter of output bufer's content */
 841              		.loc 1 420 0
 842 00a6 7B69     		ldr	r3, [r7, #20]
 843 00a8 BA1D     		add	r2, r7, #6
 844 00aa 1288     		ldrh	r2, [r2]
 845 00ac 9A81     		strh	r2, [r3, #12]
 421:../Generated_Code/I2C2.c ****   DeviceDataPrv->SendStop = SendStop;  /* Set generating stop condition */
 846              		.loc 1 421 0
 847 00ae 7B69     		ldr	r3, [r7, #20]
 848 00b0 7A1D     		add	r2, r7, #5
 849 00b2 1278     		ldrb	r2, [r2]
 850 00b4 5A70     		strb	r2, [r3, #1]
 422:../Generated_Code/I2C2.c ****   I2C_PDD_SetTransmitMode(I2C0_BASE_PTR, I2C_PDD_TX_DIRECTION); /* Set TX mode */
 851              		.loc 1 422 0
 852 00b6 354B     		ldr	r3, .L38
 853 00b8 344A     		ldr	r2, .L38
 854 00ba 9278     		ldrb	r2, [r2, #2]
 855 00bc D2B2     		uxtb	r2, r2
 856 00be D2B2     		uxtb	r2, r2
 857 00c0 1021     		mov	r1, #16
 858 00c2 0A43     		orr	r2, r1
 859 00c4 D2B2     		uxtb	r2, r2
 860 00c6 D2B2     		uxtb	r2, r2
 861 00c8 9A70     		strb	r2, [r3, #2]
 423:../Generated_Code/I2C2.c ****   if (I2C_PDD_GetMasterMode(I2C0_BASE_PTR) == I2C_PDD_MASTER_MODE) { /* Is device in master mode? *
 862              		.loc 1 423 0
 863 00ca 304B     		ldr	r3, .L38
 864 00cc 9B78     		ldrb	r3, [r3, #2]
 865 00ce DBB2     		uxtb	r3, r3
 866 00d0 1A1C     		mov	r2, r3
 867 00d2 2023     		mov	r3, #32
 868 00d4 1340     		and	r3, r2
 869 00d6 08D0     		beq	.L32
 424:../Generated_Code/I2C2.c ****     I2C_PDD_RepeatStart(I2C0_BASE_PTR); /* If yes then repeat start cycle generated */
 870              		.loc 1 424 0
 871 00d8 2C4B     		ldr	r3, .L38
 872 00da 2C4A     		ldr	r2, .L38
 873 00dc 9278     		ldrb	r2, [r2, #2]
 874 00de D2B2     		uxtb	r2, r2
 875 00e0 0421     		mov	r1, #4
 876 00e2 0A43     		orr	r2, r1
 877 00e4 D2B2     		uxtb	r2, r2
 878 00e6 9A70     		strb	r2, [r3, #2]
 879 00e8 09E0     		b	.L33
 880              	.L32:
 425:../Generated_Code/I2C2.c ****   } else {
 426:../Generated_Code/I2C2.c ****     I2C_PDD_SetMasterMode(I2C0_BASE_PTR, I2C_PDD_MASTER_MODE); /* If no then start signal generated
 881              		.loc 1 426 0
 882 00ea 284B     		ldr	r3, .L38
 883 00ec 274A     		ldr	r2, .L38
 884 00ee 9278     		ldrb	r2, [r2, #2]
 885 00f0 D2B2     		uxtb	r2, r2
 886 00f2 D2B2     		uxtb	r2, r2
 887 00f4 2021     		mov	r1, #32
 888 00f6 0A43     		orr	r2, r1
 889 00f8 D2B2     		uxtb	r2, r2
 890 00fa D2B2     		uxtb	r2, r2
 891 00fc 9A70     		strb	r2, [r3, #2]
 892              	.L33:
 427:../Generated_Code/I2C2.c ****   }
 428:../Generated_Code/I2C2.c ****   if ((DeviceDataPrv->SerFlag & ADDR_7) != 0x00U) { /* Is 7-bit addressing set ? */
 893              		.loc 1 428 0
 894 00fe 7B69     		ldr	r3, [r7, #20]
 895 0100 1B78     		ldrb	r3, [r3]
 896 0102 1A1C     		mov	r2, r3
 897 0104 2023     		mov	r3, #32
 898 0106 1340     		and	r3, r2
 899 0108 0BD0     		beq	.L34
 429:../Generated_Code/I2C2.c ****     DeviceDataPrv->SerFlag |= (ADDR_COMPLETE | REP_ADDR_COMPLETE); /* Only one byte of address will
 900              		.loc 1 429 0
 901 010a 7B69     		ldr	r3, [r7, #20]
 902 010c 1B78     		ldrb	r3, [r3]
 903 010e 0622     		mov	r2, #6
 904 0110 1343     		orr	r3, r2
 905 0112 DAB2     		uxtb	r2, r3
 906 0114 7B69     		ldr	r3, [r7, #20]
 907 0116 1A70     		strb	r2, [r3]
 430:../Generated_Code/I2C2.c ****     I2C_PDD_WriteDataReg(I2C0_BASE_PTR, DeviceDataPrv->SlaveAddr); /* Send slave address */
 908              		.loc 1 430 0
 909 0118 1C4B     		ldr	r3, .L38
 910 011a 7A69     		ldr	r2, [r7, #20]
 911 011c 1279     		ldrb	r2, [r2, #4]
 912 011e 1A71     		strb	r2, [r3, #4]
 913 0120 21E0     		b	.L35
 914              	.L34:
 431:../Generated_Code/I2C2.c ****   } else {
 432:../Generated_Code/I2C2.c ****     if ((DeviceDataPrv->SerFlag & ADDR_10) != 0x00U) { /* Is 10-bit addressing set ? */
 915              		.loc 1 432 0
 916 0122 7B69     		ldr	r3, [r7, #20]
 917 0124 1B78     		ldrb	r3, [r3]
 918 0126 1A1C     		mov	r2, r3
 919 0128 1023     		mov	r3, #16
 920 012a 1340     		and	r3, r2
 921 012c 0BD0     		beq	.L36
 433:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(ADDR_COMPLETE | REP_ADDR_COMPLETE); /* Second byte of ad
 922              		.loc 1 433 0
 923 012e 7B69     		ldr	r3, [r7, #20]
 924 0130 1B78     		ldrb	r3, [r3]
 925 0132 0622     		mov	r2, #6
 926 0134 9343     		bic	r3, r2
 927 0136 DAB2     		uxtb	r2, r3
 928 0138 7B69     		ldr	r3, [r7, #20]
 929 013a 1A70     		strb	r2, [r3]
 434:../Generated_Code/I2C2.c ****       I2C_PDD_WriteDataReg(I2C0_BASE_PTR, DeviceDataPrv->SlaveAddrHigh); /* Send slave address - hi
 930              		.loc 1 434 0
 931 013c 134B     		ldr	r3, .L38
 932 013e 7A69     		ldr	r2, [r7, #20]
 933 0140 5279     		ldrb	r2, [r2, #5]
 934 0142 1A71     		strb	r2, [r3, #4]
 935 0144 0FE0     		b	.L35
 936              	.L36:
 435:../Generated_Code/I2C2.c ****     } else {
 436:../Generated_Code/I2C2.c ****       if ((DeviceDataPrv->SerFlag & GENERAL_CALL) != 0x00U) { /* Is general call command required ?
 937              		.loc 1 436 0
 938 0146 7B69     		ldr	r3, [r7, #20]
 939 0148 1B78     		ldrb	r3, [r3]
 940 014a 1A1C     		mov	r2, r3
 941 014c 0823     		mov	r3, #8
 942 014e 1340     		and	r3, r2
 943 0150 09D0     		beq	.L35
 437:../Generated_Code/I2C2.c ****         DeviceDataPrv->SerFlag |= ADDR_COMPLETE; /* Only one byte of address will be sent in genera
 944              		.loc 1 437 0
 945 0152 7B69     		ldr	r3, [r7, #20]
 946 0154 1B78     		ldrb	r3, [r3]
 947 0156 0222     		mov	r2, #2
 948 0158 1343     		orr	r3, r2
 949 015a DAB2     		uxtb	r2, r3
 950 015c 7B69     		ldr	r3, [r7, #20]
 951 015e 1A70     		strb	r2, [r3]
 438:../Generated_Code/I2C2.c ****         I2C_PDD_WriteDataReg(I2C0_BASE_PTR, 0x00U); /* Send general call address */
 952              		.loc 1 438 0
 953 0160 0A4B     		ldr	r3, .L38
 954 0162 0022     		mov	r2, #0
 955 0164 1A71     		strb	r2, [r3, #4]
 956              	.L35:
 439:../Generated_Code/I2C2.c ****       }
 440:../Generated_Code/I2C2.c ****     }
 441:../Generated_Code/I2C2.c ****   }
 442:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Critical section end, general PE function is used */
 443:../Generated_Code/I2C2.c ****   ExitCritical();
 957              		.loc 1 443 0
 958 0166 0A4B     		ldr	r3, .L38+4
 959 0168 1B78     		ldrb	r3, [r3]
 960 016a DBB2     		uxtb	r3, r3
 961 016c 013B     		sub	r3, r3, #1
 962 016e DBB2     		uxtb	r3, r3
 963 0170 074A     		ldr	r2, .L38+4
 964 0172 191C     		add	r1, r3, #0
 965 0174 1170     		strb	r1, [r2]
 966 0176 002B     		cmp	r3, #0
 967 0178 03D1     		bne	.L37
 968              		.loc 1 443 0 is_stmt 0 discriminator 1
 969 017a 064B     		ldr	r3, .L38+8
 970              	@ 443 "../Generated_Code/I2C2.c" 1
 971 017c 1878     		ldrb r0, [r3]
 972 017e 80F31088 		msr PRIMASK,r0;
 973              		
 974              	@ 0 "" 2
 975              		.code	16
 976              	.L37:
 444:../Generated_Code/I2C2.c ****   return ERR_OK;                       /* OK */
 977              		.loc 1 444 0 is_stmt 1
 978 0182 0023     		mov	r3, #0
 979              	.L26:
 445:../Generated_Code/I2C2.c **** }
 980              		.loc 1 445 0
 981 0184 181C     		mov	r0, r3
 982 0186 BD46     		mov	sp, r7
 983 0188 06B0     		add	sp, sp, #24
 984              		@ sp needed for prologue
 985 018a 80BD     		pop	{r7, pc}
 986              	.L39:
 987              		.align	2
 988              	.L38:
 989 018c 00600640 		.word	1074159616
 990 0190 00000000 		.word	SR_lock
 991 0194 00000000 		.word	SR_reg
 992              		.cfi_endproc
 993              	.LFE3:
 995              		.section	.text.I2C2_MasterReceiveBlock,"ax",%progbits
 996              		.align	2
 997              		.global	I2C2_MasterReceiveBlock
 998              		.code	16
 999              		.thumb_func
 1001              	I2C2_MasterReceiveBlock:
 1002              	.LFB4:
 446:../Generated_Code/I2C2.c **** 
 447:../Generated_Code/I2C2.c **** /*
 448:../Generated_Code/I2C2.c **** ** ===================================================================
 449:../Generated_Code/I2C2.c **** **     Method      :  I2C2_MasterReceiveBlock (component I2C_LDD)
 450:../Generated_Code/I2C2.c **** **
 451:../Generated_Code/I2C2.c **** **     Description :
 452:../Generated_Code/I2C2.c **** **         This method writes one (7-bit addressing) or two (10-bit
 453:../Generated_Code/I2C2.c **** **         addressing) slave address bytes inclusive of R/W bit = 1 to
 454:../Generated_Code/I2C2.c **** **         the I2C bus and then receives the block of characters from
 455:../Generated_Code/I2C2.c **** **         the bus. The slave address must be specified before, by the
 456:../Generated_Code/I2C2.c **** **         "SelectSlaveDevice" method or in component initialization
 457:../Generated_Code/I2C2.c **** **         section, "Target slave address init" property. If the method
 458:../Generated_Code/I2C2.c **** **         returns ERR_OK, it doesn't mean that reception was
 459:../Generated_Code/I2C2.c **** **         successful. The state of reception is detectable by means of
 460:../Generated_Code/I2C2.c **** **         events (OnMasterSendComplete  or OnError). Data to be
 461:../Generated_Code/I2C2.c **** **         received are not copied to an internal buffer and remains in
 462:../Generated_Code/I2C2.c **** **         the original location. Therefore the content of the buffer
 463:../Generated_Code/I2C2.c **** **         should not be changed until the transmission is complete.
 464:../Generated_Code/I2C2.c **** **         Event "OnMasterBlockReceived"can be used to detect the end
 465:../Generated_Code/I2C2.c **** **         of the reception. This method is available only for the
 466:../Generated_Code/I2C2.c **** **         MASTER or MASTER - SLAVE mode.
 467:../Generated_Code/I2C2.c **** **     Parameters  :
 468:../Generated_Code/I2C2.c **** **         NAME            - DESCRIPTION
 469:../Generated_Code/I2C2.c **** **       * DeviceDataPtr   - Device data structure
 470:../Generated_Code/I2C2.c **** **                           pointer returned by <Init> method.
 471:../Generated_Code/I2C2.c **** **       * BufferPtr       - Pointer to a buffer where
 472:../Generated_Code/I2C2.c **** **                           received characters will be stored.
 473:../Generated_Code/I2C2.c **** **         Size            - The size of the block.
 474:../Generated_Code/I2C2.c **** **         SendStop        - Parameter for generating I2C
 475:../Generated_Code/I2C2.c **** **                           Stop condition
 476:../Generated_Code/I2C2.c **** **                           LDD_I2C_SEND_STOP - Stop condition is
 477:../Generated_Code/I2C2.c **** **                           generated on end transmission.
 478:../Generated_Code/I2C2.c **** **                           LDD_I2C_NO_SEND_STOP - Stop condition isn't
 479:../Generated_Code/I2C2.c **** **                           generated on end transmission.
 480:../Generated_Code/I2C2.c **** **     Returns     :
 481:../Generated_Code/I2C2.c **** **         ---             - Error code, possible codes:
 482:../Generated_Code/I2C2.c **** **                           ERR_OK - OK
 483:../Generated_Code/I2C2.c **** **                           ERR_DISABLED -  Device is disabled
 484:../Generated_Code/I2C2.c **** **                           ERR_SPEED - This device does not work in
 485:../Generated_Code/I2C2.c **** **                           the active clock configuration
 486:../Generated_Code/I2C2.c **** **                           ERR_BUSY - The master device is busy
 487:../Generated_Code/I2C2.c **** **                           ERR_NOTAVAIL - It is not possible to
 488:../Generated_Code/I2C2.c **** **                           receive data if general call address is set.
 489:../Generated_Code/I2C2.c **** **                           ERR_PARAM_MODE -  Stop condition isn't
 490:../Generated_Code/I2C2.c **** **                           possible generated on end transmission.
 491:../Generated_Code/I2C2.c **** ** ===================================================================
 492:../Generated_Code/I2C2.c **** */
 493:../Generated_Code/I2C2.c **** LDD_TError I2C2_MasterReceiveBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, LDD_I2C_TS
 494:../Generated_Code/I2C2.c **** {
 1003              		.loc 1 494 0
 1004              		.cfi_startproc
 1005 0000 80B5     		push	{r7, lr}
 1006              	.LCFI12:
 1007              		.cfi_def_cfa_offset 8
 1008              		.cfi_offset 7, -8
 1009              		.cfi_offset 14, -4
 1010 0002 86B0     		sub	sp, sp, #24
 1011              	.LCFI13:
 1012              		.cfi_def_cfa_offset 32
 1013 0004 00AF     		add	r7, sp, #0
 1014              	.LCFI14:
 1015              		.cfi_def_cfa_register 7
 1016 0006 F860     		str	r0, [r7, #12]
 1017 0008 B960     		str	r1, [r7, #8]
 1018 000a 111C     		mov	r1, r2
 1019 000c 1A1C     		mov	r2, r3
 1020 000e BB1D     		add	r3, r7, #6
 1021 0010 1980     		strh	r1, [r3]
 1022 0012 7B1D     		add	r3, r7, #5
 1023 0014 1A70     		strb	r2, [r3]
 495:../Generated_Code/I2C2.c ****   I2C2_TDeviceData *DeviceDataPrv = (I2C2_TDeviceData *)DeviceDataPtr;
 1024              		.loc 1 495 0
 1025 0016 FB68     		ldr	r3, [r7, #12]
 1026 0018 7B61     		str	r3, [r7, #20]
 496:../Generated_Code/I2C2.c **** 
 497:../Generated_Code/I2C2.c ****   if (Size == 0x00U) {                 /* Test variable Size on zero */
 1027              		.loc 1 497 0
 1028 001a BB1D     		add	r3, r7, #6
 1029 001c 1B88     		ldrh	r3, [r3]
 1030 001e 002B     		cmp	r3, #0
 1031 0020 01D1     		bne	.L41
 498:../Generated_Code/I2C2.c ****     return ERR_OK;                     /* If zero then OK */
 1032              		.loc 1 498 0
 1033 0022 0023     		mov	r3, #0
 1034 0024 AEE0     		b	.L42
 1035              	.L41:
 499:../Generated_Code/I2C2.c ****   }
 500:../Generated_Code/I2C2.c ****   if (SendStop == LDD_I2C_NO_SEND_STOP) { /* Test variable SendStop on supported value */
 1036              		.loc 1 500 0
 1037 0026 7B1D     		add	r3, r7, #5
 1038 0028 1B78     		ldrb	r3, [r3]
 1039 002a 002B     		cmp	r3, #0
 1040 002c 01D1     		bne	.L43
 501:../Generated_Code/I2C2.c ****     return ERR_PARAM_MODE;             /* If not supported value then error */
 1041              		.loc 1 501 0
 1042 002e 8123     		mov	r3, #129
 1043 0030 A8E0     		b	.L42
 1044              	.L43:
 502:../Generated_Code/I2C2.c ****   }
 503:../Generated_Code/I2C2.c ****   if ((DeviceDataPrv->SerFlag & GENERAL_CALL) != 0x00U) { /* Is the general call flag set (SelectSl
 1045              		.loc 1 503 0
 1046 0032 7B69     		ldr	r3, [r7, #20]
 1047 0034 1B78     		ldrb	r3, [r3]
 1048 0036 1A1C     		mov	r2, r3
 1049 0038 0823     		mov	r3, #8
 1050 003a 1340     		and	r3, r2
 1051 003c 01D0     		beq	.L44
 504:../Generated_Code/I2C2.c ****     return ERR_NOTAVAIL;               /* It is not possible to receive data - Call SelectSlaveDevi
 1052              		.loc 1 504 0
 1053 003e 0923     		mov	r3, #9
 1054 0040 A0E0     		b	.L42
 1055              	.L44:
 505:../Generated_Code/I2C2.c ****   }
 506:../Generated_Code/I2C2.c ****   if (DeviceDataPrv->SendStop == LDD_I2C_SEND_STOP) {
 1056              		.loc 1 506 0
 1057 0042 7B69     		ldr	r3, [r7, #20]
 1058 0044 5B78     		ldrb	r3, [r3, #1]
 1059 0046 012B     		cmp	r3, #1
 1060 0048 14D1     		bne	.L45
 507:../Generated_Code/I2C2.c ****     if ((I2C_PDD_GetBusStatus(I2C0_BASE_PTR) == I2C_PDD_BUS_BUSY) || /* Is the bus busy? */  \
 1061              		.loc 1 507 0
 1062 004a 504B     		ldr	r3, .L55
 1063 004c DB78     		ldrb	r3, [r3, #3]
 1064 004e DBB2     		uxtb	r3, r3
 1065 0050 1A1C     		mov	r2, r3
 1066 0052 2023     		mov	r3, #32
 1067 0054 1340     		and	r3, r2
 1068 0056 0BD1     		bne	.L46
 508:../Generated_Code/I2C2.c ****       ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || \
 1069              		.loc 1 508 0 discriminator 1
 1070 0058 7B69     		ldr	r3, [r7, #20]
 1071 005a 1B78     		ldrb	r3, [r3]
 1072 005c 1A1C     		mov	r2, r3
 1073 005e 0123     		mov	r3, #1
 1074 0060 1340     		and	r3, r2
 1075 0062 DBB2     		uxtb	r3, r3
 507:../Generated_Code/I2C2.c ****     if ((I2C_PDD_GetBusStatus(I2C0_BASE_PTR) == I2C_PDD_BUS_BUSY) || /* Is the bus busy? */  \
 1076              		.loc 1 507 0 discriminator 1
 1077 0064 002B     		cmp	r3, #0
 1078 0066 03D1     		bne	.L46
 509:../Generated_Code/I2C2.c ****       (DeviceDataPrv->InpLenM != 0x00U)) {
 1079              		.loc 1 509 0
 1080 0068 7B69     		ldr	r3, [r7, #20]
 1081 006a DB88     		ldrh	r3, [r3, #6]
 508:../Generated_Code/I2C2.c ****       ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || \
 1082              		.loc 1 508 0
 1083 006c 002B     		cmp	r3, #0
 1084 006e 0FD0     		beq	.L47
 1085              	.L46:
 510:../Generated_Code/I2C2.c ****       return ERR_BUSY;                 /* If yes then error */
 1086              		.loc 1 510 0
 1087 0070 0823     		mov	r3, #8
 1088 0072 87E0     		b	.L42
 1089              	.L45:
 511:../Generated_Code/I2C2.c ****     }
 512:../Generated_Code/I2C2.c ****   } else {
 513:../Generated_Code/I2C2.c ****     if(((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || /* Is the bus busy? */  \
 1090              		.loc 1 513 0
 1091 0074 7B69     		ldr	r3, [r7, #20]
 1092 0076 1B78     		ldrb	r3, [r3]
 1093 0078 1A1C     		mov	r2, r3
 1094 007a 0123     		mov	r3, #1
 1095 007c 1340     		and	r3, r2
 1096 007e DBB2     		uxtb	r3, r3
 1097 0080 002B     		cmp	r3, #0
 1098 0082 03D1     		bne	.L48
 514:../Generated_Code/I2C2.c ****       (DeviceDataPrv->InpLenM != 0x00U)) {
 1099              		.loc 1 514 0 discriminator 1
 1100 0084 7B69     		ldr	r3, [r7, #20]
 1101 0086 DB88     		ldrh	r3, [r3, #6]
 513:../Generated_Code/I2C2.c ****     if(((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || /* Is the bus busy? */  \
 1102              		.loc 1 513 0 discriminator 1
 1103 0088 002B     		cmp	r3, #0
 1104 008a 01D0     		beq	.L47
 1105              	.L48:
 515:../Generated_Code/I2C2.c ****       return ERR_BUSY;               /* If yes then error */
 1106              		.loc 1 515 0
 1107 008c 0823     		mov	r3, #8
 1108 008e 79E0     		b	.L42
 1109              	.L47:
 516:../Generated_Code/I2C2.c ****     }
 517:../Generated_Code/I2C2.c ****   }
 518:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Critical section begin, general PE function is used */
 519:../Generated_Code/I2C2.c ****   EnterCritical();
 1110              		.loc 1 519 0
 1111 0090 3F4B     		ldr	r3, .L55+4
 1112 0092 1B78     		ldrb	r3, [r3]
 1113 0094 DBB2     		uxtb	r3, r3
 1114 0096 0133     		add	r3, r3, #1
 1115 0098 DBB2     		uxtb	r3, r3
 1116 009a 3D4A     		ldr	r2, .L55+4
 1117 009c 191C     		add	r1, r3, #0
 1118 009e 1170     		strb	r1, [r2]
 1119 00a0 012B     		cmp	r3, #1
 1120 00a2 04D1     		bne	.L49
 1121              		.loc 1 519 0 is_stmt 0 discriminator 1
 1122 00a4 3B4B     		ldr	r3, .L55+8
 1123              	@ 519 "../Generated_Code/I2C2.c" 1
 1124 00a6 EFF31080 		MRS R0, PRIMASK
 1125 00aa 72B6     		CPSID i
 1126 00ac 1870     		STRB R0, [r3]
 1127              	@ 0 "" 2
 1128              		.code	16
 1129              	.L49:
 520:../Generated_Code/I2C2.c ****   DeviceDataPrv->SerFlag |= MASTER_IN_PROGRES; /* Set flag "busy" */
 1130              		.loc 1 520 0 is_stmt 1
 1131 00ae 7B69     		ldr	r3, [r7, #20]
 1132 00b0 1B78     		ldrb	r3, [r3]
 1133 00b2 0122     		mov	r2, #1
 1134 00b4 1343     		orr	r3, r2
 1135 00b6 DAB2     		uxtb	r2, r3
 1136 00b8 7B69     		ldr	r3, [r7, #20]
 1137 00ba 1A70     		strb	r2, [r3]
 521:../Generated_Code/I2C2.c ****   DeviceDataPrv->InpPtrM = (uint8_t *)BufferPtr; /* Save pointer to data for reception */
 1138              		.loc 1 521 0
 1139 00bc 7B69     		ldr	r3, [r7, #20]
 1140 00be BA68     		ldr	r2, [r7, #8]
 1141 00c0 9A60     		str	r2, [r3, #8]
 522:../Generated_Code/I2C2.c ****   DeviceDataPrv->InpLenM = Size;       /* Set the counter of input bufer's content */
 1142              		.loc 1 522 0
 1143 00c2 7B69     		ldr	r3, [r7, #20]
 1144 00c4 BA1D     		add	r2, r7, #6
 1145 00c6 1288     		ldrh	r2, [r2]
 1146 00c8 DA80     		strh	r2, [r3, #6]
 523:../Generated_Code/I2C2.c ****   DeviceDataPrv->SendStop = SendStop;  /* Set generating stop condition */
 1147              		.loc 1 523 0
 1148 00ca 7B69     		ldr	r3, [r7, #20]
 1149 00cc 7A1D     		add	r2, r7, #5
 1150 00ce 1278     		ldrb	r2, [r2]
 1151 00d0 5A70     		strb	r2, [r3, #1]
 524:../Generated_Code/I2C2.c ****   I2C_PDD_SetTransmitMode(I2C0_BASE_PTR, I2C_PDD_TX_DIRECTION); /* Set TX mode */
 1152              		.loc 1 524 0
 1153 00d2 2E4B     		ldr	r3, .L55
 1154 00d4 2D4A     		ldr	r2, .L55
 1155 00d6 9278     		ldrb	r2, [r2, #2]
 1156 00d8 D2B2     		uxtb	r2, r2
 1157 00da D2B2     		uxtb	r2, r2
 1158 00dc 1021     		mov	r1, #16
 1159 00de 0A43     		orr	r2, r1
 1160 00e0 D2B2     		uxtb	r2, r2
 1161 00e2 D2B2     		uxtb	r2, r2
 1162 00e4 9A70     		strb	r2, [r3, #2]
 525:../Generated_Code/I2C2.c ****   if (I2C_PDD_GetMasterMode(I2C0_BASE_PTR) == I2C_PDD_MASTER_MODE) { /* Is device in master mode? *
 1163              		.loc 1 525 0
 1164 00e6 294B     		ldr	r3, .L55
 1165 00e8 9B78     		ldrb	r3, [r3, #2]
 1166 00ea DBB2     		uxtb	r3, r3
 1167 00ec 1A1C     		mov	r2, r3
 1168 00ee 2023     		mov	r3, #32
 1169 00f0 1340     		and	r3, r2
 1170 00f2 08D0     		beq	.L50
 526:../Generated_Code/I2C2.c ****     I2C_PDD_RepeatStart(I2C0_BASE_PTR); /* If yes then repeat start cycle generated */
 1171              		.loc 1 526 0
 1172 00f4 254B     		ldr	r3, .L55
 1173 00f6 254A     		ldr	r2, .L55
 1174 00f8 9278     		ldrb	r2, [r2, #2]
 1175 00fa D2B2     		uxtb	r2, r2
 1176 00fc 0421     		mov	r1, #4
 1177 00fe 0A43     		orr	r2, r1
 1178 0100 D2B2     		uxtb	r2, r2
 1179 0102 9A70     		strb	r2, [r3, #2]
 1180 0104 09E0     		b	.L51
 1181              	.L50:
 527:../Generated_Code/I2C2.c ****   } else {
 528:../Generated_Code/I2C2.c ****     I2C_PDD_SetMasterMode(I2C0_BASE_PTR, I2C_PDD_MASTER_MODE); /* If no then start signal generated
 1182              		.loc 1 528 0
 1183 0106 214B     		ldr	r3, .L55
 1184 0108 204A     		ldr	r2, .L55
 1185 010a 9278     		ldrb	r2, [r2, #2]
 1186 010c D2B2     		uxtb	r2, r2
 1187 010e D2B2     		uxtb	r2, r2
 1188 0110 2021     		mov	r1, #32
 1189 0112 0A43     		orr	r2, r1
 1190 0114 D2B2     		uxtb	r2, r2
 1191 0116 D2B2     		uxtb	r2, r2
 1192 0118 9A70     		strb	r2, [r3, #2]
 1193              	.L51:
 529:../Generated_Code/I2C2.c ****   }
 530:../Generated_Code/I2C2.c ****   if ((DeviceDataPrv->SerFlag & ADDR_7) != 0x00U) { /* Is 7-bit addressing set ? */
 1194              		.loc 1 530 0
 1195 011a 7B69     		ldr	r3, [r7, #20]
 1196 011c 1B78     		ldrb	r3, [r3]
 1197 011e 1A1C     		mov	r2, r3
 1198 0120 2023     		mov	r3, #32
 1199 0122 1340     		and	r3, r2
 1200 0124 0ED0     		beq	.L52
 531:../Generated_Code/I2C2.c ****     DeviceDataPrv->SerFlag |= (ADDR_COMPLETE|REP_ADDR_COMPLETE); /* Only one byte of address will b
 1201              		.loc 1 531 0
 1202 0126 7B69     		ldr	r3, [r7, #20]
 1203 0128 1B78     		ldrb	r3, [r3]
 1204 012a 0622     		mov	r2, #6
 1205 012c 1343     		orr	r3, r2
 1206 012e DAB2     		uxtb	r2, r3
 1207 0130 7B69     		ldr	r3, [r7, #20]
 1208 0132 1A70     		strb	r2, [r3]
 532:../Generated_Code/I2C2.c ****     I2C_PDD_WriteDataReg(I2C0_BASE_PTR, (uint8_t)(DeviceDataPrv->SlaveAddr | 0x01U)); /* Send slave
 1209              		.loc 1 532 0
 1210 0134 154B     		ldr	r3, .L55
 1211 0136 7A69     		ldr	r2, [r7, #20]
 1212 0138 1279     		ldrb	r2, [r2, #4]
 1213 013a 0121     		mov	r1, #1
 1214 013c 0A43     		orr	r2, r1
 1215 013e D2B2     		uxtb	r2, r2
 1216 0140 1A71     		strb	r2, [r3, #4]
 1217 0142 10E0     		b	.L53
 1218              	.L52:
 533:../Generated_Code/I2C2.c ****   } else {
 534:../Generated_Code/I2C2.c ****     if ((DeviceDataPrv->SerFlag & ADDR_10) != 0x00U) { /* Is 10-bit addressing set ? */
 1219              		.loc 1 534 0
 1220 0144 7B69     		ldr	r3, [r7, #20]
 1221 0146 1B78     		ldrb	r3, [r3]
 1222 0148 1A1C     		mov	r2, r3
 1223 014a 1023     		mov	r3, #16
 1224 014c 1340     		and	r3, r2
 1225 014e 0AD0     		beq	.L53
 535:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(ADDR_COMPLETE | REP_ADDR_COMPLETE); /* Second byte of ad
 1226              		.loc 1 535 0
 1227 0150 7B69     		ldr	r3, [r7, #20]
 1228 0152 1B78     		ldrb	r3, [r3]
 1229 0154 0622     		mov	r2, #6
 1230 0156 9343     		bic	r3, r2
 1231 0158 DAB2     		uxtb	r2, r3
 1232 015a 7B69     		ldr	r3, [r7, #20]
 1233 015c 1A70     		strb	r2, [r3]
 536:../Generated_Code/I2C2.c ****       I2C_PDD_WriteDataReg(I2C0_BASE_PTR, DeviceDataPrv->SlaveAddrHigh); /* Send slave address - hi
 1234              		.loc 1 536 0
 1235 015e 0B4B     		ldr	r3, .L55
 1236 0160 7A69     		ldr	r2, [r7, #20]
 1237 0162 5279     		ldrb	r2, [r2, #5]
 1238 0164 1A71     		strb	r2, [r3, #4]
 1239              	.L53:
 537:../Generated_Code/I2C2.c ****     }
 538:../Generated_Code/I2C2.c ****   }
 539:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Critical section end, general PE function is used */
 540:../Generated_Code/I2C2.c ****   ExitCritical();
 1240              		.loc 1 540 0
 1241 0166 0A4B     		ldr	r3, .L55+4
 1242 0168 1B78     		ldrb	r3, [r3]
 1243 016a DBB2     		uxtb	r3, r3
 1244 016c 013B     		sub	r3, r3, #1
 1245 016e DBB2     		uxtb	r3, r3
 1246 0170 074A     		ldr	r2, .L55+4
 1247 0172 191C     		add	r1, r3, #0
 1248 0174 1170     		strb	r1, [r2]
 1249 0176 002B     		cmp	r3, #0
 1250 0178 03D1     		bne	.L54
 1251              		.loc 1 540 0 is_stmt 0 discriminator 1
 1252 017a 064B     		ldr	r3, .L55+8
 1253              	@ 540 "../Generated_Code/I2C2.c" 1
 1254 017c 1878     		ldrb r0, [r3]
 1255 017e 80F31088 		msr PRIMASK,r0;
 1256              		
 1257              	@ 0 "" 2
 1258              		.code	16
 1259              	.L54:
 541:../Generated_Code/I2C2.c ****   return ERR_OK;                       /* OK */
 1260              		.loc 1 541 0 is_stmt 1
 1261 0182 0023     		mov	r3, #0
 1262              	.L42:
 542:../Generated_Code/I2C2.c **** }
 1263              		.loc 1 542 0
 1264 0184 181C     		mov	r0, r3
 1265 0186 BD46     		mov	sp, r7
 1266 0188 06B0     		add	sp, sp, #24
 1267              		@ sp needed for prologue
 1268 018a 80BD     		pop	{r7, pc}
 1269              	.L56:
 1270              		.align	2
 1271              	.L55:
 1272 018c 00600640 		.word	1074159616
 1273 0190 00000000 		.word	SR_lock
 1274 0194 00000000 		.word	SR_reg
 1275              		.cfi_endproc
 1276              	.LFE4:
 1278              		.section	.text.I2C2_SelectSlaveDevice,"ax",%progbits
 1279              		.align	2
 1280              		.global	I2C2_SelectSlaveDevice
 1281              		.code	16
 1282              		.thumb_func
 1284              	I2C2_SelectSlaveDevice:
 1285              	.LFB5:
 543:../Generated_Code/I2C2.c **** 
 544:../Generated_Code/I2C2.c **** /*
 545:../Generated_Code/I2C2.c **** ** ===================================================================
 546:../Generated_Code/I2C2.c **** **     Method      :  I2C2_SelectSlaveDevice (component I2C_LDD)
 547:../Generated_Code/I2C2.c **** **
 548:../Generated_Code/I2C2.c **** **     Description :
 549:../Generated_Code/I2C2.c **** **         This method selects a new slave for communication by its
 550:../Generated_Code/I2C2.c **** **         7-bit slave, 10-bit address or general call value. Any send
 551:../Generated_Code/I2C2.c **** **         or receive method directs to or from selected device, until
 552:../Generated_Code/I2C2.c **** **         a new slave device is selected by this method. This method
 553:../Generated_Code/I2C2.c **** **         is available for the MASTER mode.
 554:../Generated_Code/I2C2.c **** **     Parameters  :
 555:../Generated_Code/I2C2.c **** **         NAME            - DESCRIPTION
 556:../Generated_Code/I2C2.c **** **       * DeviceDataPtr   - Device data structure
 557:../Generated_Code/I2C2.c **** **                           pointer returned by <Init> method.
 558:../Generated_Code/I2C2.c **** **         AddrType        - Specify type of slave address
 559:../Generated_Code/I2C2.c **** **                           (7bit, 10bit or general call address), e.g.
 560:../Generated_Code/I2C2.c **** **                           LDD_I2C_ADDRTYPE_7BITS.
 561:../Generated_Code/I2C2.c **** **         Addr            - 7bit or 10bit slave address value.
 562:../Generated_Code/I2C2.c **** **     Returns     :
 563:../Generated_Code/I2C2.c **** **         ---             - Error code, possible codes:
 564:../Generated_Code/I2C2.c **** **                           ERR_OK - OK
 565:../Generated_Code/I2C2.c **** **                           ERR_BUSY - The device is busy, wait until
 566:../Generated_Code/I2C2.c **** **                           the current operation is finished.
 567:../Generated_Code/I2C2.c **** **                           ERR_DISABLED -  The device is disabled.
 568:../Generated_Code/I2C2.c **** **                           ERR_SPEED - This device does not work in
 569:../Generated_Code/I2C2.c **** **                           the active clock configuration
 570:../Generated_Code/I2C2.c **** **                           ERR_PARAM_ADDRESS_TYPE -  Invalid address
 571:../Generated_Code/I2C2.c **** **                           type.
 572:../Generated_Code/I2C2.c **** **                           ERR_PARAM_ADDRESS -  Invalid address value.
 573:../Generated_Code/I2C2.c **** ** ===================================================================
 574:../Generated_Code/I2C2.c **** */
 575:../Generated_Code/I2C2.c **** LDD_TError I2C2_SelectSlaveDevice(LDD_TDeviceData *DeviceDataPtr, LDD_I2C_TAddrType AddrType, LDD_I
 576:../Generated_Code/I2C2.c **** {
 1286              		.loc 1 576 0
 1287              		.cfi_startproc
 1288 0000 80B5     		push	{r7, lr}
 1289              	.LCFI15:
 1290              		.cfi_def_cfa_offset 8
 1291              		.cfi_offset 7, -8
 1292              		.cfi_offset 14, -4
 1293 0002 84B0     		sub	sp, sp, #16
 1294              	.LCFI16:
 1295              		.cfi_def_cfa_offset 24
 1296 0004 00AF     		add	r7, sp, #0
 1297              	.LCFI17:
 1298              		.cfi_def_cfa_register 7
 1299 0006 7860     		str	r0, [r7, #4]
 1300 0008 FB1C     		add	r3, r7, #3
 1301 000a 1970     		strb	r1, [r3]
 1302 000c 3B1C     		mov	r3, r7
 1303 000e 1A80     		strh	r2, [r3]
 577:../Generated_Code/I2C2.c ****   I2C2_TDeviceData *DeviceDataPrv = (I2C2_TDeviceData *)DeviceDataPtr;
 1304              		.loc 1 577 0
 1305 0010 7B68     		ldr	r3, [r7, #4]
 1306 0012 FB60     		str	r3, [r7, #12]
 578:../Generated_Code/I2C2.c **** 
 579:../Generated_Code/I2C2.c ****   if ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) { /* Is the device in the active state
 1307              		.loc 1 579 0
 1308 0014 FB68     		ldr	r3, [r7, #12]
 1309 0016 1B78     		ldrb	r3, [r3]
 1310 0018 1A1C     		mov	r2, r3
 1311 001a 0123     		mov	r3, #1
 1312 001c 1340     		and	r3, r2
 1313 001e DBB2     		uxtb	r3, r3
 1314 0020 002B     		cmp	r3, #0
 1315 0022 01D0     		beq	.L58
 580:../Generated_Code/I2C2.c ****     return ERR_BUSY;                   /* If yes then error */
 1316              		.loc 1 580 0
 1317 0024 0823     		mov	r3, #8
 1318 0026 66E0     		b	.L59
 1319              	.L58:
 581:../Generated_Code/I2C2.c ****   }
 582:../Generated_Code/I2C2.c ****   switch (AddrType) {
 1320              		.loc 1 582 0
 1321 0028 FB1C     		add	r3, r7, #3
 1322 002a 1B78     		ldrb	r3, [r3]
 1323 002c 012B     		cmp	r3, #1
 1324 002e 1FD0     		beq	.L62
 1325 0030 022B     		cmp	r3, #2
 1326 0032 4ED0     		beq	.L63
 1327 0034 002B     		cmp	r3, #0
 1328 0036 5BD1     		bne	.L67
 1329              	.L61:
 583:../Generated_Code/I2C2.c ****     case LDD_I2C_ADDRTYPE_7BITS:
 584:../Generated_Code/I2C2.c ****       if (Addr > 0x7FU) {              /* Test address value */
 1330              		.loc 1 584 0
 1331 0038 3B1C     		mov	r3, r7
 1332 003a 1B88     		ldrh	r3, [r3]
 1333 003c 7F2B     		cmp	r3, #127
 1334 003e 01D9     		bls	.L64
 585:../Generated_Code/I2C2.c ****         return ERR_PARAM_ADDRESS;      /* If value of address is invalid, return error */
 1335              		.loc 1 585 0
 1336 0040 8923     		mov	r3, #137
 1337 0042 58E0     		b	.L59
 1338              	.L64:
 586:../Generated_Code/I2C2.c ****       }
 587:../Generated_Code/I2C2.c ****       DeviceDataPrv->SlaveAddr = (uint8_t)((uint8_t)Addr << 0x01U); /* Set slave address */
 1339              		.loc 1 587 0
 1340 0044 3B1C     		mov	r3, r7
 1341 0046 1B88     		ldrh	r3, [r3]
 1342 0048 DBB2     		uxtb	r3, r3
 1343 004a 5B00     		lsl	r3, r3, #1
 1344 004c DAB2     		uxtb	r2, r3
 1345 004e FB68     		ldr	r3, [r7, #12]
 1346 0050 1A71     		strb	r2, [r3, #4]
 588:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(GENERAL_CALL | ADDR_10); /* Clear the general call flag 
 1347              		.loc 1 588 0
 1348 0052 FB68     		ldr	r3, [r7, #12]
 1349 0054 1B78     		ldrb	r3, [r3]
 1350 0056 1822     		mov	r2, #24
 1351 0058 9343     		bic	r3, r2
 1352 005a DAB2     		uxtb	r2, r3
 1353 005c FB68     		ldr	r3, [r7, #12]
 1354 005e 1A70     		strb	r2, [r3]
 589:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag |= ADDR_7; /* Set 7-bit address mode flag */
 1355              		.loc 1 589 0
 1356 0060 FB68     		ldr	r3, [r7, #12]
 1357 0062 1B78     		ldrb	r3, [r3]
 1358 0064 2022     		mov	r2, #32
 1359 0066 1343     		orr	r3, r2
 1360 0068 DAB2     		uxtb	r2, r3
 1361 006a FB68     		ldr	r3, [r7, #12]
 1362 006c 1A70     		strb	r2, [r3]
 590:../Generated_Code/I2C2.c ****     break;
 1363              		.loc 1 590 0
 1364 006e 41E0     		b	.L65
 1365              	.L62:
 591:../Generated_Code/I2C2.c ****     case LDD_I2C_ADDRTYPE_10BITS:
 592:../Generated_Code/I2C2.c ****       if (Addr > 0x03FFU) {            /* Test address value */
 1366              		.loc 1 592 0
 1367 0070 3B1C     		mov	r3, r7
 1368 0072 1A88     		ldrh	r2, [r3]
 1369 0074 224B     		ldr	r3, .L68
 1370 0076 9A42     		cmp	r2, r3
 1371 0078 01D9     		bls	.L66
 593:../Generated_Code/I2C2.c ****         return ERR_PARAM_ADDRESS;      /* If value of address is invalid, return error */
 1372              		.loc 1 593 0
 1373 007a 8923     		mov	r3, #137
 1374 007c 3BE0     		b	.L59
 1375              	.L66:
 594:../Generated_Code/I2C2.c ****       }
 595:../Generated_Code/I2C2.c ****       DeviceDataPrv->SlaveAddr = (uint8_t)Addr; /* Set slave address - low byte */
 1376              		.loc 1 595 0
 1377 007e 3B1C     		mov	r3, r7
 1378 0080 1B88     		ldrh	r3, [r3]
 1379 0082 DAB2     		uxtb	r2, r3
 1380 0084 FB68     		ldr	r3, [r7, #12]
 1381 0086 1A71     		strb	r2, [r3, #4]
 596:../Generated_Code/I2C2.c ****       DeviceDataPrv->SlaveAddrHigh = (uint8_t)((uint16_t)Addr >> 0x07U); /* Set slave address - hig
 1382              		.loc 1 596 0
 1383 0088 3B1C     		mov	r3, r7
 1384 008a 1B88     		ldrh	r3, [r3]
 1385 008c DB09     		lsr	r3, r3, #7
 1386 008e 9BB2     		uxth	r3, r3
 1387 0090 DAB2     		uxtb	r2, r3
 1388 0092 FB68     		ldr	r3, [r7, #12]
 1389 0094 5A71     		strb	r2, [r3, #5]
 597:../Generated_Code/I2C2.c ****       DeviceDataPrv->SlaveAddrHigh &= 0x06U; /* Format address to 11110xx0 */
 1390              		.loc 1 597 0
 1391 0096 FB68     		ldr	r3, [r7, #12]
 1392 0098 5A79     		ldrb	r2, [r3, #5]
 1393 009a 0623     		mov	r3, #6
 1394 009c 1340     		and	r3, r2
 1395 009e DAB2     		uxtb	r2, r3
 1396 00a0 FB68     		ldr	r3, [r7, #12]
 1397 00a2 5A71     		strb	r2, [r3, #5]
 598:../Generated_Code/I2C2.c ****       DeviceDataPrv->SlaveAddrHigh |= 0xF0U;
 1398              		.loc 1 598 0
 1399 00a4 FB68     		ldr	r3, [r7, #12]
 1400 00a6 5B79     		ldrb	r3, [r3, #5]
 1401 00a8 1022     		mov	r2, #16
 1402 00aa 5242     		neg	r2, r2
 1403 00ac 1343     		orr	r3, r2
 1404 00ae DAB2     		uxtb	r2, r3
 1405 00b0 FB68     		ldr	r3, [r7, #12]
 1406 00b2 5A71     		strb	r2, [r3, #5]
 599:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(GENERAL_CALL | ADDR_7); /* Clear the general call flag a
 1407              		.loc 1 599 0
 1408 00b4 FB68     		ldr	r3, [r7, #12]
 1409 00b6 1B78     		ldrb	r3, [r3]
 1410 00b8 2822     		mov	r2, #40
 1411 00ba 9343     		bic	r3, r2
 1412 00bc DAB2     		uxtb	r2, r3
 1413 00be FB68     		ldr	r3, [r7, #12]
 1414 00c0 1A70     		strb	r2, [r3]
 600:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag |= ADDR_10; /* Set 10-bit address mode flag */
 1415              		.loc 1 600 0
 1416 00c2 FB68     		ldr	r3, [r7, #12]
 1417 00c4 1B78     		ldrb	r3, [r3]
 1418 00c6 1022     		mov	r2, #16
 1419 00c8 1343     		orr	r3, r2
 1420 00ca DAB2     		uxtb	r2, r3
 1421 00cc FB68     		ldr	r3, [r7, #12]
 1422 00ce 1A70     		strb	r2, [r3]
 601:../Generated_Code/I2C2.c ****     break;
 1423              		.loc 1 601 0
 1424 00d0 10E0     		b	.L65
 1425              	.L63:
 602:../Generated_Code/I2C2.c ****     case LDD_I2C_ADDRTYPE_GENERAL_CALL:
 603:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(ADDR_7 | ADDR_10); /* Clear the 7-bit address flag and 1
 1426              		.loc 1 603 0
 1427 00d2 FB68     		ldr	r3, [r7, #12]
 1428 00d4 1B78     		ldrb	r3, [r3]
 1429 00d6 3022     		mov	r2, #48
 1430 00d8 9343     		bic	r3, r2
 1431 00da DAB2     		uxtb	r2, r3
 1432 00dc FB68     		ldr	r3, [r7, #12]
 1433 00de 1A70     		strb	r2, [r3]
 604:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag |= GENERAL_CALL; /* Set general call mode flag */
 1434              		.loc 1 604 0
 1435 00e0 FB68     		ldr	r3, [r7, #12]
 1436 00e2 1B78     		ldrb	r3, [r3]
 1437 00e4 0822     		mov	r2, #8
 1438 00e6 1343     		orr	r3, r2
 1439 00e8 DAB2     		uxtb	r2, r3
 1440 00ea FB68     		ldr	r3, [r7, #12]
 1441 00ec 1A70     		strb	r2, [r3]
 605:../Generated_Code/I2C2.c ****     break;
 1442              		.loc 1 605 0
 1443 00ee 01E0     		b	.L65
 1444              	.L67:
 606:../Generated_Code/I2C2.c ****     default:
 607:../Generated_Code/I2C2.c ****       return ERR_PARAM_ADDRESS_TYPE;   /* If value of address type is invalid, return error */
 1445              		.loc 1 607 0
 1446 00f0 8D23     		mov	r3, #141
 1447 00f2 00E0     		b	.L59
 1448              	.L65:
 608:../Generated_Code/I2C2.c ****   }
 609:../Generated_Code/I2C2.c ****   return ERR_OK;                       /* OK */
 1449              		.loc 1 609 0
 1450 00f4 0023     		mov	r3, #0
 1451              	.L59:
 610:../Generated_Code/I2C2.c **** }
 1452              		.loc 1 610 0
 1453 00f6 181C     		mov	r0, r3
 1454 00f8 BD46     		mov	sp, r7
 1455 00fa 04B0     		add	sp, sp, #16
 1456              		@ sp needed for prologue
 1457 00fc 80BD     		pop	{r7, pc}
 1458              	.L69:
 1459 00fe C046     		.align	2
 1460              	.L68:
 1461 0100 FF030000 		.word	1023
 1462              		.cfi_endproc
 1463              	.LFE5:
 1465              		.section	.text.I2C2_GetError,"ax",%progbits
 1466              		.align	2
 1467              		.global	I2C2_GetError
 1468              		.code	16
 1469              		.thumb_func
 1471              	I2C2_GetError:
 1472              	.LFB6:
 611:../Generated_Code/I2C2.c **** 
 612:../Generated_Code/I2C2.c **** /*
 613:../Generated_Code/I2C2.c **** ** ===================================================================
 614:../Generated_Code/I2C2.c **** **     Method      :  I2C2_GetError (component I2C_LDD)
 615:../Generated_Code/I2C2.c **** **
 616:../Generated_Code/I2C2.c **** **     Description :
 617:../Generated_Code/I2C2.c **** **         Returns value of error mask, e.g. LDD_I2C_ARBIT_LOST.
 618:../Generated_Code/I2C2.c **** **     Parameters  :
 619:../Generated_Code/I2C2.c **** **         NAME            - DESCRIPTION
 620:../Generated_Code/I2C2.c **** **       * DeviceDataPtr   - Device data structure
 621:../Generated_Code/I2C2.c **** **                           pointer returned by <Init> method.
 622:../Generated_Code/I2C2.c **** **       * ErrorMaskPtr    - Pointer to a variable
 623:../Generated_Code/I2C2.c **** **                           where errors value mask will be stored.
 624:../Generated_Code/I2C2.c **** **     Returns     :
 625:../Generated_Code/I2C2.c **** **         ---             - Error code, possible codes:
 626:../Generated_Code/I2C2.c **** **                           ERR_OK - OK
 627:../Generated_Code/I2C2.c **** **                           ERR_DISABLED -  Device is disabled
 628:../Generated_Code/I2C2.c **** **                           ERR_SPEED - This device does not work in
 629:../Generated_Code/I2C2.c **** **                           the active clock configuration
 630:../Generated_Code/I2C2.c **** ** ===================================================================
 631:../Generated_Code/I2C2.c **** */
 632:../Generated_Code/I2C2.c **** LDD_TError I2C2_GetError(LDD_TDeviceData *DeviceDataPtr, LDD_I2C_TErrorMask *ErrorMaskPtr)
 633:../Generated_Code/I2C2.c **** {
 1473              		.loc 1 633 0
 1474              		.cfi_startproc
 1475 0000 80B5     		push	{r7, lr}
 1476              	.LCFI18:
 1477              		.cfi_def_cfa_offset 8
 1478              		.cfi_offset 7, -8
 1479              		.cfi_offset 14, -4
 1480 0002 84B0     		sub	sp, sp, #16
 1481              	.LCFI19:
 1482              		.cfi_def_cfa_offset 24
 1483 0004 00AF     		add	r7, sp, #0
 1484              	.LCFI20:
 1485              		.cfi_def_cfa_register 7
 1486 0006 7860     		str	r0, [r7, #4]
 1487 0008 3960     		str	r1, [r7]
 634:../Generated_Code/I2C2.c ****   I2C2_TDeviceData *DeviceDataPrv = (I2C2_TDeviceData *)DeviceDataPtr;
 1488              		.loc 1 634 0
 1489 000a 7B68     		ldr	r3, [r7, #4]
 1490 000c FB60     		str	r3, [r7, #12]
 635:../Generated_Code/I2C2.c **** 
 636:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Critical section begin, general PE function is used */
 637:../Generated_Code/I2C2.c ****   EnterCritical();
 1491              		.loc 1 637 0
 1492 000e 144B     		ldr	r3, .L73
 1493 0010 1B78     		ldrb	r3, [r3]
 1494 0012 DBB2     		uxtb	r3, r3
 1495 0014 0133     		add	r3, r3, #1
 1496 0016 DBB2     		uxtb	r3, r3
 1497 0018 114A     		ldr	r2, .L73
 1498 001a 191C     		add	r1, r3, #0
 1499 001c 1170     		strb	r1, [r2]
 1500 001e 012B     		cmp	r3, #1
 1501 0020 04D1     		bne	.L71
 1502              		.loc 1 637 0 is_stmt 0 discriminator 1
 1503 0022 104B     		ldr	r3, .L73+4
 1504              	@ 637 "../Generated_Code/I2C2.c" 1
 1505 0024 EFF31080 		MRS R0, PRIMASK
 1506 0028 72B6     		CPSID i
 1507 002a 1870     		STRB R0, [r3]
 1508              	@ 0 "" 2
 1509              		.code	16
 1510              	.L71:
 638:../Generated_Code/I2C2.c ****   *ErrorMaskPtr = DeviceDataPrv->ErrorMask; /* Return last value of error mask */
 1511              		.loc 1 638 0 is_stmt 1
 1512 002c FB68     		ldr	r3, [r7, #12]
 1513 002e 5A88     		ldrh	r2, [r3, #2]
 1514 0030 3B68     		ldr	r3, [r7]
 1515 0032 1A80     		strh	r2, [r3]
 639:../Generated_Code/I2C2.c ****   DeviceDataPrv->ErrorMask = 0x00U;
 1516              		.loc 1 639 0
 1517 0034 FB68     		ldr	r3, [r7, #12]
 1518 0036 0022     		mov	r2, #0
 1519 0038 5A80     		strh	r2, [r3, #2]
 640:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Critical section end, general PE function is used */
 641:../Generated_Code/I2C2.c ****   ExitCritical();
 1520              		.loc 1 641 0
 1521 003a 094B     		ldr	r3, .L73
 1522 003c 1B78     		ldrb	r3, [r3]
 1523 003e DBB2     		uxtb	r3, r3
 1524 0040 013B     		sub	r3, r3, #1
 1525 0042 DBB2     		uxtb	r3, r3
 1526 0044 064A     		ldr	r2, .L73
 1527 0046 191C     		add	r1, r3, #0
 1528 0048 1170     		strb	r1, [r2]
 1529 004a 002B     		cmp	r3, #0
 1530 004c 03D1     		bne	.L72
 1531              		.loc 1 641 0 is_stmt 0 discriminator 1
 1532 004e 054B     		ldr	r3, .L73+4
 1533              	@ 641 "../Generated_Code/I2C2.c" 1
 1534 0050 1878     		ldrb r0, [r3]
 1535 0052 80F31088 		msr PRIMASK,r0;
 1536              		
 1537              	@ 0 "" 2
 1538              		.code	16
 1539              	.L72:
 642:../Generated_Code/I2C2.c ****   return ERR_OK;
 1540              		.loc 1 642 0 is_stmt 1
 1541 0056 0023     		mov	r3, #0
 643:../Generated_Code/I2C2.c **** }
 1542              		.loc 1 643 0
 1543 0058 181C     		mov	r0, r3
 1544 005a BD46     		mov	sp, r7
 1545 005c 04B0     		add	sp, sp, #16
 1546              		@ sp needed for prologue
 1547 005e 80BD     		pop	{r7, pc}
 1548              	.L74:
 1549              		.align	2
 1550              	.L73:
 1551 0060 00000000 		.word	SR_lock
 1552 0064 00000000 		.word	SR_reg
 1553              		.cfi_endproc
 1554              	.LFE6:
 1556              		.text
 1557              	.Letext0:
 1558              		.file 2 "C:/Freescale/CW MCU v10.3/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 1559              		.file 3 "C:/workspace/USBDM/Generated_Code/IO_Map.h"
 1560              		.file 4 "C:/workspace/USBDM/Generated_Code/PE_LDD.h"
 1561              		.file 5 "C:/workspace/USBDM/Generated_Code/Cpu.h"
DEFINED SYMBOLS
                            *ABS*:00000000 I2C2.c
C:\DOCUME~1\chenty\LOCALS~1\Temp\cc1WFVKR.s:18     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\cc1WFVKR.s:21     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 DeviceDataPrv__DEFAULT_RTOS_ALLOC
C:\DOCUME~1\chenty\LOCALS~1\Temp\cc1WFVKR.s:24     .bss.INT_I2C0__DEFAULT_RTOS_ISRPARAM:00000000 $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\cc1WFVKR.s:27     .bss.INT_I2C0__DEFAULT_RTOS_ISRPARAM:00000000 INT_I2C0__DEFAULT_RTOS_ISRPARAM
C:\DOCUME~1\chenty\LOCALS~1\Temp\cc1WFVKR.s:30     .text.I2C2_Interrupt:00000000 $t
C:\DOCUME~1\chenty\LOCALS~1\Temp\cc1WFVKR.s:35     .text.I2C2_Interrupt:00000000 I2C2_Interrupt
C:\DOCUME~1\chenty\LOCALS~1\Temp\cc1WFVKR.s:468    .text.I2C2_Interrupt:000002b4 $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\cc1WFVKR.s:474    .text.I2C2_Init:00000000 $t
C:\DOCUME~1\chenty\LOCALS~1\Temp\cc1WFVKR.s:479    .text.I2C2_Init:00000000 I2C2_Init
C:\DOCUME~1\chenty\LOCALS~1\Temp\cc1WFVKR.s:646    .text.I2C2_Init:000000fc $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\cc1WFVKR.s:659    .text.I2C2_Deinit:00000000 $t
C:\DOCUME~1\chenty\LOCALS~1\Temp\cc1WFVKR.s:664    .text.I2C2_Deinit:00000000 I2C2_Deinit
C:\DOCUME~1\chenty\LOCALS~1\Temp\cc1WFVKR.s:707    .text.I2C2_Deinit:00000030 $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\cc1WFVKR.s:715    .text.I2C2_MasterSendBlock:00000000 $t
C:\DOCUME~1\chenty\LOCALS~1\Temp\cc1WFVKR.s:720    .text.I2C2_MasterSendBlock:00000000 I2C2_MasterSendBlock
C:\DOCUME~1\chenty\LOCALS~1\Temp\cc1WFVKR.s:989    .text.I2C2_MasterSendBlock:0000018c $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\cc1WFVKR.s:996    .text.I2C2_MasterReceiveBlock:00000000 $t
C:\DOCUME~1\chenty\LOCALS~1\Temp\cc1WFVKR.s:1001   .text.I2C2_MasterReceiveBlock:00000000 I2C2_MasterReceiveBlock
C:\DOCUME~1\chenty\LOCALS~1\Temp\cc1WFVKR.s:1272   .text.I2C2_MasterReceiveBlock:0000018c $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\cc1WFVKR.s:1279   .text.I2C2_SelectSlaveDevice:00000000 $t
C:\DOCUME~1\chenty\LOCALS~1\Temp\cc1WFVKR.s:1284   .text.I2C2_SelectSlaveDevice:00000000 I2C2_SelectSlaveDevice
C:\DOCUME~1\chenty\LOCALS~1\Temp\cc1WFVKR.s:1461   .text.I2C2_SelectSlaveDevice:00000100 $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\cc1WFVKR.s:1466   .text.I2C2_GetError:00000000 $t
C:\DOCUME~1\chenty\LOCALS~1\Temp\cc1WFVKR.s:1471   .text.I2C2_GetError:00000000 I2C2_GetError
C:\DOCUME~1\chenty\LOCALS~1\Temp\cc1WFVKR.s:1551   .text.I2C2_GetError:00000060 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
I2C2_OnMasterBlockSent
I2C2_OnMasterBlockReceived
I2C2_OnError
PE_LDD_DeviceDataList
SR_lock
SR_reg

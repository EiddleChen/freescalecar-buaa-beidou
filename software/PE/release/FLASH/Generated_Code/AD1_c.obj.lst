   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"AD1.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.bss.ModeFlg,"aw",%nobits
  20              	ModeFlg:
  21 0000 00       		.space	1
  22              		.comm	AdcLdd1_DeviceDataPtr,4,4
  23              		.comm	SampleGroup,4,4
  24              		.comm	AD1_OutV,8,4
  25              		.section	.bss.OutFlg,"aw",%nobits
  28              	OutFlg:
  29 0000 00       		.space	1
  30              		.section	.text.AD1_MainMeasure,"ax",%progbits
  31              		.align	2
  32              		.code	16
  33              		.thumb_func
  35              	AD1_MainMeasure:
  36              	.LFB0:
  37              		.file 1 "../Generated_Code/AD1.c"
   1:../Generated_Code/AD1.c **** /** ###################################################################
   2:../Generated_Code/AD1.c **** **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
   3:../Generated_Code/AD1.c **** **     Filename    : AD1.c
   4:../Generated_Code/AD1.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/AD1.c **** **     Processor   : MKL25Z128VLK4
   6:../Generated_Code/AD1.c **** **     Component   : ADC
   7:../Generated_Code/AD1.c **** **     Version     : Component 01.667, Driver 01.00, CPU db: 3.00.000
   8:../Generated_Code/AD1.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/AD1.c **** **     Date/Time   : 2013-05-15, 17:26, # CodeGen: 51
  10:../Generated_Code/AD1.c **** **     Abstract    :
  11:../Generated_Code/AD1.c **** **         This device "ADC" implements an A/D converter,
  12:../Generated_Code/AD1.c **** **         its control methods and interrupt/event handling procedure.
  13:../Generated_Code/AD1.c **** **     Settings    :
  14:../Generated_Code/AD1.c **** **          Component name                                 : AD1
  15:../Generated_Code/AD1.c **** **          A/D converter                                  : ADC0
  16:../Generated_Code/AD1.c **** **          Sharing                                        : Disabled
  17:../Generated_Code/AD1.c **** **          Interrupt service/event                        : Disabled
  18:../Generated_Code/AD1.c **** **          A/D channels                                   : 4
  19:../Generated_Code/AD1.c **** **            Channel0                                     : 
  20:../Generated_Code/AD1.c **** **              A/D channel (pin)                          : ADC0_SE9/TSI0_CH6/PTB1/I2C0_SDA/TPM1_C
  21:../Generated_Code/AD1.c **** **              A/D channel (pin) signal                   : 
  22:../Generated_Code/AD1.c **** **              Mode select                                : Single Ended
  23:../Generated_Code/AD1.c **** **            Channel1                                     : 
  24:../Generated_Code/AD1.c **** **              A/D channel (pin)                          : ADC0_SE12/TSI0_CH7/PTB2/I2C0_SCL/TPM2_
  25:../Generated_Code/AD1.c **** **              A/D channel (pin) signal                   : 
  26:../Generated_Code/AD1.c **** **              Mode select                                : Single Ended
  27:../Generated_Code/AD1.c **** **            Channel2                                     : 
  28:../Generated_Code/AD1.c **** **              A/D channel (pin)                          : ADC0_SE13/TSI0_CH8/PTB3/I2C0_SDA/TPM2_
  29:../Generated_Code/AD1.c **** **              A/D channel (pin) signal                   : 
  30:../Generated_Code/AD1.c **** **              Mode select                                : Single Ended
  31:../Generated_Code/AD1.c **** **            Channel3                                     : 
  32:../Generated_Code/AD1.c **** **              A/D channel (pin)                          : ADC0_SE7b/PTD6/LLWU_P15/SPI1_MOSI/UART
  33:../Generated_Code/AD1.c **** **              A/D channel (pin) signal                   : 
  34:../Generated_Code/AD1.c **** **              Mode select                                : Single Ended
  35:../Generated_Code/AD1.c **** **          A/D resolution                                 : Autoselect
  36:../Generated_Code/AD1.c **** **          Conversion time                                : 1.125 ?s
  37:../Generated_Code/AD1.c **** **          Low-power mode                                 : Disabled
  38:../Generated_Code/AD1.c **** **          High-speed conversion mode                     : Enabled
  39:../Generated_Code/AD1.c **** **          Asynchro clock output                          : Disabled
  40:../Generated_Code/AD1.c **** **          Sample time                                    : 0 = short
  41:../Generated_Code/AD1.c **** **          Internal trigger                               : Disabled
  42:../Generated_Code/AD1.c **** **          Number of conversions                          : 1
  43:../Generated_Code/AD1.c **** **          Initialization                                 : 
  44:../Generated_Code/AD1.c **** **            Enabled in init. code                        : yes
  45:../Generated_Code/AD1.c **** **            Events enabled in init.                      : yes
  46:../Generated_Code/AD1.c **** **          CPU clock/speed selection                      : 
  47:../Generated_Code/AD1.c **** **            High speed mode                              : This component enabled
  48:../Generated_Code/AD1.c **** **            Low speed mode                               : This component disabled
  49:../Generated_Code/AD1.c **** **            Slow speed mode                              : This component disabled
  50:../Generated_Code/AD1.c **** **          High input limit                               : 1
  51:../Generated_Code/AD1.c **** **          Low input limit                                : 0
  52:../Generated_Code/AD1.c **** **          Get value directly                             : yes
  53:../Generated_Code/AD1.c **** **          Wait for result                                : yes
  54:../Generated_Code/AD1.c **** **     Contents    :
  55:../Generated_Code/AD1.c **** **         Measure    - byte AD1_Measure(bool WaitForResult);
  56:../Generated_Code/AD1.c **** **         GetValue16 - byte AD1_GetValue16(word *Values);
  57:../Generated_Code/AD1.c **** **         Calibrate  - byte AD1_Calibrate(bool WaitForResult);
  58:../Generated_Code/AD1.c **** **
  59:../Generated_Code/AD1.c **** **     Copyright : 1997 - 2012 Freescale, Inc. All Rights Reserved.
  60:../Generated_Code/AD1.c **** **     
  61:../Generated_Code/AD1.c **** **     http      : www.freescale.com
  62:../Generated_Code/AD1.c **** **     mail      : support@freescale.com
  63:../Generated_Code/AD1.c **** ** ###################################################################*/
  64:../Generated_Code/AD1.c **** 
  65:../Generated_Code/AD1.c **** /* MODULE AD1. */
  66:../Generated_Code/AD1.c **** 
  67:../Generated_Code/AD1.c **** #include "AD1.h"
  68:../Generated_Code/AD1.c **** 
  69:../Generated_Code/AD1.c **** #define STOP            0x00U          /* STOP state           */
  70:../Generated_Code/AD1.c **** #define MEASURE         0x01U          /* MESURE state         */
  71:../Generated_Code/AD1.c **** #define CONTINUOUS      0x02U          /* CONTINUOUS state     */
  72:../Generated_Code/AD1.c **** #define SINGLE          0x03U          /* SINGLE state         */
  73:../Generated_Code/AD1.c **** #define CALIBRATING     0x04U          /* CALIBRATING state    */
  74:../Generated_Code/AD1.c **** 
  75:../Generated_Code/AD1.c **** static volatile byte ModeFlg;          /* Current state of device */
  76:../Generated_Code/AD1.c **** LDD_TDeviceData *AdcLdd1_DeviceDataPtr; /* Device data pointer */
  77:../Generated_Code/AD1.c **** /* Sample group configuration */
  78:../Generated_Code/AD1.c **** LDD_ADC_TSample SampleGroup[AD1_SAMPLE_GROUP_SIZE];
  79:../Generated_Code/AD1.c **** /* Measure multiple channels flags  */
  80:../Generated_Code/AD1.c **** /* Temporary buffer for converting results */
  81:../Generated_Code/AD1.c **** volatile word AD1_OutV[AD1_SAMPLE_GROUP_SIZE]; /* Sum of measured values */
  82:../Generated_Code/AD1.c **** /* Calibration in progress flag */
  83:../Generated_Code/AD1.c **** static volatile bool OutFlg;           /* Measurement finish flag */
  84:../Generated_Code/AD1.c **** 
  85:../Generated_Code/AD1.c **** /*
  86:../Generated_Code/AD1.c **** ** ===================================================================
  87:../Generated_Code/AD1.c **** **     Method      :  MainMeasure (component ADC)
  88:../Generated_Code/AD1.c **** **
  89:../Generated_Code/AD1.c **** **     Description :
  90:../Generated_Code/AD1.c **** **         The method performs the conversion of the input channels in 
  91:../Generated_Code/AD1.c **** **         the polling mode.
  92:../Generated_Code/AD1.c **** **         This method is internal. It is used by Processor Expert only.
  93:../Generated_Code/AD1.c **** ** ===================================================================
  94:../Generated_Code/AD1.c **** */
  95:../Generated_Code/AD1.c **** static void AD1_MainMeasure(void)
  96:../Generated_Code/AD1.c **** {
  38              		.loc 1 96 0
  39              		.cfi_startproc
  40 0000 80B5     		push	{r7, lr}
  41              	.LCFI0:
  42              		.cfi_def_cfa_offset 8
  43              		.cfi_offset 7, -8
  44              		.cfi_offset 14, -4
  45 0002 82B0     		sub	sp, sp, #8
  46              	.LCFI1:
  47              		.cfi_def_cfa_offset 16
  48 0004 00AF     		add	r7, sp, #0
  49              	.LCFI2:
  50              		.cfi_def_cfa_register 7
  97:../Generated_Code/AD1.c ****   byte SumChan;                        /* Counter of measured channels */
  98:../Generated_Code/AD1.c **** 
  99:../Generated_Code/AD1.c ****   OutFlg = FALSE;                      /* Output values aren't available */
  51              		.loc 1 99 0
  52 0006 204B     		ldr	r3, .L5
  53 0008 0022     		mov	r2, #0
  54 000a 1A70     		strb	r2, [r3]
 100:../Generated_Code/AD1.c ****   SumChan = 0U;                        /* Set the counter of measured channels to 0 */
  55              		.loc 1 100 0
  56 000c FB1D     		add	r3, r7, #7
  57 000e 0022     		mov	r2, #0
  58 0010 1A70     		strb	r2, [r3]
 101:../Generated_Code/AD1.c **** 
 102:../Generated_Code/AD1.c ****   for (SumChan=0U; SumChan<4U; SumChan++) {
  59              		.loc 1 102 0
  60 0012 FB1D     		add	r3, r7, #7
  61 0014 0022     		mov	r2, #0
  62 0016 1A70     		strb	r2, [r3]
  63 0018 28E0     		b	.L2
  64              	.L4:
 103:../Generated_Code/AD1.c ****     SampleGroup[0].ChannelIdx = SumChan;
  65              		.loc 1 103 0
  66 001a 1C4B     		ldr	r3, .L5+4
  67 001c FA1D     		add	r2, r7, #7
  68 001e 1278     		ldrb	r2, [r2]
  69 0020 1A70     		strb	r2, [r3]
 104:../Generated_Code/AD1.c ****     (void)AdcLdd1_CreateSampleGroup(AdcLdd1_DeviceDataPtr, (LDD_ADC_TSample *)SampleGroup, 1U); /* 
  70              		.loc 1 104 0
  71 0022 1B4B     		ldr	r3, .L5+8
  72 0024 1A68     		ldr	r2, [r3]
  73 0026 194B     		ldr	r3, .L5+4
  74 0028 101C     		mov	r0, r2
  75 002a 191C     		mov	r1, r3
  76 002c 0122     		mov	r2, #1
  77 002e FFF7FEFF 		bl	AdcLdd1_CreateSampleGroup
 105:../Generated_Code/AD1.c ****     (void)AdcLdd1_StartSingleMeasurement(AdcLdd1_DeviceDataPtr);
  78              		.loc 1 105 0
  79 0032 174B     		ldr	r3, .L5+8
  80 0034 1B68     		ldr	r3, [r3]
  81 0036 181C     		mov	r0, r3
  82 0038 FFF7FEFF 		bl	AdcLdd1_StartSingleMeasurement
 106:../Generated_Code/AD1.c ****     while (AdcLdd1_GetMeasurementCompleteStatus(AdcLdd1_DeviceDataPtr) == FALSE) {} /* Wait for AD 
  83              		.loc 1 106 0
  84 003c C046     		mov	r8, r8
  85              	.L3:
  86              		.loc 1 106 0 is_stmt 0 discriminator 1
  87 003e 144B     		ldr	r3, .L5+8
  88 0040 1B68     		ldr	r3, [r3]
  89 0042 181C     		mov	r0, r3
  90 0044 FFF7FEFF 		bl	AdcLdd1_GetMeasurementCompleteStatus
  91 0048 031C     		mov	r3, r0
  92 004a F8D0     		beq	.L3
 107:../Generated_Code/AD1.c ****     AdcLdd1_GetMeasuredValues(AdcLdd1_DeviceDataPtr, (LDD_TData *)&AD1_OutV[SumChan]);
  93              		.loc 1 107 0 is_stmt 1
  94 004c 104B     		ldr	r3, .L5+8
  95 004e 1A68     		ldr	r2, [r3]
  96 0050 FB1D     		add	r3, r7, #7
  97 0052 1B78     		ldrb	r3, [r3]
  98 0054 5900     		lsl	r1, r3, #1
  99 0056 0F4B     		ldr	r3, .L5+12
 100 0058 CB18     		add	r3, r1, r3
 101 005a 101C     		mov	r0, r2
 102 005c 191C     		mov	r1, r3
 103 005e FFF7FEFF 		bl	AdcLdd1_GetMeasuredValues
 102:../Generated_Code/AD1.c ****   for (SumChan=0U; SumChan<4U; SumChan++) {
 104              		.loc 1 102 0
 105 0062 FB1D     		add	r3, r7, #7
 106 0064 FA1D     		add	r2, r7, #7
 107 0066 1278     		ldrb	r2, [r2]
 108 0068 0132     		add	r2, r2, #1
 109 006a 1A70     		strb	r2, [r3]
 110              	.L2:
 102:../Generated_Code/AD1.c ****   for (SumChan=0U; SumChan<4U; SumChan++) {
 111              		.loc 1 102 0 is_stmt 0 discriminator 1
 112 006c FB1D     		add	r3, r7, #7
 113 006e 1B78     		ldrb	r3, [r3]
 114 0070 032B     		cmp	r3, #3
 115 0072 D2D9     		bls	.L4
 108:../Generated_Code/AD1.c ****   }
 109:../Generated_Code/AD1.c ****   OutFlg = TRUE;                       /* Measured values are available */
 116              		.loc 1 109 0 is_stmt 1
 117 0074 044B     		ldr	r3, .L5
 118 0076 0122     		mov	r2, #1
 119 0078 1A70     		strb	r2, [r3]
 110:../Generated_Code/AD1.c ****   ModeFlg = STOP;                      /* Set the device to the stop mode */
 120              		.loc 1 110 0
 121 007a 074B     		ldr	r3, .L5+16
 122 007c 0022     		mov	r2, #0
 123 007e 1A70     		strb	r2, [r3]
 111:../Generated_Code/AD1.c **** }
 124              		.loc 1 111 0
 125 0080 BD46     		mov	sp, r7
 126 0082 02B0     		add	sp, sp, #8
 127              		@ sp needed for prologue
 128 0084 80BD     		pop	{r7, pc}
 129              	.L6:
 130 0086 C046     		.align	2
 131              	.L5:
 132 0088 00000000 		.word	OutFlg
 133 008c 00000000 		.word	SampleGroup
 134 0090 00000000 		.word	AdcLdd1_DeviceDataPtr
 135 0094 00000000 		.word	AD1_OutV
 136 0098 00000000 		.word	ModeFlg
 137              		.cfi_endproc
 138              	.LFE0:
 140              		.section	.text.PE_AD1_Measure,"ax",%progbits
 141              		.align	2
 142              		.global	PE_AD1_Measure
 143              		.code	16
 144              		.thumb_func
 146              	PE_AD1_Measure:
 147              	.LFB1:
 112:../Generated_Code/AD1.c **** /*
 113:../Generated_Code/AD1.c **** ** ===================================================================
 114:../Generated_Code/AD1.c **** **     Method      :  AD1_Measure (component ADC)
 115:../Generated_Code/AD1.c **** **
 116:../Generated_Code/AD1.c **** **     Description :
 117:../Generated_Code/AD1.c **** **         This method performs one measurement on all channels that
 118:../Generated_Code/AD1.c **** **         are set in the component inspector. (Note: If the <number of
 119:../Generated_Code/AD1.c **** **         conversions> is more than one the conversion of A/D channels
 120:../Generated_Code/AD1.c **** **         is performed specified number of times.)
 121:../Generated_Code/AD1.c **** **     Parameters  :
 122:../Generated_Code/AD1.c **** **         NAME            - DESCRIPTION
 123:../Generated_Code/AD1.c **** **         WaitForResult   - Wait for a result of a
 124:../Generated_Code/AD1.c **** **                           conversion. If <interrupt service> is
 125:../Generated_Code/AD1.c **** **                           disabled, A/D peripheral doesn't support
 126:../Generated_Code/AD1.c **** **                           measuring all channels at once or Autoscan
 127:../Generated_Code/AD1.c **** **                           mode property isn't enabled and at the same
 128:../Generated_Code/AD1.c **** **                           time the <number of channels> is greater
 129:../Generated_Code/AD1.c **** **                           than 1, then the WaitForResult parameter is
 130:../Generated_Code/AD1.c **** **                           ignored and the method waits for each
 131:../Generated_Code/AD1.c **** **                           result every time. If the <interrupt
 132:../Generated_Code/AD1.c **** **                           service> is disabled and a <number of
 133:../Generated_Code/AD1.c **** **                           conversions> is greater than 1, the
 134:../Generated_Code/AD1.c **** **                           parameter is ignored and the method also
 135:../Generated_Code/AD1.c **** **                           waits for each result every time.
 136:../Generated_Code/AD1.c **** **     Returns     :
 137:../Generated_Code/AD1.c **** **         ---             - Error code, possible codes:
 138:../Generated_Code/AD1.c **** **                           ERR_OK - OK
 139:../Generated_Code/AD1.c **** **                           ERR_SPEED - This device does not work in
 140:../Generated_Code/AD1.c **** **                           the active speed mode
 141:../Generated_Code/AD1.c **** **                           ERR_DISABLED - Device is disabled
 142:../Generated_Code/AD1.c **** **                           ERR_BUSY - A conversion is already running
 143:../Generated_Code/AD1.c **** ** ===================================================================
 144:../Generated_Code/AD1.c **** */
 145:../Generated_Code/AD1.c **** byte PE_AD1_Measure(void)
 146:../Generated_Code/AD1.c **** {
 148              		.loc 1 146 0
 149              		.cfi_startproc
 150 0000 80B5     		push	{r7, lr}
 151              	.LCFI3:
 152              		.cfi_def_cfa_offset 8
 153              		.cfi_offset 7, -8
 154              		.cfi_offset 14, -4
 155 0002 00AF     		add	r7, sp, #0
 156              	.LCFI4:
 157              		.cfi_def_cfa_register 7
 147:../Generated_Code/AD1.c ****   if (ModeFlg != STOP) {               /* Is the device in different mode than "stop"? */
 158              		.loc 1 147 0
 159 0004 074B     		ldr	r3, .L10
 160 0006 1B78     		ldrb	r3, [r3]
 161 0008 DBB2     		uxtb	r3, r3
 162 000a 002B     		cmp	r3, #0
 163 000c 01D0     		beq	.L8
 148:../Generated_Code/AD1.c ****     return ERR_BUSY;                   /* If yes then error */
 164              		.loc 1 148 0
 165 000e 0823     		mov	r3, #8
 166 0010 05E0     		b	.L9
 167              	.L8:
 149:../Generated_Code/AD1.c ****   }
 150:../Generated_Code/AD1.c ****   ModeFlg = MEASURE;                   /* Set state of device to the measure mode */
 168              		.loc 1 150 0
 169 0012 044B     		ldr	r3, .L10
 170 0014 0122     		mov	r2, #1
 171 0016 1A70     		strb	r2, [r3]
 151:../Generated_Code/AD1.c ****   AD1_MainMeasure();
 172              		.loc 1 151 0
 173 0018 FFF7FEFF 		bl	AD1_MainMeasure
 152:../Generated_Code/AD1.c ****   return ERR_OK;                       /* OK */
 174              		.loc 1 152 0
 175 001c 0023     		mov	r3, #0
 176              	.L9:
 153:../Generated_Code/AD1.c **** }
 177              		.loc 1 153 0
 178 001e 181C     		mov	r0, r3
 179 0020 BD46     		mov	sp, r7
 180              		@ sp needed for prologue
 181 0022 80BD     		pop	{r7, pc}
 182              	.L11:
 183              		.align	2
 184              	.L10:
 185 0024 00000000 		.word	ModeFlg
 186              		.cfi_endproc
 187              	.LFE1:
 189              		.section	.text.AD1_GetValue16,"ax",%progbits
 190              		.align	2
 191              		.global	AD1_GetValue16
 192              		.code	16
 193              		.thumb_func
 195              	AD1_GetValue16:
 196              	.LFB2:
 154:../Generated_Code/AD1.c **** 
 155:../Generated_Code/AD1.c **** /*
 156:../Generated_Code/AD1.c **** ** ===================================================================
 157:../Generated_Code/AD1.c **** **     Method      :  AD1_GetValue16 (component ADC)
 158:../Generated_Code/AD1.c **** **
 159:../Generated_Code/AD1.c **** **     Description :
 160:../Generated_Code/AD1.c **** **         This method returns the last measured values of all channels
 161:../Generated_Code/AD1.c **** **         justified to the left. Compared with <GetValue> method this
 162:../Generated_Code/AD1.c **** **         method returns more accurate result if the <number of
 163:../Generated_Code/AD1.c **** **         conversions> is greater than 1 and <AD resolution> is less
 164:../Generated_Code/AD1.c **** **         than 16 bits. In addition, the user code dependency on <AD
 165:../Generated_Code/AD1.c **** **         resolution> is eliminated.
 166:../Generated_Code/AD1.c **** **     Parameters  :
 167:../Generated_Code/AD1.c **** **         NAME            - DESCRIPTION
 168:../Generated_Code/AD1.c **** **       * Values          - Pointer to the array that contains
 169:../Generated_Code/AD1.c **** **                           the measured data.
 170:../Generated_Code/AD1.c **** **     Returns     :
 171:../Generated_Code/AD1.c **** **         ---             - Error code, possible codes:
 172:../Generated_Code/AD1.c **** **                           ERR_OK - OK
 173:../Generated_Code/AD1.c **** **                           ERR_SPEED - This device does not work in
 174:../Generated_Code/AD1.c **** **                           the active speed mode
 175:../Generated_Code/AD1.c **** **                           ERR_NOTAVAIL - Requested value not
 176:../Generated_Code/AD1.c **** **                           available
 177:../Generated_Code/AD1.c **** **                           ERR_OVERRUN - External trigger overrun flag
 178:../Generated_Code/AD1.c **** **                           was detected after the last value(s) was
 179:../Generated_Code/AD1.c **** **                           obtained (for example by GetValue). This
 180:../Generated_Code/AD1.c **** **                           error may not be supported on some CPUs
 181:../Generated_Code/AD1.c **** **                           (see generated code).
 182:../Generated_Code/AD1.c **** ** ===================================================================
 183:../Generated_Code/AD1.c **** */
 184:../Generated_Code/AD1.c **** byte AD1_GetValue16(word *Values)
 185:../Generated_Code/AD1.c **** {
 197              		.loc 1 185 0
 198              		.cfi_startproc
 199 0000 80B5     		push	{r7, lr}
 200              	.LCFI5:
 201              		.cfi_def_cfa_offset 8
 202              		.cfi_offset 7, -8
 203              		.cfi_offset 14, -4
 204 0002 82B0     		sub	sp, sp, #8
 205              	.LCFI6:
 206              		.cfi_def_cfa_offset 16
 207 0004 00AF     		add	r7, sp, #0
 208              	.LCFI7:
 209              		.cfi_def_cfa_register 7
 210 0006 7860     		str	r0, [r7, #4]
 186:../Generated_Code/AD1.c ****   if (!OutFlg) {                       /* Is output flag set? */
 211              		.loc 1 186 0
 212 0008 114B     		ldr	r3, .L15
 213 000a 1B78     		ldrb	r3, [r3]
 214 000c DBB2     		uxtb	r3, r3
 215 000e 002B     		cmp	r3, #0
 216 0010 01D1     		bne	.L13
 187:../Generated_Code/AD1.c ****     return ERR_NOTAVAIL;               /* If no then error */
 217              		.loc 1 187 0
 218 0012 0923     		mov	r3, #9
 219 0014 17E0     		b	.L14
 220              	.L13:
 188:../Generated_Code/AD1.c ****   }
 189:../Generated_Code/AD1.c ****   Values[0] = AD1_OutV[0];             /* Save measured values to the output buffer */
 221              		.loc 1 189 0
 222 0016 0F4B     		ldr	r3, .L15+4
 223 0018 1B88     		ldrh	r3, [r3]
 224 001a 9AB2     		uxth	r2, r3
 225 001c 7B68     		ldr	r3, [r7, #4]
 226 001e 1A80     		strh	r2, [r3]
 190:../Generated_Code/AD1.c ****   Values[1] = AD1_OutV[1];             /* Save measured values to the output buffer */
 227              		.loc 1 190 0
 228 0020 7B68     		ldr	r3, [r7, #4]
 229 0022 0233     		add	r3, r3, #2
 230 0024 0B4A     		ldr	r2, .L15+4
 231 0026 5288     		ldrh	r2, [r2, #2]
 232 0028 92B2     		uxth	r2, r2
 233 002a 1A80     		strh	r2, [r3]
 191:../Generated_Code/AD1.c ****   Values[2] = AD1_OutV[2];             /* Save measured values to the output buffer */
 234              		.loc 1 191 0
 235 002c 7B68     		ldr	r3, [r7, #4]
 236 002e 0433     		add	r3, r3, #4
 237 0030 084A     		ldr	r2, .L15+4
 238 0032 9288     		ldrh	r2, [r2, #4]
 239 0034 92B2     		uxth	r2, r2
 240 0036 1A80     		strh	r2, [r3]
 192:../Generated_Code/AD1.c ****   Values[3] = AD1_OutV[3];             /* Save measured values to the output buffer */
 241              		.loc 1 192 0
 242 0038 7B68     		ldr	r3, [r7, #4]
 243 003a 0633     		add	r3, r3, #6
 244 003c 054A     		ldr	r2, .L15+4
 245 003e D288     		ldrh	r2, [r2, #6]
 246 0040 92B2     		uxth	r2, r2
 247 0042 1A80     		strh	r2, [r3]
 193:../Generated_Code/AD1.c ****   return ERR_OK;                       /* OK */
 248              		.loc 1 193 0
 249 0044 0023     		mov	r3, #0
 250              	.L14:
 194:../Generated_Code/AD1.c **** }
 251              		.loc 1 194 0
 252 0046 181C     		mov	r0, r3
 253 0048 BD46     		mov	sp, r7
 254 004a 02B0     		add	sp, sp, #8
 255              		@ sp needed for prologue
 256 004c 80BD     		pop	{r7, pc}
 257              	.L16:
 258 004e C046     		.align	2
 259              	.L15:
 260 0050 00000000 		.word	OutFlg
 261 0054 00000000 		.word	AD1_OutV
 262              		.cfi_endproc
 263              	.LFE2:
 265              		.section	.text.PE_AD1_Calibrate,"ax",%progbits
 266              		.align	2
 267              		.global	PE_AD1_Calibrate
 268              		.code	16
 269              		.thumb_func
 271              	PE_AD1_Calibrate:
 272              	.LFB3:
 195:../Generated_Code/AD1.c **** 
 196:../Generated_Code/AD1.c **** /*
 197:../Generated_Code/AD1.c **** ** ===================================================================
 198:../Generated_Code/AD1.c **** **     Method      :  AD1_Calibrate (component ADC)
 199:../Generated_Code/AD1.c **** **
 200:../Generated_Code/AD1.c **** **     Description :
 201:../Generated_Code/AD1.c **** **         This method starts self calibration process. Calibration is
 202:../Generated_Code/AD1.c **** **         typically used to remove the effects of the gain and offset
 203:../Generated_Code/AD1.c **** **         from a specific reading.
 204:../Generated_Code/AD1.c **** **     Parameters  :
 205:../Generated_Code/AD1.c **** **         NAME            - DESCRIPTION
 206:../Generated_Code/AD1.c **** **         WaitForResult   - Wait for a result of
 207:../Generated_Code/AD1.c **** **                           calibration. If the <interrupt service> is
 208:../Generated_Code/AD1.c **** **                           disabled, the WaitForResult parameter is
 209:../Generated_Code/AD1.c **** **                           ignored and the method waits for
 210:../Generated_Code/AD1.c **** **                           calibration result every time.
 211:../Generated_Code/AD1.c **** **     Returns     :
 212:../Generated_Code/AD1.c **** **         ---             - Error code
 213:../Generated_Code/AD1.c **** **                           ERR_OK - OK
 214:../Generated_Code/AD1.c **** **                           ERR_BUSY - A conversion is already running
 215:../Generated_Code/AD1.c **** **                           ERR_SPEED - This device does not work in
 216:../Generated_Code/AD1.c **** **                           the active speed mode
 217:../Generated_Code/AD1.c **** **                           ERR_DISABLED - Device is disabled
 218:../Generated_Code/AD1.c **** **                           ERR_FAILED - Calibration hasn't been
 219:../Generated_Code/AD1.c **** **                           finished correctly
 220:../Generated_Code/AD1.c **** ** ===================================================================
 221:../Generated_Code/AD1.c **** */
 222:../Generated_Code/AD1.c **** byte PE_AD1_Calibrate(void)
 223:../Generated_Code/AD1.c **** {
 273              		.loc 1 223 0
 274              		.cfi_startproc
 275 0000 80B5     		push	{r7, lr}
 276              	.LCFI8:
 277              		.cfi_def_cfa_offset 8
 278              		.cfi_offset 7, -8
 279              		.cfi_offset 14, -4
 280 0002 00AF     		add	r7, sp, #0
 281              	.LCFI9:
 282              		.cfi_def_cfa_register 7
 224:../Generated_Code/AD1.c ****   if (ModeFlg != STOP) {               /* Is the device in different mode than "stop"? */
 283              		.loc 1 224 0
 284 0004 144B     		ldr	r3, .L22
 285 0006 1B78     		ldrb	r3, [r3]
 286 0008 DBB2     		uxtb	r3, r3
 287 000a 002B     		cmp	r3, #0
 288 000c 01D0     		beq	.L18
 225:../Generated_Code/AD1.c ****     return ERR_BUSY;                   /* If yes then error */
 289              		.loc 1 225 0
 290 000e 0823     		mov	r3, #8
 291 0010 1EE0     		b	.L19
 292              	.L18:
 226:../Generated_Code/AD1.c ****   }
 227:../Generated_Code/AD1.c ****   (void)AdcLdd1_GetMeasurementCompleteStatus(AdcLdd1_DeviceDataPtr); /* Clear measurement complete 
 293              		.loc 1 227 0
 294 0012 124B     		ldr	r3, .L22+4
 295 0014 1B68     		ldr	r3, [r3]
 296 0016 181C     		mov	r0, r3
 297 0018 FFF7FEFF 		bl	AdcLdd1_GetMeasurementCompleteStatus
 228:../Generated_Code/AD1.c ****   (void)AdcLdd1_StartCalibration(AdcLdd1_DeviceDataPtr); /* Start calibration */
 298              		.loc 1 228 0
 299 001c 0F4B     		ldr	r3, .L22+4
 300 001e 1B68     		ldr	r3, [r3]
 301 0020 181C     		mov	r0, r3
 302 0022 FFF7FEFF 		bl	AdcLdd1_StartCalibration
 229:../Generated_Code/AD1.c ****   while (!AdcLdd1_GetMeasurementCompleteStatus(AdcLdd1_DeviceDataPtr)) {}; /* Wait until calibratio
 303              		.loc 1 229 0
 304 0026 C046     		mov	r8, r8
 305              	.L20:
 306              		.loc 1 229 0 is_stmt 0 discriminator 1
 307 0028 0C4B     		ldr	r3, .L22+4
 308 002a 1B68     		ldr	r3, [r3]
 309 002c 181C     		mov	r0, r3
 310 002e FFF7FEFF 		bl	AdcLdd1_GetMeasurementCompleteStatus
 311 0032 031C     		mov	r3, r0
 312 0034 F8D0     		beq	.L20
 230:../Generated_Code/AD1.c ****   if (AdcLdd1_GetCalibrationResultStatus(AdcLdd1_DeviceDataPtr) != ERR_OK) { /* If calibration fail
 313              		.loc 1 230 0 is_stmt 1
 314 0036 094B     		ldr	r3, .L22+4
 315 0038 1B68     		ldr	r3, [r3]
 316 003a 181C     		mov	r0, r3
 317 003c FFF7FEFF 		bl	AdcLdd1_GetCalibrationResultStatus
 318 0040 031C     		mov	r3, r0
 319 0042 04D0     		beq	.L21
 231:../Generated_Code/AD1.c ****     ModeFlg = STOP;                    /* Set the device to the stop mode */
 320              		.loc 1 231 0
 321 0044 044B     		ldr	r3, .L22
 322 0046 0022     		mov	r2, #0
 323 0048 1A70     		strb	r2, [r3]
 232:../Generated_Code/AD1.c ****     return ERR_FAILED;                 /* Return ERR_FAILED error code */
 324              		.loc 1 232 0
 325 004a 1B23     		mov	r3, #27
 326 004c 00E0     		b	.L19
 327              	.L21:
 233:../Generated_Code/AD1.c ****   }
 234:../Generated_Code/AD1.c ****   return ERR_OK;                       /* ADC device is now calibrated */
 328              		.loc 1 234 0
 329 004e 0023     		mov	r3, #0
 330              	.L19:
 235:../Generated_Code/AD1.c **** }
 331              		.loc 1 235 0
 332 0050 181C     		mov	r0, r3
 333 0052 BD46     		mov	sp, r7
 334              		@ sp needed for prologue
 335 0054 80BD     		pop	{r7, pc}
 336              	.L23:
 337 0056 C046     		.align	2
 338              	.L22:
 339 0058 00000000 		.word	ModeFlg
 340 005c 00000000 		.word	AdcLdd1_DeviceDataPtr
 341              		.cfi_endproc
 342              	.LFE3:
 344              		.section	.text.AD1_Init,"ax",%progbits
 345              		.align	2
 346              		.global	AD1_Init
 347              		.code	16
 348              		.thumb_func
 350              	AD1_Init:
 351              	.LFB4:
 236:../Generated_Code/AD1.c **** 
 237:../Generated_Code/AD1.c **** /*
 238:../Generated_Code/AD1.c **** ** ===================================================================
 239:../Generated_Code/AD1.c **** **     Method      :  AD1_Init (component ADC)
 240:../Generated_Code/AD1.c **** **
 241:../Generated_Code/AD1.c **** **     Description :
 242:../Generated_Code/AD1.c **** **         Initializes the associated peripheral(s) and the component 
 243:../Generated_Code/AD1.c **** **         internal variables. The method is called automatically as a 
 244:../Generated_Code/AD1.c **** **         part of the application initialization code.
 245:../Generated_Code/AD1.c **** **         This method is internal. It is used by Processor Expert only.
 246:../Generated_Code/AD1.c **** ** ===================================================================
 247:../Generated_Code/AD1.c **** */
 248:../Generated_Code/AD1.c **** void AD1_Init(void)
 249:../Generated_Code/AD1.c **** {
 352              		.loc 1 249 0
 353              		.cfi_startproc
 354 0000 80B5     		push	{r7, lr}
 355              	.LCFI10:
 356              		.cfi_def_cfa_offset 8
 357              		.cfi_offset 7, -8
 358              		.cfi_offset 14, -4
 359 0002 00AF     		add	r7, sp, #0
 360              	.LCFI11:
 361              		.cfi_def_cfa_register 7
 250:../Generated_Code/AD1.c ****   OutFlg = FALSE;                      /* No measured value */
 362              		.loc 1 250 0
 363 0004 064B     		ldr	r3, .L25
 364 0006 0022     		mov	r2, #0
 365 0008 1A70     		strb	r2, [r3]
 251:../Generated_Code/AD1.c ****   ModeFlg = STOP;                      /* Device isn't running */
 366              		.loc 1 251 0
 367 000a 064B     		ldr	r3, .L25+4
 368 000c 0022     		mov	r2, #0
 369 000e 1A70     		strb	r2, [r3]
 252:../Generated_Code/AD1.c ****   AdcLdd1_DeviceDataPtr = AdcLdd1_Init(NULL); /* Calling init method of the inherited component */
 370              		.loc 1 252 0
 371 0010 0020     		mov	r0, #0
 372 0012 FFF7FEFF 		bl	AdcLdd1_Init
 373 0016 021C     		mov	r2, r0
 374 0018 034B     		ldr	r3, .L25+8
 375 001a 1A60     		str	r2, [r3]
 253:../Generated_Code/AD1.c **** }
 376              		.loc 1 253 0
 377 001c BD46     		mov	sp, r7
 378              		@ sp needed for prologue
 379 001e 80BD     		pop	{r7, pc}
 380              	.L26:
 381              		.align	2
 382              	.L25:
 383 0020 00000000 		.word	OutFlg
 384 0024 00000000 		.word	ModeFlg
 385 0028 00000000 		.word	AdcLdd1_DeviceDataPtr
 386              		.cfi_endproc
 387              	.LFE4:
 389              		.text
 390              	.Letext0:
 391              		.file 2 "C:/Freescale/CW MCU v10.3/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 392              		.file 3 "../Generated_Code/PE_Types.h"
 393              		.file 4 "../Generated_Code/PE_LDD.h"
DEFINED SYMBOLS
                            *ABS*:00000000 AD1.c
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccZYiMzk.s:20     .bss.ModeFlg:00000000 ModeFlg
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccZYiMzk.s:21     .bss.ModeFlg:00000000 $d
                            *COM*:00000004 AdcLdd1_DeviceDataPtr
                            *COM*:00000004 SampleGroup
                            *COM*:00000008 AD1_OutV
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccZYiMzk.s:28     .bss.OutFlg:00000000 OutFlg
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccZYiMzk.s:29     .bss.OutFlg:00000000 $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccZYiMzk.s:31     .text.AD1_MainMeasure:00000000 $t
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccZYiMzk.s:35     .text.AD1_MainMeasure:00000000 AD1_MainMeasure
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccZYiMzk.s:132    .text.AD1_MainMeasure:00000088 $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccZYiMzk.s:141    .text.PE_AD1_Measure:00000000 $t
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccZYiMzk.s:146    .text.PE_AD1_Measure:00000000 PE_AD1_Measure
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccZYiMzk.s:185    .text.PE_AD1_Measure:00000024 $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccZYiMzk.s:190    .text.AD1_GetValue16:00000000 $t
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccZYiMzk.s:195    .text.AD1_GetValue16:00000000 AD1_GetValue16
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccZYiMzk.s:260    .text.AD1_GetValue16:00000050 $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccZYiMzk.s:266    .text.PE_AD1_Calibrate:00000000 $t
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccZYiMzk.s:271    .text.PE_AD1_Calibrate:00000000 PE_AD1_Calibrate
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccZYiMzk.s:339    .text.PE_AD1_Calibrate:00000058 $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccZYiMzk.s:345    .text.AD1_Init:00000000 $t
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccZYiMzk.s:350    .text.AD1_Init:00000000 AD1_Init
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccZYiMzk.s:383    .text.AD1_Init:00000020 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
AdcLdd1_CreateSampleGroup
AdcLdd1_StartSingleMeasurement
AdcLdd1_GetMeasurementCompleteStatus
AdcLdd1_GetMeasuredValues
AdcLdd1_StartCalibration
AdcLdd1_GetCalibrationResultStatus
AdcLdd1_Init

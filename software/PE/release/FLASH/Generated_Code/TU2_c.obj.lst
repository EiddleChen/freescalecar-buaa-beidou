   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"TU2.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.rodata.ChannelDevice,"a",%progbits
  18              		.align	2
  21              	ChannelDevice:
  22 0000 00       		.space	1
  23 0001 000000   		.section	.rodata.ChannelMode,"a",%progbits
  24              		.align	2
  27              	ChannelMode:
  28 0000 00       		.space	1
  29 0001 000000   		.section	.bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC,"aw",%nobits
  30              		.align	2
  33              	DeviceDataPrv__DEFAULT_RTOS_ALLOC:
  34 0000 00000000 		.space	12
  34      00000000 
  34      00000000 
  35              		.section	.bss.INT_TPM1__DEFAULT_RTOS_ISRPARAM,"aw",%nobits
  36              		.align	2
  39              	INT_TPM1__DEFAULT_RTOS_ISRPARAM:
  40 0000 00000000 		.space	4
  41              		.section	.text.TU2_Init,"ax",%progbits
  42              		.align	2
  43              		.global	TU2_Init
  44              		.code	16
  45              		.thumb_func
  47              	TU2_Init:
  48              	.LFB0:
  49              		.file 1 "../Generated_Code/TU2.c"
   1:../Generated_Code/TU2.c **** /** ###################################################################
   2:../Generated_Code/TU2.c **** **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
   3:../Generated_Code/TU2.c **** **     Filename    : TU2.c
   4:../Generated_Code/TU2.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/TU2.c **** **     Processor   : MKL25Z128VLK4
   6:../Generated_Code/TU2.c **** **     Component   : TimerUnit_LDD
   7:../Generated_Code/TU2.c **** **     Version     : Component 01.139, Driver 01.09, CPU db: 3.00.000
   8:../Generated_Code/TU2.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/TU2.c **** **     Date/Time   : 2013-05-25, 21:24, # CodeGen: 82
  10:../Generated_Code/TU2.c **** **     Abstract    :
  11:../Generated_Code/TU2.c **** **          This TimerUnit component provides a low level API for unified hardware access across
  12:../Generated_Code/TU2.c **** **          various timer devices using the Prescaler-Counter-Compare-Capture timer structure.
  13:../Generated_Code/TU2.c **** **     Settings    :
  14:../Generated_Code/TU2.c **** **          Component name                                 : TU2
  15:../Generated_Code/TU2.c **** **          Module name                                    : TPM1
  16:../Generated_Code/TU2.c **** **          Counter                                        : TPM1_CNT
  17:../Generated_Code/TU2.c **** **          Counter direction                              : Up
  18:../Generated_Code/TU2.c **** **          Counter width                                  : 16 bits
  19:../Generated_Code/TU2.c **** **          Value type                                     : uint16_t
  20:../Generated_Code/TU2.c **** **          Input clock source                             : Internal
  21:../Generated_Code/TU2.c **** **            Counter frequency                            : 187.5 kHz
  22:../Generated_Code/TU2.c **** **          Counter restart                                : On-match
  23:../Generated_Code/TU2.c **** **            Period device                                : TPM1_MOD
  24:../Generated_Code/TU2.c **** **            Period                                       : 12 ms
  25:../Generated_Code/TU2.c **** **            Interrupt                                    : Enabled
  26:../Generated_Code/TU2.c **** **              Interrupt                                  : INT_TPM1
  27:../Generated_Code/TU2.c **** **              Interrupt priority                         : medium priority
  28:../Generated_Code/TU2.c **** **          Channel list                                   : 1
  29:../Generated_Code/TU2.c **** **            Channel 0                                    : 
  30:../Generated_Code/TU2.c **** **              Mode                                       : Compare
  31:../Generated_Code/TU2.c **** **                Compare                                  : TPM1_C0V
  32:../Generated_Code/TU2.c **** **                Offset                                   : 1 ms
  33:../Generated_Code/TU2.c **** **                Output on compare                        : Set
  34:../Generated_Code/TU2.c **** **                  Output on overrun                      : Clear
  35:../Generated_Code/TU2.c **** **                  Initial state                          : Low
  36:../Generated_Code/TU2.c **** **                  Output pin                             : ADC0_SE8/TSI0_CH0/PTB0/LLWU_P5/I2C0_SC
  37:../Generated_Code/TU2.c **** **                  Output pin signal                      : 
  38:../Generated_Code/TU2.c **** **                Interrupt                                : Disabled
  39:../Generated_Code/TU2.c **** **          Initialization                                 : 
  40:../Generated_Code/TU2.c **** **            Enabled in init. code                        : yes
  41:../Generated_Code/TU2.c **** **            Auto initialization                          : no
  42:../Generated_Code/TU2.c **** **            Event mask                                   : 
  43:../Generated_Code/TU2.c **** **              OnCounterRestart                           : Enabled
  44:../Generated_Code/TU2.c **** **              OnChannel0                                 : Disabled
  45:../Generated_Code/TU2.c **** **              OnChannel1                                 : Disabled
  46:../Generated_Code/TU2.c **** **              OnChannel2                                 : Disabled
  47:../Generated_Code/TU2.c **** **              OnChannel3                                 : Disabled
  48:../Generated_Code/TU2.c **** **              OnChannel4                                 : Disabled
  49:../Generated_Code/TU2.c **** **              OnChannel5                                 : Disabled
  50:../Generated_Code/TU2.c **** **              OnChannel6                                 : Disabled
  51:../Generated_Code/TU2.c **** **              OnChannel7                                 : Disabled
  52:../Generated_Code/TU2.c **** **          CPU clock/configuration selection              : 
  53:../Generated_Code/TU2.c **** **            Clock configuration 0                        : This component enabled
  54:../Generated_Code/TU2.c **** **            Clock configuration 1                        : This component disabled
  55:../Generated_Code/TU2.c **** **            Clock configuration 2                        : This component disabled
  56:../Generated_Code/TU2.c **** **            Clock configuration 3                        : This component enabled
  57:../Generated_Code/TU2.c **** **            Clock configuration 4                        : This component enabled
  58:../Generated_Code/TU2.c **** **            Clock configuration 5                        : This component enabled
  59:../Generated_Code/TU2.c **** **            Clock configuration 6                        : This component enabled
  60:../Generated_Code/TU2.c **** **            Clock configuration 7                        : This component enabled
  61:../Generated_Code/TU2.c **** **     Contents    :
  62:../Generated_Code/TU2.c **** **         Init               - LDD_TDeviceData* TU2_Init(LDD_TUserData *UserDataPtr);
  63:../Generated_Code/TU2.c **** **         Deinit             - void TU2_Deinit(LDD_TDeviceData *DeviceDataPtr);
  64:../Generated_Code/TU2.c **** **         GetPeriodTicks     - LDD_TError TU2_GetPeriodTicks(LDD_TDeviceData *DeviceDataPtr, TU2_T
  65:../Generated_Code/TU2.c **** **         GetCounterValue    - TU2_TValueType TU2_GetCounterValue(LDD_TDeviceData *DeviceDataPtr);
  66:../Generated_Code/TU2.c **** **         SetOffsetTicks     - LDD_TError TU2_SetOffsetTicks(LDD_TDeviceData *DeviceDataPtr, uint8
  67:../Generated_Code/TU2.c **** **         GetOffsetTicks     - LDD_TError TU2_GetOffsetTicks(LDD_TDeviceData *DeviceDataPtr, uint8
  68:../Generated_Code/TU2.c **** **         SelectOutputAction - LDD_TError TU2_SelectOutputAction(LDD_TDeviceData *DeviceDataPtr, u
  69:../Generated_Code/TU2.c **** **
  70:../Generated_Code/TU2.c **** **     Copyright : 1997 - 2012 Freescale, Inc. All Rights Reserved.
  71:../Generated_Code/TU2.c **** **     
  72:../Generated_Code/TU2.c **** **     http      : www.freescale.com
  73:../Generated_Code/TU2.c **** **     mail      : support@freescale.com
  74:../Generated_Code/TU2.c **** ** ###################################################################*/
  75:../Generated_Code/TU2.c **** 
  76:../Generated_Code/TU2.c **** /* MODULE TU2. */
  77:../Generated_Code/TU2.c **** 
  78:../Generated_Code/TU2.c **** #include "PwmLdd5.h"
  79:../Generated_Code/TU2.c **** #include "TU2.h"
  80:../Generated_Code/TU2.c **** /* {Default RTOS Adapter} No RTOS includes */
  81:../Generated_Code/TU2.c **** #include "IO_Map.h"
  82:../Generated_Code/TU2.c **** 
  83:../Generated_Code/TU2.c **** /* List of channels used by component */
  84:../Generated_Code/TU2.c **** static const uint8_t ChannelDevice[TU2_NUMBER_OF_CHANNELS] = {0x00U};
  85:../Generated_Code/TU2.c **** 
  86:../Generated_Code/TU2.c **** /* Table of channels mode / 0 - compare mode, 1 - capture mode */
  87:../Generated_Code/TU2.c **** static const uint8_t ChannelMode[TU2_NUMBER_OF_CHANNELS] = {0x00U};
  88:../Generated_Code/TU2.c **** 
  89:../Generated_Code/TU2.c **** 
  90:../Generated_Code/TU2.c **** typedef struct {
  91:../Generated_Code/TU2.c ****   LDD_TEventMask EnEvents;             /* Enable/Disable events mask */
  92:../Generated_Code/TU2.c ****   uint8_t InitCntr;                    /* Number of initialization */
  93:../Generated_Code/TU2.c ****   LDD_TUserData *UserDataPtr;          /* RTOS device data structure */
  94:../Generated_Code/TU2.c **** } TU2_TDeviceData;
  95:../Generated_Code/TU2.c **** 
  96:../Generated_Code/TU2.c **** typedef TU2_TDeviceData *TU2_TDeviceDataPtr; /* Pointer to the device data structure. */
  97:../Generated_Code/TU2.c **** 
  98:../Generated_Code/TU2.c **** /* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
  99:../Generated_Code/TU2.c **** static TU2_TDeviceData DeviceDataPrv__DEFAULT_RTOS_ALLOC;
 100:../Generated_Code/TU2.c **** /* {Default RTOS Adapter} Global variable used for passing a parameter into ISR */
 101:../Generated_Code/TU2.c **** static TU2_TDeviceDataPtr INT_TPM1__DEFAULT_RTOS_ISRPARAM;
 102:../Generated_Code/TU2.c **** 
 103:../Generated_Code/TU2.c **** #define AVAILABLE_EVENTS_MASK (LDD_TEventMask)(LDD_TIMERUNIT_ON_COUNTER_RESTART)
 104:../Generated_Code/TU2.c **** #define AVAILABLE_PIN_MASK (LDD_TPinMask)(TU2_CHANNEL_0_PIN)
 105:../Generated_Code/TU2.c **** #define LAST_CHANNEL 0x00U
 106:../Generated_Code/TU2.c **** 
 107:../Generated_Code/TU2.c **** /* Internal method prototypes */
 108:../Generated_Code/TU2.c **** /*
 109:../Generated_Code/TU2.c **** ** ===================================================================
 110:../Generated_Code/TU2.c **** **     Method      :  TU2_Init (component TimerUnit_LDD)
 111:../Generated_Code/TU2.c **** **
 112:../Generated_Code/TU2.c **** **     Description :
 113:../Generated_Code/TU2.c **** **         Initializes the device. Allocates memory for the device data
 114:../Generated_Code/TU2.c **** **         structure, allocates interrupt vectors and sets interrupt
 115:../Generated_Code/TU2.c **** **         priority, sets pin routing, sets timing, etc. If the
 116:../Generated_Code/TU2.c **** **         property <"Enable in init. code"> is set to "yes" value then
 117:../Generated_Code/TU2.c **** **         the device is also enabled (see the description of the
 118:../Generated_Code/TU2.c **** **         <Enable> method). In this case the <Enable> method is not
 119:../Generated_Code/TU2.c **** **         necessary and needn't to be generated. This method can be
 120:../Generated_Code/TU2.c **** **         called only once. Before the second call of Init the <Deinit>
 121:../Generated_Code/TU2.c **** **         must be called first.
 122:../Generated_Code/TU2.c **** **     Parameters  :
 123:../Generated_Code/TU2.c **** **         NAME            - DESCRIPTION
 124:../Generated_Code/TU2.c **** **       * UserDataPtr     - Pointer to the user or
 125:../Generated_Code/TU2.c **** **                           RTOS specific data. This pointer will be
 126:../Generated_Code/TU2.c **** **                           passed as an event or callback parameter.
 127:../Generated_Code/TU2.c **** **     Returns     :
 128:../Generated_Code/TU2.c **** **         ---             - Pointer to the dynamically allocated
 129:../Generated_Code/TU2.c **** **                           private structure or NULL if there was an
 130:../Generated_Code/TU2.c **** **                           error.
 131:../Generated_Code/TU2.c **** ** ===================================================================
 132:../Generated_Code/TU2.c **** */
 133:../Generated_Code/TU2.c **** LDD_TDeviceData* TU2_Init(LDD_TUserData *UserDataPtr)
 134:../Generated_Code/TU2.c **** {
  50              		.loc 1 134 0
  51              		.cfi_startproc
  52 0000 80B5     		push	{r7, lr}
  53              	.LCFI0:
  54              		.cfi_def_cfa_offset 8
  55              		.cfi_offset 7, -8
  56              		.cfi_offset 14, -4
  57 0002 84B0     		sub	sp, sp, #16
  58              	.LCFI1:
  59              		.cfi_def_cfa_offset 24
  60 0004 00AF     		add	r7, sp, #0
  61              	.LCFI2:
  62              		.cfi_def_cfa_register 7
  63 0006 7860     		str	r0, [r7, #4]
 135:../Generated_Code/TU2.c ****   TU2_TDeviceData *DeviceDataPrv;
 136:../Generated_Code/TU2.c **** 
 137:../Generated_Code/TU2.c ****   if (PE_LDD_DeviceDataList[PE_LDD_COMPONENT_TU2_ID] == NULL) {
  64              		.loc 1 137 0
  65 0008 344B     		ldr	r3, .L4
  66 000a 5B6B     		ldr	r3, [r3, #52]
  67 000c 002B     		cmp	r3, #0
  68 000e 53D1     		bne	.L2
 138:../Generated_Code/TU2.c ****     /* Allocate device structure */
 139:../Generated_Code/TU2.c ****     /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointe
 140:../Generated_Code/TU2.c ****     DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;
  69              		.loc 1 140 0
  70 0010 334B     		ldr	r3, .L4+4
  71 0012 FB60     		str	r3, [r7, #12]
 141:../Generated_Code/TU2.c ****     DeviceDataPrv->UserDataPtr = UserDataPtr; /* Store the RTOS device structure */
  72              		.loc 1 141 0
  73 0014 FB68     		ldr	r3, [r7, #12]
  74 0016 7A68     		ldr	r2, [r7, #4]
  75 0018 9A60     		str	r2, [r3, #8]
 142:../Generated_Code/TU2.c ****     DeviceDataPrv->InitCntr = 1U;      /* First initialization */
  76              		.loc 1 142 0
  77 001a FB68     		ldr	r3, [r7, #12]
  78 001c 0122     		mov	r2, #1
  79 001e 1A71     		strb	r2, [r3, #4]
 143:../Generated_Code/TU2.c ****   }
 144:../Generated_Code/TU2.c ****   else {
 145:../Generated_Code/TU2.c ****     /* Memory is already allocated */
 146:../Generated_Code/TU2.c ****     DeviceDataPrv = PE_LDD_DeviceDataList[PE_LDD_COMPONENT_TU2_ID];
 147:../Generated_Code/TU2.c ****     DeviceDataPrv->UserDataPtr = UserDataPtr; /* Store the RTOS device structure */
 148:../Generated_Code/TU2.c ****     DeviceDataPrv->InitCntr++;         /* Increment counter of initialization */
 149:../Generated_Code/TU2.c ****     return ((LDD_TDeviceData *)DeviceDataPrv); /* Return pointer to the device data structure */
 150:../Generated_Code/TU2.c ****   }
 151:../Generated_Code/TU2.c ****   /* Interrupt vector(s) allocation */
 152:../Generated_Code/TU2.c ****   /* {Default RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the glo
 153:../Generated_Code/TU2.c ****   INT_TPM1__DEFAULT_RTOS_ISRPARAM = DeviceDataPrv;
  80              		.loc 1 153 0
  81 0020 304B     		ldr	r3, .L4+8
  82 0022 FA68     		ldr	r2, [r7, #12]
  83 0024 1A60     		str	r2, [r3]
 154:../Generated_Code/TU2.c ****   /* SIM_SCGC6: TPM1=1 */
 155:../Generated_Code/TU2.c ****   SIM_SCGC6 |= SIM_SCGC6_TPM1_MASK;                                                   
  84              		.loc 1 155 0
  85 0026 304A     		ldr	r2, .L4+12
  86 0028 2F49     		ldr	r1, .L4+12
  87 002a 304B     		ldr	r3, .L4+16
  88 002c CB58     		ldr	r3, [r1, r3]
  89 002e 8021     		mov	r1, #128
  90 0030 8904     		lsl	r1, r1, #18
  91 0032 1943     		orr	r1, r3
  92 0034 2D4B     		ldr	r3, .L4+16
  93 0036 D150     		str	r1, [r2, r3]
 156:../Generated_Code/TU2.c ****   /* TPM1_SC: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,
 157:../Generated_Code/TU2.c ****   TPM1_SC = 0x00U;                     /* Clear status and control register */
  94              		.loc 1 157 0
  95 0038 2D4B     		ldr	r3, .L4+20
  96 003a 0022     		mov	r2, #0
  97 003c 1A60     		str	r2, [r3]
 158:../Generated_Code/TU2.c ****   /* TPM1_CNT: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,COUN
 159:../Generated_Code/TU2.c ****   TPM1_CNT = 0x00U;                    /* Reset counter register */
  98              		.loc 1 159 0
  99 003e 2C4B     		ldr	r3, .L4+20
 100 0040 0022     		mov	r2, #0
 101 0042 5A60     		str	r2, [r3, #4]
 160:../Generated_Code/TU2.c ****   /* TPM1_C0SC: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 161:../Generated_Code/TU2.c ****   TPM1_C0SC = 0x00U;                   /* Clear channel status and control register */
 102              		.loc 1 161 0
 103 0044 2A4B     		ldr	r3, .L4+20
 104 0046 0022     		mov	r2, #0
 105 0048 DA60     		str	r2, [r3, #12]
 162:../Generated_Code/TU2.c ****   /* TPM1_C1SC: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 163:../Generated_Code/TU2.c ****   TPM1_C1SC = 0x00U;                   /* Clear channel status and control register */
 106              		.loc 1 163 0
 107 004a 294B     		ldr	r3, .L4+20
 108 004c 0022     		mov	r2, #0
 109 004e 5A61     		str	r2, [r3, #20]
 164:../Generated_Code/TU2.c ****   /* TPM1_MOD: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,MOD=
 165:../Generated_Code/TU2.c ****   TPM1_MOD = TPM_MOD_MOD(0x08C9);      /* Set up modulo register */
 110              		.loc 1 165 0
 111 0050 274B     		ldr	r3, .L4+20
 112 0052 284A     		ldr	r2, .L4+24
 113 0054 9A60     		str	r2, [r3, #8]
 166:../Generated_Code/TU2.c ****   /* TPM1_C0SC: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 167:../Generated_Code/TU2.c ****   TPM1_C0SC = (TPM_CnSC_MSB_MASK | TPM_CnSC_ELSB_MASK | TPM_CnSC_ELSA_MASK); /* Set up channel stat
 114              		.loc 1 167 0
 115 0056 264B     		ldr	r3, .L4+20
 116 0058 2C22     		mov	r2, #44
 117 005a DA60     		str	r2, [r3, #12]
 168:../Generated_Code/TU2.c ****   /* TPM1_C0V: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,VAL=
 169:../Generated_Code/TU2.c ****   TPM1_C0V = TPM_CnV_VAL(0xBC);        /* Set up channel value register */
 118              		.loc 1 169 0
 119 005c 244B     		ldr	r3, .L4+20
 120 005e BC22     		mov	r2, #188
 121 0060 1A61     		str	r2, [r3, #16]
 170:../Generated_Code/TU2.c ****   /* PORTB_PCR0: ISF=0,MUX=3 */
 171:../Generated_Code/TU2.c ****   PORTB_PCR0 = (uint32_t)((PORTB_PCR0 & (uint32_t)~(uint32_t)(
 122              		.loc 1 171 0
 123 0062 254B     		ldr	r3, .L4+28
 124 0064 244A     		ldr	r2, .L4+28
 125 0066 1268     		ldr	r2, [r2]
 126 0068 111C     		mov	r1, r2
 127 006a 244A     		ldr	r2, .L4+32
 128 006c 0A40     		and	r2, r1
 129 006e C021     		mov	r1, #192
 130 0070 8900     		lsl	r1, r1, #2
 131 0072 0A43     		orr	r2, r1
 132 0074 1A60     		str	r2, [r3]
 172:../Generated_Code/TU2.c ****                 PORT_PCR_ISF_MASK |
 173:../Generated_Code/TU2.c ****                 PORT_PCR_MUX(0x04)
 174:../Generated_Code/TU2.c ****                )) | (uint32_t)(
 175:../Generated_Code/TU2.c ****                 PORT_PCR_MUX(0x03)
 176:../Generated_Code/TU2.c ****                ));                                                  
 177:../Generated_Code/TU2.c ****   DeviceDataPrv->EnEvents = 0x0100U;   /* Enable selected events */
 133              		.loc 1 177 0
 134 0076 FB68     		ldr	r3, [r7, #12]
 135 0078 8022     		mov	r2, #128
 136 007a 5200     		lsl	r2, r2, #1
 137 007c 1A60     		str	r2, [r3]
 178:../Generated_Code/TU2.c ****   /* NVIC_IPR4: PRI_18=0x80 */
 179:../Generated_Code/TU2.c ****   NVIC_IPR4 = (uint32_t)((NVIC_IPR4 & (uint32_t)~(uint32_t)(
 138              		.loc 1 179 0
 139 007e 204A     		ldr	r2, .L4+36
 140 0080 1F49     		ldr	r1, .L4+36
 141 0082 C423     		mov	r3, #196
 142 0084 9B00     		lsl	r3, r3, #2
 143 0086 CB58     		ldr	r3, [r1, r3]
 144 0088 191C     		mov	r1, r3
 145 008a 1E4B     		ldr	r3, .L4+40
 146 008c 0B40     		and	r3, r1
 147 008e 8021     		mov	r1, #128
 148 0090 0904     		lsl	r1, r1, #16
 149 0092 1943     		orr	r1, r3
 150 0094 C423     		mov	r3, #196
 151 0096 9B00     		lsl	r3, r3, #2
 152 0098 D150     		str	r1, [r2, r3]
 180:../Generated_Code/TU2.c ****                NVIC_IP_PRI_18(0x7F)
 181:../Generated_Code/TU2.c ****               )) | (uint32_t)(
 182:../Generated_Code/TU2.c ****                NVIC_IP_PRI_18(0x80)
 183:../Generated_Code/TU2.c ****               ));                                                  
 184:../Generated_Code/TU2.c ****   /* NVIC_ISER: SETENA|=0x00040000 */
 185:../Generated_Code/TU2.c ****   NVIC_ISER |= NVIC_ISER_SETENA(0x00040000);                                                   
 153              		.loc 1 185 0
 154 009a 194B     		ldr	r3, .L4+36
 155 009c 184A     		ldr	r2, .L4+36
 156 009e 1268     		ldr	r2, [r2]
 157 00a0 8021     		mov	r1, #128
 158 00a2 C902     		lsl	r1, r1, #11
 159 00a4 0A43     		orr	r2, r1
 160 00a6 1A60     		str	r2, [r3]
 186:../Generated_Code/TU2.c ****   /* TPM1_SC: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,
 187:../Generated_Code/TU2.c ****   TPM1_SC = (TPM_SC_TOIE_MASK | TPM_SC_CMOD(0x01) | TPM_SC_PS(0x07)); /* Set up status and control 
 161              		.loc 1 187 0
 162 00a8 114B     		ldr	r3, .L4+20
 163 00aa 4F22     		mov	r2, #79
 164 00ac 1A60     		str	r2, [r3]
 188:../Generated_Code/TU2.c ****   /* Registration of the device structure */
 189:../Generated_Code/TU2.c ****   PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_TU2_ID,DeviceDataPrv);
 165              		.loc 1 189 0
 166 00ae 0B4B     		ldr	r3, .L4
 167 00b0 FA68     		ldr	r2, [r7, #12]
 168 00b2 5A63     		str	r2, [r3, #52]
 190:../Generated_Code/TU2.c ****   return ((LDD_TDeviceData *)DeviceDataPrv); /* Return pointer to the device data structure */
 169              		.loc 1 190 0
 170 00b4 FB68     		ldr	r3, [r7, #12]
 171 00b6 0CE0     		b	.L3
 172              	.L2:
 146:../Generated_Code/TU2.c ****     DeviceDataPrv = PE_LDD_DeviceDataList[PE_LDD_COMPONENT_TU2_ID];
 173              		.loc 1 146 0
 174 00b8 084B     		ldr	r3, .L4
 175 00ba 5B6B     		ldr	r3, [r3, #52]
 176 00bc FB60     		str	r3, [r7, #12]
 147:../Generated_Code/TU2.c ****     DeviceDataPrv->UserDataPtr = UserDataPtr; /* Store the RTOS device structure */
 177              		.loc 1 147 0
 178 00be FB68     		ldr	r3, [r7, #12]
 179 00c0 7A68     		ldr	r2, [r7, #4]
 180 00c2 9A60     		str	r2, [r3, #8]
 148:../Generated_Code/TU2.c ****     DeviceDataPrv->InitCntr++;         /* Increment counter of initialization */
 181              		.loc 1 148 0
 182 00c4 FB68     		ldr	r3, [r7, #12]
 183 00c6 1B79     		ldrb	r3, [r3, #4]
 184 00c8 0133     		add	r3, r3, #1
 185 00ca DAB2     		uxtb	r2, r3
 186 00cc FB68     		ldr	r3, [r7, #12]
 187 00ce 1A71     		strb	r2, [r3, #4]
 149:../Generated_Code/TU2.c ****     return ((LDD_TDeviceData *)DeviceDataPrv); /* Return pointer to the device data structure */
 188              		.loc 1 149 0
 189 00d0 FB68     		ldr	r3, [r7, #12]
 190              	.L3:
 191:../Generated_Code/TU2.c **** }
 191              		.loc 1 191 0
 192 00d2 181C     		mov	r0, r3
 193 00d4 BD46     		mov	sp, r7
 194 00d6 04B0     		add	sp, sp, #16
 195              		@ sp needed for prologue
 196 00d8 80BD     		pop	{r7, pc}
 197              	.L5:
 198 00da C046     		.align	2
 199              	.L4:
 200 00dc 00000000 		.word	PE_LDD_DeviceDataList
 201 00e0 00000000 		.word	DeviceDataPrv__DEFAULT_RTOS_ALLOC
 202 00e4 00000000 		.word	INT_TPM1__DEFAULT_RTOS_ISRPARAM
 203 00e8 00700440 		.word	1074032640
 204 00ec 3C100000 		.word	4156
 205 00f0 00900340 		.word	1073975296
 206 00f4 C9080000 		.word	2249
 207 00f8 00A00440 		.word	1074044928
 208 00fc FFF8FFFE 		.word	-16779009
 209 0100 00E100E0 		.word	-536813312
 210 0104 FFFF00FF 		.word	-16711681
 211              		.cfi_endproc
 212              	.LFE0:
 214              		.section	.text.TU2_Deinit,"ax",%progbits
 215              		.align	2
 216              		.global	TU2_Deinit
 217              		.code	16
 218              		.thumb_func
 220              	TU2_Deinit:
 221              	.LFB1:
 192:../Generated_Code/TU2.c **** 
 193:../Generated_Code/TU2.c **** /*
 194:../Generated_Code/TU2.c **** ** ===================================================================
 195:../Generated_Code/TU2.c **** **     Method      :  TU2_Deinit (component TimerUnit_LDD)
 196:../Generated_Code/TU2.c **** **
 197:../Generated_Code/TU2.c **** **     Description :
 198:../Generated_Code/TU2.c **** **         Deinitializes the device. Switches off the device, frees the
 199:../Generated_Code/TU2.c **** **         device data structure memory, interrupts vectors, etc.
 200:../Generated_Code/TU2.c **** **     Parameters  :
 201:../Generated_Code/TU2.c **** **         NAME            - DESCRIPTION
 202:../Generated_Code/TU2.c **** **       * DeviceDataPtr   - Device data structure
 203:../Generated_Code/TU2.c **** **                           pointer returned by Init method
 204:../Generated_Code/TU2.c **** **     Returns     : Nothing
 205:../Generated_Code/TU2.c **** ** ===================================================================
 206:../Generated_Code/TU2.c **** */
 207:../Generated_Code/TU2.c **** void TU2_Deinit(LDD_TDeviceData *DeviceDataPtr)
 208:../Generated_Code/TU2.c **** {
 222              		.loc 1 208 0
 223              		.cfi_startproc
 224 0000 80B5     		push	{r7, lr}
 225              	.LCFI3:
 226              		.cfi_def_cfa_offset 8
 227              		.cfi_offset 7, -8
 228              		.cfi_offset 14, -4
 229 0002 84B0     		sub	sp, sp, #16
 230              	.LCFI4:
 231              		.cfi_def_cfa_offset 24
 232 0004 00AF     		add	r7, sp, #0
 233              	.LCFI5:
 234              		.cfi_def_cfa_register 7
 235 0006 7860     		str	r0, [r7, #4]
 209:../Generated_Code/TU2.c ****   TU2_TDeviceData *DeviceDataPrv = (TU2_TDeviceData *)DeviceDataPtr;
 236              		.loc 1 209 0
 237 0008 7B68     		ldr	r3, [r7, #4]
 238 000a FB60     		str	r3, [r7, #12]
 210:../Generated_Code/TU2.c **** 
 211:../Generated_Code/TU2.c ****   DeviceDataPrv->InitCntr--;           /* Decrement counter of initialization */
 239              		.loc 1 211 0
 240 000c FB68     		ldr	r3, [r7, #12]
 241 000e 1B79     		ldrb	r3, [r3, #4]
 242 0010 013B     		sub	r3, r3, #1
 243 0012 DAB2     		uxtb	r2, r3
 244 0014 FB68     		ldr	r3, [r7, #12]
 245 0016 1A71     		strb	r2, [r3, #4]
 212:../Generated_Code/TU2.c ****   if ((DeviceDataPrv->InitCntr) > 0U) { /* Is the result greater or equal than zero ? */
 246              		.loc 1 212 0
 247 0018 FB68     		ldr	r3, [r7, #12]
 248 001a 1B79     		ldrb	r3, [r3, #4]
 249 001c 002B     		cmp	r3, #0
 250 001e 09D1     		bne	.L9
 251              	.L7:
 213:../Generated_Code/TU2.c ****     return;                            /* If yes then de-initialization isn't complete */
 214:../Generated_Code/TU2.c ****   }
 215:../Generated_Code/TU2.c ****   TPM_PDD_SelectPrescalerSource(TPM1_BASE_PTR, TPM_PDD_DISABLED);
 252              		.loc 1 215 0
 253 0020 064B     		ldr	r3, .L10
 254 0022 064A     		ldr	r2, .L10
 255 0024 1268     		ldr	r2, [r2]
 256 0026 9821     		mov	r1, #152
 257 0028 8A43     		bic	r2, r1
 258 002a 1A60     		str	r2, [r3]
 216:../Generated_Code/TU2.c ****   /* Interrupt vector(s) deallocation */
 217:../Generated_Code/TU2.c ****   /* {Default RTOS Adapter} Restore interrupt vector: IVT is static, no code is generated */
 218:../Generated_Code/TU2.c ****   /* Unregistration of the device structure */
 219:../Generated_Code/TU2.c ****   PE_LDD_UnregisterDeviceStructure(PE_LDD_COMPONENT_TU2_ID);
 259              		.loc 1 219 0
 260 002c 044B     		ldr	r3, .L10+4
 261 002e 0022     		mov	r2, #0
 262 0030 5A63     		str	r2, [r3, #52]
 263 0032 00E0     		b	.L6
 264              	.L9:
 213:../Generated_Code/TU2.c ****     return;                            /* If yes then de-initialization isn't complete */
 265              		.loc 1 213 0
 266 0034 C046     		mov	r8, r8
 267              	.L6:
 220:../Generated_Code/TU2.c ****   /* Deallocation of the device structure */
 221:../Generated_Code/TU2.c ****   /* {Default RTOS Adapter} Driver memory deallocation: Dynamic allocation is simulated, no dealloc
 222:../Generated_Code/TU2.c **** }
 268              		.loc 1 222 0
 269 0036 BD46     		mov	sp, r7
 270 0038 04B0     		add	sp, sp, #16
 271              		@ sp needed for prologue
 272 003a 80BD     		pop	{r7, pc}
 273              	.L11:
 274              		.align	2
 275              	.L10:
 276 003c 00900340 		.word	1073975296
 277 0040 00000000 		.word	PE_LDD_DeviceDataList
 278              		.cfi_endproc
 279              	.LFE1:
 281              		.section	.text.TU2_GetPeriodTicks,"ax",%progbits
 282              		.align	2
 283              		.global	TU2_GetPeriodTicks
 284              		.code	16
 285              		.thumb_func
 287              	TU2_GetPeriodTicks:
 288              	.LFB2:
 223:../Generated_Code/TU2.c **** 
 224:../Generated_Code/TU2.c **** /*
 225:../Generated_Code/TU2.c **** ** ===================================================================
 226:../Generated_Code/TU2.c **** **     Method      :  TU2_GetPeriodTicks (component TimerUnit_LDD)
 227:../Generated_Code/TU2.c **** **
 228:../Generated_Code/TU2.c **** **     Description :
 229:../Generated_Code/TU2.c **** **         Returns the number of counter ticks before re-initialization.
 230:../Generated_Code/TU2.c **** **         See also method <SetPeriodTicks>. This method is available
 231:../Generated_Code/TU2.c **** **         only if the property <"Counter restart"> is switched to
 232:../Generated_Code/TU2.c **** **         'on-match' value.
 233:../Generated_Code/TU2.c **** **     Parameters  :
 234:../Generated_Code/TU2.c **** **         NAME            - DESCRIPTION
 235:../Generated_Code/TU2.c **** **       * DeviceDataPtr   - Device data structure
 236:../Generated_Code/TU2.c **** **                           pointer returned by <Init> method.
 237:../Generated_Code/TU2.c **** **       * TicksPtr        - Pointer to return value of the
 238:../Generated_Code/TU2.c **** **                           number of counter ticks before
 239:../Generated_Code/TU2.c **** **                           re-initialization
 240:../Generated_Code/TU2.c **** **     Returns     :
 241:../Generated_Code/TU2.c **** **         ---             - Error code, possible codes:
 242:../Generated_Code/TU2.c **** **                           ERR_OK - OK 
 243:../Generated_Code/TU2.c **** **                           ERR_SPEED - The component does not work in
 244:../Generated_Code/TU2.c **** **                           the active clock configuration
 245:../Generated_Code/TU2.c **** ** ===================================================================
 246:../Generated_Code/TU2.c **** */
 247:../Generated_Code/TU2.c **** LDD_TError TU2_GetPeriodTicks(LDD_TDeviceData *DeviceDataPtr, TU2_TValueType *TicksPtr)
 248:../Generated_Code/TU2.c **** {
 289              		.loc 1 248 0
 290              		.cfi_startproc
 291 0000 80B5     		push	{r7, lr}
 292              	.LCFI6:
 293              		.cfi_def_cfa_offset 8
 294              		.cfi_offset 7, -8
 295              		.cfi_offset 14, -4
 296 0002 84B0     		sub	sp, sp, #16
 297              	.LCFI7:
 298              		.cfi_def_cfa_offset 24
 299 0004 00AF     		add	r7, sp, #0
 300              	.LCFI8:
 301              		.cfi_def_cfa_register 7
 302 0006 7860     		str	r0, [r7, #4]
 303 0008 3960     		str	r1, [r7]
 249:../Generated_Code/TU2.c ****   uint16_t tmp;
 250:../Generated_Code/TU2.c **** 
 251:../Generated_Code/TU2.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 252:../Generated_Code/TU2.c ****   tmp = (uint16_t)(TPM_PDD_ReadModuloReg(TPM1_BASE_PTR));
 304              		.loc 1 252 0
 305 000a 0B4B     		ldr	r3, .L13
 306 000c 9B68     		ldr	r3, [r3, #8]
 307 000e 1A1C     		mov	r2, r3
 308 0010 3B1C     		mov	r3, r7
 309 0012 0E33     		add	r3, r3, #14
 310 0014 1A80     		strh	r2, [r3]
 253:../Generated_Code/TU2.c ****   *TicksPtr = (TU2_TValueType)++tmp;
 311              		.loc 1 253 0
 312 0016 3B1C     		mov	r3, r7
 313 0018 0E33     		add	r3, r3, #14
 314 001a 3A1C     		mov	r2, r7
 315 001c 0E32     		add	r2, r2, #14
 316 001e 1288     		ldrh	r2, [r2]
 317 0020 0132     		add	r2, r2, #1
 318 0022 1A80     		strh	r2, [r3]
 319 0024 3B68     		ldr	r3, [r7]
 320 0026 3A1C     		mov	r2, r7
 321 0028 0E32     		add	r2, r2, #14
 322 002a 1288     		ldrh	r2, [r2]
 323 002c 1A80     		strh	r2, [r3]
 254:../Generated_Code/TU2.c ****   return ERR_OK;                       /* OK */
 324              		.loc 1 254 0
 325 002e 0023     		mov	r3, #0
 255:../Generated_Code/TU2.c **** }
 326              		.loc 1 255 0
 327 0030 181C     		mov	r0, r3
 328 0032 BD46     		mov	sp, r7
 329 0034 04B0     		add	sp, sp, #16
 330              		@ sp needed for prologue
 331 0036 80BD     		pop	{r7, pc}
 332              	.L14:
 333              		.align	2
 334              	.L13:
 335 0038 00900340 		.word	1073975296
 336              		.cfi_endproc
 337              	.LFE2:
 339              		.section	.text.TU2_GetCounterValue,"ax",%progbits
 340              		.align	2
 341              		.global	TU2_GetCounterValue
 342              		.code	16
 343              		.thumb_func
 345              	TU2_GetCounterValue:
 346              	.LFB3:
 256:../Generated_Code/TU2.c **** 
 257:../Generated_Code/TU2.c **** /*
 258:../Generated_Code/TU2.c **** ** ===================================================================
 259:../Generated_Code/TU2.c **** **     Method      :  TU2_GetCounterValue (component TimerUnit_LDD)
 260:../Generated_Code/TU2.c **** **
 261:../Generated_Code/TU2.c **** **     Description :
 262:../Generated_Code/TU2.c **** **         Returns the content of counter register. This method can be
 263:../Generated_Code/TU2.c **** **         used both if counter is enabled and if counter is disabled.
 264:../Generated_Code/TU2.c **** **         The method is not available if HW doesn't allow reading of
 265:../Generated_Code/TU2.c **** **         the counter.
 266:../Generated_Code/TU2.c **** **     Parameters  :
 267:../Generated_Code/TU2.c **** **         NAME            - DESCRIPTION
 268:../Generated_Code/TU2.c **** **       * DeviceDataPtr   - Device data structure
 269:../Generated_Code/TU2.c **** **                           pointer returned by <Init> method.
 270:../Generated_Code/TU2.c **** **     Returns     :
 271:../Generated_Code/TU2.c **** **         ---             - Counter value (number of counted ticks).
 272:../Generated_Code/TU2.c **** ** ===================================================================
 273:../Generated_Code/TU2.c **** */
 274:../Generated_Code/TU2.c **** TU2_TValueType TU2_GetCounterValue(LDD_TDeviceData *DeviceDataPtr)
 275:../Generated_Code/TU2.c **** {
 347              		.loc 1 275 0
 348              		.cfi_startproc
 349 0000 80B5     		push	{r7, lr}
 350              	.LCFI9:
 351              		.cfi_def_cfa_offset 8
 352              		.cfi_offset 7, -8
 353              		.cfi_offset 14, -4
 354 0002 82B0     		sub	sp, sp, #8
 355              	.LCFI10:
 356              		.cfi_def_cfa_offset 16
 357 0004 00AF     		add	r7, sp, #0
 358              	.LCFI11:
 359              		.cfi_def_cfa_register 7
 360 0006 7860     		str	r0, [r7, #4]
 276:../Generated_Code/TU2.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 277:../Generated_Code/TU2.c ****   return (TU2_TValueType)TPM_PDD_ReadCounterReg(TPM1_BASE_PTR);
 361              		.loc 1 277 0
 362 0008 034B     		ldr	r3, .L16
 363 000a 5B68     		ldr	r3, [r3, #4]
 364 000c 9BB2     		uxth	r3, r3
 278:../Generated_Code/TU2.c **** }
 365              		.loc 1 278 0
 366 000e 181C     		mov	r0, r3
 367 0010 BD46     		mov	sp, r7
 368 0012 02B0     		add	sp, sp, #8
 369              		@ sp needed for prologue
 370 0014 80BD     		pop	{r7, pc}
 371              	.L17:
 372 0016 C046     		.align	2
 373              	.L16:
 374 0018 00900340 		.word	1073975296
 375              		.cfi_endproc
 376              	.LFE3:
 378              		.section	.text.TU2_SetOffsetTicks,"ax",%progbits
 379              		.align	2
 380              		.global	TU2_SetOffsetTicks
 381              		.code	16
 382              		.thumb_func
 384              	TU2_SetOffsetTicks:
 385              	.LFB4:
 279:../Generated_Code/TU2.c **** 
 280:../Generated_Code/TU2.c **** /*
 281:../Generated_Code/TU2.c **** ** ===================================================================
 282:../Generated_Code/TU2.c **** **     Method      :  TU2_SetOffsetTicks (component TimerUnit_LDD)
 283:../Generated_Code/TU2.c **** **
 284:../Generated_Code/TU2.c **** **     Description :
 285:../Generated_Code/TU2.c **** **         Sets the new offset value to channel specified by the
 286:../Generated_Code/TU2.c **** **         parameter ChannelIdx. It is user responsibility to use value
 287:../Generated_Code/TU2.c **** **         below selected period. This method is available when at
 288:../Generated_Code/TU2.c **** **         least one channel is configured.
 289:../Generated_Code/TU2.c **** **     Parameters  :
 290:../Generated_Code/TU2.c **** **         NAME            - DESCRIPTION
 291:../Generated_Code/TU2.c **** **       * DeviceDataPtr   - Device data structure
 292:../Generated_Code/TU2.c **** **                           pointer returned by <Init> method.
 293:../Generated_Code/TU2.c **** **         ChannelIdx      - Index of the component
 294:../Generated_Code/TU2.c **** **                           channel.
 295:../Generated_Code/TU2.c **** **         Ticks           - Number of counter ticks to compare
 296:../Generated_Code/TU2.c **** **                           match.
 297:../Generated_Code/TU2.c **** **     Returns     :
 298:../Generated_Code/TU2.c **** **         ---             - Error code, possible codes:
 299:../Generated_Code/TU2.c **** **                           ERR_OK - OK 
 300:../Generated_Code/TU2.c **** **                           ERR_PARAM_INDEX - ChannelIdx parameter is
 301:../Generated_Code/TU2.c **** **                           out of possible range.
 302:../Generated_Code/TU2.c **** **                           ERR_NOTAVAIL -  The compare mode is not
 303:../Generated_Code/TU2.c **** **                           selected for selected channel
 304:../Generated_Code/TU2.c **** **                           ERR_PARAM_TICKS - Ticks parameter is out of
 305:../Generated_Code/TU2.c **** **                           possible range.
 306:../Generated_Code/TU2.c **** **                           ERR_SPEED - The component does not work in
 307:../Generated_Code/TU2.c **** **                           the active clock configuration
 308:../Generated_Code/TU2.c **** ** ===================================================================
 309:../Generated_Code/TU2.c **** */
 310:../Generated_Code/TU2.c **** LDD_TError TU2_SetOffsetTicks(LDD_TDeviceData *DeviceDataPtr, uint8_t ChannelIdx, TU2_TValueType Ti
 311:../Generated_Code/TU2.c **** {
 386              		.loc 1 311 0
 387              		.cfi_startproc
 388 0000 80B5     		push	{r7, lr}
 389              	.LCFI12:
 390              		.cfi_def_cfa_offset 8
 391              		.cfi_offset 7, -8
 392              		.cfi_offset 14, -4
 393 0002 82B0     		sub	sp, sp, #8
 394              	.LCFI13:
 395              		.cfi_def_cfa_offset 16
 396 0004 00AF     		add	r7, sp, #0
 397              	.LCFI14:
 398              		.cfi_def_cfa_register 7
 399 0006 7860     		str	r0, [r7, #4]
 400 0008 FB1C     		add	r3, r7, #3
 401 000a 1970     		strb	r1, [r3]
 402 000c 3B1C     		mov	r3, r7
 403 000e 1A80     		strh	r2, [r3]
 312:../Generated_Code/TU2.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 313:../Generated_Code/TU2.c ****   /* Parameter test - this test can be disabled by setting the "Ignore range checking"
 314:../Generated_Code/TU2.c ****      property to the "yes" value in the "Configuration inspector" */
 315:../Generated_Code/TU2.c ****   if (ChannelIdx > LAST_CHANNEL) {     /* Is the channel index out of range? */
 404              		.loc 1 315 0
 405 0010 FB1C     		add	r3, r7, #3
 406 0012 1B78     		ldrb	r3, [r3]
 407 0014 002B     		cmp	r3, #0
 408 0016 01D0     		beq	.L19
 316:../Generated_Code/TU2.c ****     return ERR_PARAM_INDEX;            /* If yes then error */
 409              		.loc 1 316 0
 410 0018 8223     		mov	r3, #130
 411 001a 13E0     		b	.L20
 412              	.L19:
 317:../Generated_Code/TU2.c ****   }
 318:../Generated_Code/TU2.c ****   if ((ChannelMode[ChannelIdx]) != 0U) { /* Is the channel in compare mode? */
 413              		.loc 1 318 0
 414 001c FB1C     		add	r3, r7, #3
 415 001e 1B78     		ldrb	r3, [r3]
 416 0020 0A4A     		ldr	r2, .L22
 417 0022 D35C     		ldrb	r3, [r2, r3]
 418 0024 002B     		cmp	r3, #0
 419 0026 01D0     		beq	.L21
 319:../Generated_Code/TU2.c ****     return ERR_NOTAVAIL;               /* If not then error */
 420              		.loc 1 319 0
 421 0028 0923     		mov	r3, #9
 422 002a 0BE0     		b	.L20
 423              	.L21:
 320:../Generated_Code/TU2.c ****   }
 321:../Generated_Code/TU2.c ****   TPM_PDD_WriteChannelValueReg(TPM1_BASE_PTR, ChannelDevice[ChannelIdx], (uint16_t)Ticks);
 424              		.loc 1 321 0
 425 002c 0849     		ldr	r1, .L22+4
 426 002e FB1C     		add	r3, r7, #3
 427 0030 1B78     		ldrb	r3, [r3]
 428 0032 084A     		ldr	r2, .L22+8
 429 0034 D35C     		ldrb	r3, [r2, r3]
 430 0036 3A1C     		mov	r2, r7
 431 0038 1288     		ldrh	r2, [r2]
 432 003a 0133     		add	r3, r3, #1
 433 003c DB00     		lsl	r3, r3, #3
 434 003e CB18     		add	r3, r1, r3
 435 0040 9A60     		str	r2, [r3, #8]
 322:../Generated_Code/TU2.c ****   return ERR_OK;                       /* OK */
 436              		.loc 1 322 0
 437 0042 0023     		mov	r3, #0
 438              	.L20:
 323:../Generated_Code/TU2.c **** }
 439              		.loc 1 323 0
 440 0044 181C     		mov	r0, r3
 441 0046 BD46     		mov	sp, r7
 442 0048 02B0     		add	sp, sp, #8
 443              		@ sp needed for prologue
 444 004a 80BD     		pop	{r7, pc}
 445              	.L23:
 446              		.align	2
 447              	.L22:
 448 004c 00000000 		.word	ChannelMode
 449 0050 00900340 		.word	1073975296
 450 0054 00000000 		.word	ChannelDevice
 451              		.cfi_endproc
 452              	.LFE4:
 454              		.section	.text.TU2_GetOffsetTicks,"ax",%progbits
 455              		.align	2
 456              		.global	TU2_GetOffsetTicks
 457              		.code	16
 458              		.thumb_func
 460              	TU2_GetOffsetTicks:
 461              	.LFB5:
 324:../Generated_Code/TU2.c **** 
 325:../Generated_Code/TU2.c **** /*
 326:../Generated_Code/TU2.c **** ** ===================================================================
 327:../Generated_Code/TU2.c **** **     Method      :  TU2_GetOffsetTicks (component TimerUnit_LDD)
 328:../Generated_Code/TU2.c **** **
 329:../Generated_Code/TU2.c **** **     Description :
 330:../Generated_Code/TU2.c **** **         Returns the number of counter ticks to compare match channel
 331:../Generated_Code/TU2.c **** **         specified by the parameter ChannelIdx. See also method
 332:../Generated_Code/TU2.c **** **         <SetOffsetTicks>. This method is available when at least one
 333:../Generated_Code/TU2.c **** **         channel is configured.
 334:../Generated_Code/TU2.c **** **     Parameters  :
 335:../Generated_Code/TU2.c **** **         NAME            - DESCRIPTION
 336:../Generated_Code/TU2.c **** **       * DeviceDataPtr   - Device data structure
 337:../Generated_Code/TU2.c **** **                           pointer returned by <Init> method.
 338:../Generated_Code/TU2.c **** **         ChannelIdx      - Index of the component
 339:../Generated_Code/TU2.c **** **                           channel.
 340:../Generated_Code/TU2.c **** **       * TicksPtr        - Pointer to return value of the
 341:../Generated_Code/TU2.c **** **                           number of counter ticks to compare match.
 342:../Generated_Code/TU2.c **** **     Returns     :
 343:../Generated_Code/TU2.c **** **         ---             - Error code, possible codes:
 344:../Generated_Code/TU2.c **** **                           ERR_OK - OK 
 345:../Generated_Code/TU2.c **** **                           ERR_PARAM_INDEX - ChannelIdx parameter is
 346:../Generated_Code/TU2.c **** **                           out of possible range.
 347:../Generated_Code/TU2.c **** **                           ERR_NOTAVAIL -  The compare mode is not
 348:../Generated_Code/TU2.c **** **                           selected for selected channel.
 349:../Generated_Code/TU2.c **** **                           ERR_SPEED - The component does not work in
 350:../Generated_Code/TU2.c **** **                           the active clock configuration
 351:../Generated_Code/TU2.c **** ** ===================================================================
 352:../Generated_Code/TU2.c **** */
 353:../Generated_Code/TU2.c **** LDD_TError TU2_GetOffsetTicks(LDD_TDeviceData *DeviceDataPtr, uint8_t ChannelIdx, TU2_TValueType *T
 354:../Generated_Code/TU2.c **** {
 462              		.loc 1 354 0
 463              		.cfi_startproc
 464 0000 80B5     		push	{r7, lr}
 465              	.LCFI15:
 466              		.cfi_def_cfa_offset 8
 467              		.cfi_offset 7, -8
 468              		.cfi_offset 14, -4
 469 0002 84B0     		sub	sp, sp, #16
 470              	.LCFI16:
 471              		.cfi_def_cfa_offset 24
 472 0004 00AF     		add	r7, sp, #0
 473              	.LCFI17:
 474              		.cfi_def_cfa_register 7
 475 0006 F860     		str	r0, [r7, #12]
 476 0008 7A60     		str	r2, [r7, #4]
 477 000a 3B1C     		mov	r3, r7
 478 000c 0B33     		add	r3, r3, #11
 479 000e 0A1C     		add	r2, r1, #0
 480 0010 1A70     		strb	r2, [r3]
 355:../Generated_Code/TU2.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 356:../Generated_Code/TU2.c ****   /* Parameter test - this test can be disabled by setting the "Ignore range checking"
 357:../Generated_Code/TU2.c ****      property to the "yes" value in the "Configuration inspector" */
 358:../Generated_Code/TU2.c ****   if (ChannelIdx > LAST_CHANNEL) {     /* Is the channel index out of range? */
 481              		.loc 1 358 0
 482 0012 3B1C     		mov	r3, r7
 483 0014 0B33     		add	r3, r3, #11
 484 0016 1B78     		ldrb	r3, [r3]
 485 0018 002B     		cmp	r3, #0
 486 001a 01D0     		beq	.L25
 359:../Generated_Code/TU2.c ****     return ERR_PARAM_INDEX;            /* If yes then error */
 487              		.loc 1 359 0
 488 001c 8223     		mov	r3, #130
 489 001e 16E0     		b	.L26
 490              	.L25:
 360:../Generated_Code/TU2.c ****   }
 361:../Generated_Code/TU2.c ****   if ((ChannelMode[ChannelIdx]) != 0U) { /* Is the channel in compare mode? */
 491              		.loc 1 361 0
 492 0020 3B1C     		mov	r3, r7
 493 0022 0B33     		add	r3, r3, #11
 494 0024 1B78     		ldrb	r3, [r3]
 495 0026 0C4A     		ldr	r2, .L28
 496 0028 D35C     		ldrb	r3, [r2, r3]
 497 002a 002B     		cmp	r3, #0
 498 002c 01D0     		beq	.L27
 362:../Generated_Code/TU2.c ****     return ERR_NOTAVAIL;               /* If not then error */
 499              		.loc 1 362 0
 500 002e 0923     		mov	r3, #9
 501 0030 0DE0     		b	.L26
 502              	.L27:
 363:../Generated_Code/TU2.c ****   }
 364:../Generated_Code/TU2.c ****   *TicksPtr = (TU2_TValueType)(TPM_PDD_ReadChannelValueReg(TPM1_BASE_PTR, ChannelDevice[ChannelIdx]
 503              		.loc 1 364 0
 504 0032 0A4A     		ldr	r2, .L28+4
 505 0034 3B1C     		mov	r3, r7
 506 0036 0B33     		add	r3, r3, #11
 507 0038 1B78     		ldrb	r3, [r3]
 508 003a 0949     		ldr	r1, .L28+8
 509 003c CB5C     		ldrb	r3, [r1, r3]
 510 003e 0133     		add	r3, r3, #1
 511 0040 DB00     		lsl	r3, r3, #3
 512 0042 D318     		add	r3, r2, r3
 513 0044 9B68     		ldr	r3, [r3, #8]
 514 0046 9AB2     		uxth	r2, r3
 515 0048 7B68     		ldr	r3, [r7, #4]
 516 004a 1A80     		strh	r2, [r3]
 365:../Generated_Code/TU2.c ****   return ERR_OK;                       /* OK */
 517              		.loc 1 365 0
 518 004c 0023     		mov	r3, #0
 519              	.L26:
 366:../Generated_Code/TU2.c **** }
 520              		.loc 1 366 0
 521 004e 181C     		mov	r0, r3
 522 0050 BD46     		mov	sp, r7
 523 0052 04B0     		add	sp, sp, #16
 524              		@ sp needed for prologue
 525 0054 80BD     		pop	{r7, pc}
 526              	.L29:
 527 0056 C046     		.align	2
 528              	.L28:
 529 0058 00000000 		.word	ChannelMode
 530 005c 00900340 		.word	1073975296
 531 0060 00000000 		.word	ChannelDevice
 532              		.cfi_endproc
 533              	.LFE5:
 535              		.section	.text.TU2_SelectOutputAction,"ax",%progbits
 536              		.align	2
 537              		.global	TU2_SelectOutputAction
 538              		.code	16
 539              		.thumb_func
 541              	TU2_SelectOutputAction:
 542              	.LFB6:
 367:../Generated_Code/TU2.c **** 
 368:../Generated_Code/TU2.c **** /*
 369:../Generated_Code/TU2.c **** ** ===================================================================
 370:../Generated_Code/TU2.c **** **     Method      :  TU2_SelectOutputAction (component TimerUnit_LDD)
 371:../Generated_Code/TU2.c **** **
 372:../Generated_Code/TU2.c **** **     Description :
 373:../Generated_Code/TU2.c **** **         Sets the type of compare match and counter overflow action
 374:../Generated_Code/TU2.c **** **         on channel output. This method is available when at least
 375:../Generated_Code/TU2.c **** **         one channel is configured.
 376:../Generated_Code/TU2.c **** **     Parameters  :
 377:../Generated_Code/TU2.c **** **         NAME            - DESCRIPTION
 378:../Generated_Code/TU2.c **** **       * DeviceDataPtr   - Device data structure
 379:../Generated_Code/TU2.c **** **                           pointer returned by <Init> method.
 380:../Generated_Code/TU2.c **** **         ChannelIdx      - Index of the component
 381:../Generated_Code/TU2.c **** **                           channel.
 382:../Generated_Code/TU2.c **** **         CompareAction   - Select output action
 383:../Generated_Code/TU2.c **** **                           on compare match
 384:../Generated_Code/TU2.c **** **         CounterAction   - Select output action
 385:../Generated_Code/TU2.c **** **                           on counter overflow
 386:../Generated_Code/TU2.c **** **     Returns     :
 387:../Generated_Code/TU2.c **** **         ---             - Error code, possible codes:
 388:../Generated_Code/TU2.c **** **                           ERR_OK - OK
 389:../Generated_Code/TU2.c **** **                           ERR_PARAM_INDEX - ChannelIdx parameter is
 390:../Generated_Code/TU2.c **** **                           out of possible range
 391:../Generated_Code/TU2.c **** **                           ERR_NOTAVAIL -  Action is not possible on
 392:../Generated_Code/TU2.c **** **                           selected channel or counter. Supported
 393:../Generated_Code/TU2.c **** **                           combinations are HW specific.
 394:../Generated_Code/TU2.c **** **                           ERR_SPEED - The component does not work in
 395:../Generated_Code/TU2.c **** **                           the active clock configuration
 396:../Generated_Code/TU2.c **** ** ===================================================================
 397:../Generated_Code/TU2.c **** */
 398:../Generated_Code/TU2.c **** LDD_TError TU2_SelectOutputAction(LDD_TDeviceData *DeviceDataPtr, uint8_t ChannelIdx, LDD_TimerUnit
 399:../Generated_Code/TU2.c **** {
 543              		.loc 1 399 0
 544              		.cfi_startproc
 545 0000 90B5     		push	{r4, r7, lr}
 546              	.LCFI18:
 547              		.cfi_def_cfa_offset 12
 548              		.cfi_offset 4, -12
 549              		.cfi_offset 7, -8
 550              		.cfi_offset 14, -4
 551 0002 83B0     		sub	sp, sp, #12
 552              	.LCFI19:
 553              		.cfi_def_cfa_offset 24
 554 0004 00AF     		add	r7, sp, #0
 555              	.LCFI20:
 556              		.cfi_def_cfa_register 7
 557 0006 7860     		str	r0, [r7, #4]
 558 0008 081C     		mov	r0, r1
 559 000a 111C     		mov	r1, r2
 560 000c 1A1C     		mov	r2, r3
 561 000e FB1C     		add	r3, r7, #3
 562 0010 1870     		strb	r0, [r3]
 563 0012 BB1C     		add	r3, r7, #2
 564 0014 1970     		strb	r1, [r3]
 565 0016 7B1C     		add	r3, r7, #1
 566 0018 1A70     		strb	r2, [r3]
 400:../Generated_Code/TU2.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 401:../Generated_Code/TU2.c ****   /* Parameter test - this test can be disabled by setting the "Ignore range checking"
 402:../Generated_Code/TU2.c ****      property to the "yes" value in the "Configuration inspector" */
 403:../Generated_Code/TU2.c ****   if (ChannelIdx > LAST_CHANNEL) {     /* Is the channel index out of range? */
 567              		.loc 1 403 0
 568 001a FB1C     		add	r3, r7, #3
 569 001c 1B78     		ldrb	r3, [r3]
 570 001e 002B     		cmp	r3, #0
 571 0020 01D0     		beq	.L31
 404:../Generated_Code/TU2.c ****     return ERR_PARAM_INDEX;            /* If yes then error */
 572              		.loc 1 404 0
 573 0022 8223     		mov	r3, #130
 574 0024 06E1     		b	.L32
 575              	.L31:
 405:../Generated_Code/TU2.c ****   }
 406:../Generated_Code/TU2.c ****   if ((ChannelMode[ChannelIdx]) != 0U) { /* Is the channel in compare mode? */
 576              		.loc 1 406 0
 577 0026 FB1C     		add	r3, r7, #3
 578 0028 1B78     		ldrb	r3, [r3]
 579 002a 844A     		ldr	r2, .L49
 580 002c D35C     		ldrb	r3, [r2, r3]
 581 002e 002B     		cmp	r3, #0
 582 0030 01D0     		beq	.L33
 407:../Generated_Code/TU2.c ****     return ERR_NOTAVAIL;               /* If not then error */
 583              		.loc 1 407 0
 584 0032 0923     		mov	r3, #9
 585 0034 FEE0     		b	.L32
 586              	.L33:
 408:../Generated_Code/TU2.c ****   }
 409:../Generated_Code/TU2.c ****   switch (CounterAction) {
 587              		.loc 1 409 0
 588 0036 7B1C     		add	r3, r7, #1
 589 0038 1B78     		ldrb	r3, [r3]
 590 003a 022B     		cmp	r3, #2
 591 003c 00D1     		bne	.LCB441
 592 003e 8CE0     		b	.L36	@long jump
 593              	.LCB441:
 594 0040 032B     		cmp	r3, #3
 595 0042 00D1     		bne	.LCB443
 596 0044 BEE0     		b	.L37	@long jump
 597              	.LCB443:
 598 0046 002B     		cmp	r3, #0
 599 0048 00D0     		beq	.LCB445
 600 004a F0E0     		b	.L48	@long jump
 601              	.LCB445:
 602              	.L35:
 410:../Generated_Code/TU2.c ****     case OUTPUT_NONE:
 411:../Generated_Code/TU2.c ****       TPM_PDD_SelectChannelMode(TPM1_BASE_PTR, ChannelDevice[ChannelIdx], TPM_PDD_OUTPUT_TOGGLE);
 603              		.loc 1 411 0
 604 004c 7C49     		ldr	r1, .L49+4
 605 004e FB1C     		add	r3, r7, #3
 606 0050 1B78     		ldrb	r3, [r3]
 607 0052 7C4A     		ldr	r2, .L49+8
 608 0054 D35C     		ldrb	r3, [r2, r3]
 609 0056 181C     		mov	r0, r3
 610 0058 794A     		ldr	r2, .L49+4
 611 005a FB1C     		add	r3, r7, #3
 612 005c 1B78     		ldrb	r3, [r3]
 613 005e 794C     		ldr	r4, .L49+8
 614 0060 E35C     		ldrb	r3, [r4, r3]
 615 0062 0133     		add	r3, r3, #1
 616 0064 DB00     		lsl	r3, r3, #3
 617 0066 D318     		add	r3, r2, r3
 618 0068 5B68     		ldr	r3, [r3, #4]
 619 006a B022     		mov	r2, #176
 620 006c 9343     		bic	r3, r2
 621 006e 1022     		mov	r2, #16
 622 0070 1A43     		orr	r2, r3
 623 0072 431C     		add	r3, r0, #1
 624 0074 DB00     		lsl	r3, r3, #3
 625 0076 CB18     		add	r3, r1, r3
 626 0078 5A60     		str	r2, [r3, #4]
 412:../Generated_Code/TU2.c ****       switch (CompareAction) {
 627              		.loc 1 412 0
 628 007a BB1C     		add	r3, r7, #2
 629 007c 1B78     		ldrb	r3, [r3]
 630 007e 012B     		cmp	r3, #1
 631 0080 20D0     		beq	.L40
 632 0082 02DC     		bgt	.L43
 633 0084 002B     		cmp	r3, #0
 634 0086 05D0     		beq	.L39
 635 0088 64E0     		b	.L38
 636              	.L43:
 637 008a 022B     		cmp	r3, #2
 638 008c 32D0     		beq	.L41
 639 008e 032B     		cmp	r3, #3
 640 0090 48D0     		beq	.L42
 641 0092 5FE0     		b	.L38
 642              	.L39:
 413:../Generated_Code/TU2.c ****         case OUTPUT_NONE:
 414:../Generated_Code/TU2.c ****           TPM_PDD_SelectChannelEdgeLevel(TPM1_BASE_PTR, ChannelDevice[ChannelIdx], TPM_PDD_EDGE_NON
 643              		.loc 1 414 0
 644 0094 6A49     		ldr	r1, .L49+4
 645 0096 FB1C     		add	r3, r7, #3
 646 0098 1B78     		ldrb	r3, [r3]
 647 009a 6A4A     		ldr	r2, .L49+8
 648 009c D35C     		ldrb	r3, [r2, r3]
 649 009e 181C     		mov	r0, r3
 650 00a0 674A     		ldr	r2, .L49+4
 651 00a2 FB1C     		add	r3, r7, #3
 652 00a4 1B78     		ldrb	r3, [r3]
 653 00a6 674C     		ldr	r4, .L49+8
 654 00a8 E35C     		ldrb	r3, [r4, r3]
 655 00aa 0133     		add	r3, r3, #1
 656 00ac DB00     		lsl	r3, r3, #3
 657 00ae D318     		add	r3, r2, r3
 658 00b0 5B68     		ldr	r3, [r3, #4]
 659 00b2 8C22     		mov	r2, #140
 660 00b4 1C1C     		mov	r4, r3
 661 00b6 9443     		bic	r4, r2
 662 00b8 221C     		mov	r2, r4
 663 00ba 431C     		add	r3, r0, #1
 664 00bc DB00     		lsl	r3, r3, #3
 665 00be CB18     		add	r3, r1, r3
 666 00c0 5A60     		str	r2, [r3, #4]
 415:../Generated_Code/TU2.c ****           break;
 667              		.loc 1 415 0
 668 00c2 49E0     		b	.L44
 669              	.L40:
 416:../Generated_Code/TU2.c ****         case OUTPUT_TOGGLE:
 417:../Generated_Code/TU2.c ****           TPM_PDD_SelectChannelEdgeLevel(TPM1_BASE_PTR, ChannelDevice[ChannelIdx], TPM_PDD_EDGE_RIS
 670              		.loc 1 417 0
 671 00c4 5E49     		ldr	r1, .L49+4
 672 00c6 FB1C     		add	r3, r7, #3
 673 00c8 1B78     		ldrb	r3, [r3]
 674 00ca 5E4A     		ldr	r2, .L49+8
 675 00cc D35C     		ldrb	r3, [r2, r3]
 676 00ce 181C     		mov	r0, r3
 677 00d0 5B4A     		ldr	r2, .L49+4
 678 00d2 FB1C     		add	r3, r7, #3
 679 00d4 1B78     		ldrb	r3, [r3]
 680 00d6 5B4C     		ldr	r4, .L49+8
 681 00d8 E35C     		ldrb	r3, [r4, r3]
 682 00da 0133     		add	r3, r3, #1
 683 00dc DB00     		lsl	r3, r3, #3
 684 00de D318     		add	r3, r2, r3
 685 00e0 5B68     		ldr	r3, [r3, #4]
 686 00e2 8C22     		mov	r2, #140
 687 00e4 9343     		bic	r3, r2
 688 00e6 0422     		mov	r2, #4
 689 00e8 1A43     		orr	r2, r3
 690 00ea 431C     		add	r3, r0, #1
 691 00ec DB00     		lsl	r3, r3, #3
 692 00ee CB18     		add	r3, r1, r3
 693 00f0 5A60     		str	r2, [r3, #4]
 418:../Generated_Code/TU2.c ****           break;
 694              		.loc 1 418 0
 695 00f2 31E0     		b	.L44
 696              	.L41:
 419:../Generated_Code/TU2.c ****         case OUTPUT_CLEAR:
 420:../Generated_Code/TU2.c ****           TPM_PDD_SelectChannelEdgeLevel(TPM1_BASE_PTR, ChannelDevice[ChannelIdx], TPM_PDD_EDGE_FAL
 697              		.loc 1 420 0
 698 00f4 5249     		ldr	r1, .L49+4
 699 00f6 FB1C     		add	r3, r7, #3
 700 00f8 1B78     		ldrb	r3, [r3]
 701 00fa 524A     		ldr	r2, .L49+8
 702 00fc D35C     		ldrb	r3, [r2, r3]
 703 00fe 181C     		mov	r0, r3
 704 0100 4F4A     		ldr	r2, .L49+4
 705 0102 FB1C     		add	r3, r7, #3
 706 0104 1B78     		ldrb	r3, [r3]
 707 0106 4F4C     		ldr	r4, .L49+8
 708 0108 E35C     		ldrb	r3, [r4, r3]
 709 010a 0133     		add	r3, r3, #1
 710 010c DB00     		lsl	r3, r3, #3
 711 010e D318     		add	r3, r2, r3
 712 0110 5B68     		ldr	r3, [r3, #4]
 713 0112 8C22     		mov	r2, #140
 714 0114 9343     		bic	r3, r2
 715 0116 0822     		mov	r2, #8
 716 0118 1A43     		orr	r2, r3
 717 011a 431C     		add	r3, r0, #1
 718 011c DB00     		lsl	r3, r3, #3
 719 011e CB18     		add	r3, r1, r3
 720 0120 5A60     		str	r2, [r3, #4]
 421:../Generated_Code/TU2.c ****           break;
 721              		.loc 1 421 0
 722 0122 19E0     		b	.L44
 723              	.L42:
 422:../Generated_Code/TU2.c ****         case OUTPUT_SET:
 423:../Generated_Code/TU2.c ****           TPM_PDD_SelectChannelEdgeLevel(TPM1_BASE_PTR, ChannelDevice[ChannelIdx], TPM_PDD_EDGE_BOT
 724              		.loc 1 423 0
 725 0124 4649     		ldr	r1, .L49+4
 726 0126 FB1C     		add	r3, r7, #3
 727 0128 1B78     		ldrb	r3, [r3]
 728 012a 464A     		ldr	r2, .L49+8
 729 012c D35C     		ldrb	r3, [r2, r3]
 730 012e 181C     		mov	r0, r3
 731 0130 434A     		ldr	r2, .L49+4
 732 0132 FB1C     		add	r3, r7, #3
 733 0134 1B78     		ldrb	r3, [r3]
 734 0136 434C     		ldr	r4, .L49+8
 735 0138 E35C     		ldrb	r3, [r4, r3]
 736 013a 0133     		add	r3, r3, #1
 737 013c DB00     		lsl	r3, r3, #3
 738 013e D318     		add	r3, r2, r3
 739 0140 5B68     		ldr	r3, [r3, #4]
 740 0142 8C22     		mov	r2, #140
 741 0144 9343     		bic	r3, r2
 742 0146 0C22     		mov	r2, #12
 743 0148 1A43     		orr	r2, r3
 744 014a 431C     		add	r3, r0, #1
 745 014c DB00     		lsl	r3, r3, #3
 746 014e CB18     		add	r3, r1, r3
 747 0150 5A60     		str	r2, [r3, #4]
 424:../Generated_Code/TU2.c ****           break;
 748              		.loc 1 424 0
 749 0152 01E0     		b	.L44
 750              	.L38:
 425:../Generated_Code/TU2.c ****         default:
 426:../Generated_Code/TU2.c ****           return ERR_NOTAVAIL;
 751              		.loc 1 426 0
 752 0154 0923     		mov	r3, #9
 753 0156 6DE0     		b	.L32
 754              	.L44:
 427:../Generated_Code/TU2.c ****       }
 428:../Generated_Code/TU2.c ****       break;
 755              		.loc 1 428 0
 756 0158 6BE0     		b	.L45
 757              	.L36:
 429:../Generated_Code/TU2.c ****     case OUTPUT_CLEAR:
 430:../Generated_Code/TU2.c ****       if (CompareAction != OUTPUT_SET) {
 758              		.loc 1 430 0
 759 015a BB1C     		add	r3, r7, #2
 760 015c 1B78     		ldrb	r3, [r3]
 761 015e 032B     		cmp	r3, #3
 762 0160 01D0     		beq	.L46
 431:../Generated_Code/TU2.c ****         return ERR_NOTAVAIL;
 763              		.loc 1 431 0
 764 0162 0923     		mov	r3, #9
 765 0164 66E0     		b	.L32
 766              	.L46:
 432:../Generated_Code/TU2.c ****       }
 433:../Generated_Code/TU2.c ****       TPM_PDD_SelectChannelMode(TPM1_BASE_PTR, ChannelDevice[ChannelIdx], TPM_PDD_OUTPUT_CLEAR);
 767              		.loc 1 433 0
 768 0166 3649     		ldr	r1, .L49+4
 769 0168 FB1C     		add	r3, r7, #3
 770 016a 1B78     		ldrb	r3, [r3]
 771 016c 354A     		ldr	r2, .L49+8
 772 016e D35C     		ldrb	r3, [r2, r3]
 773 0170 181C     		mov	r0, r3
 774 0172 334A     		ldr	r2, .L49+4
 775 0174 FB1C     		add	r3, r7, #3
 776 0176 1B78     		ldrb	r3, [r3]
 777 0178 324C     		ldr	r4, .L49+8
 778 017a E35C     		ldrb	r3, [r4, r3]
 779 017c 0133     		add	r3, r3, #1
 780 017e DB00     		lsl	r3, r3, #3
 781 0180 D318     		add	r3, r2, r3
 782 0182 5B68     		ldr	r3, [r3, #4]
 783 0184 B022     		mov	r2, #176
 784 0186 9343     		bic	r3, r2
 785 0188 2022     		mov	r2, #32
 786 018a 1A43     		orr	r2, r3
 787 018c 431C     		add	r3, r0, #1
 788 018e DB00     		lsl	r3, r3, #3
 789 0190 CB18     		add	r3, r1, r3
 790 0192 5A60     		str	r2, [r3, #4]
 434:../Generated_Code/TU2.c ****       TPM_PDD_SelectChannelEdgeLevel(TPM1_BASE_PTR, ChannelDevice[ChannelIdx], TPM_PDD_EDGE_BOTH);
 791              		.loc 1 434 0
 792 0194 2A49     		ldr	r1, .L49+4
 793 0196 FB1C     		add	r3, r7, #3
 794 0198 1B78     		ldrb	r3, [r3]
 795 019a 2A4A     		ldr	r2, .L49+8
 796 019c D35C     		ldrb	r3, [r2, r3]
 797 019e 181C     		mov	r0, r3
 798 01a0 274A     		ldr	r2, .L49+4
 799 01a2 FB1C     		add	r3, r7, #3
 800 01a4 1B78     		ldrb	r3, [r3]
 801 01a6 274C     		ldr	r4, .L49+8
 802 01a8 E35C     		ldrb	r3, [r4, r3]
 803 01aa 0133     		add	r3, r3, #1
 804 01ac DB00     		lsl	r3, r3, #3
 805 01ae D318     		add	r3, r2, r3
 806 01b0 5B68     		ldr	r3, [r3, #4]
 807 01b2 8C22     		mov	r2, #140
 808 01b4 9343     		bic	r3, r2
 809 01b6 0C22     		mov	r2, #12
 810 01b8 1A43     		orr	r2, r3
 811 01ba 431C     		add	r3, r0, #1
 812 01bc DB00     		lsl	r3, r3, #3
 813 01be CB18     		add	r3, r1, r3
 814 01c0 5A60     		str	r2, [r3, #4]
 435:../Generated_Code/TU2.c ****       break;
 815              		.loc 1 435 0
 816 01c2 36E0     		b	.L45
 817              	.L37:
 436:../Generated_Code/TU2.c ****     case OUTPUT_SET:
 437:../Generated_Code/TU2.c ****       if (CompareAction != OUTPUT_CLEAR) {
 818              		.loc 1 437 0
 819 01c4 BB1C     		add	r3, r7, #2
 820 01c6 1B78     		ldrb	r3, [r3]
 821 01c8 022B     		cmp	r3, #2
 822 01ca 01D0     		beq	.L47
 438:../Generated_Code/TU2.c ****         return ERR_NOTAVAIL;
 823              		.loc 1 438 0
 824 01cc 0923     		mov	r3, #9
 825 01ce 31E0     		b	.L32
 826              	.L47:
 439:../Generated_Code/TU2.c ****       }
 440:../Generated_Code/TU2.c ****       TPM_PDD_SelectChannelMode(TPM1_BASE_PTR, ChannelDevice[ChannelIdx], TPM_PDD_OUTPUT_SET);
 827              		.loc 1 440 0
 828 01d0 1B49     		ldr	r1, .L49+4
 829 01d2 FB1C     		add	r3, r7, #3
 830 01d4 1B78     		ldrb	r3, [r3]
 831 01d6 1B4A     		ldr	r2, .L49+8
 832 01d8 D35C     		ldrb	r3, [r2, r3]
 833 01da 181C     		mov	r0, r3
 834 01dc 184A     		ldr	r2, .L49+4
 835 01de FB1C     		add	r3, r7, #3
 836 01e0 1B78     		ldrb	r3, [r3]
 837 01e2 184C     		ldr	r4, .L49+8
 838 01e4 E35C     		ldrb	r3, [r4, r3]
 839 01e6 0133     		add	r3, r3, #1
 840 01e8 DB00     		lsl	r3, r3, #3
 841 01ea D318     		add	r3, r2, r3
 842 01ec 5B68     		ldr	r3, [r3, #4]
 843 01ee B022     		mov	r2, #176
 844 01f0 9343     		bic	r3, r2
 845 01f2 3022     		mov	r2, #48
 846 01f4 1A43     		orr	r2, r3
 847 01f6 431C     		add	r3, r0, #1
 848 01f8 DB00     		lsl	r3, r3, #3
 849 01fa CB18     		add	r3, r1, r3
 850 01fc 5A60     		str	r2, [r3, #4]
 441:../Generated_Code/TU2.c ****       TPM_PDD_SelectChannelEdgeLevel(TPM1_BASE_PTR, ChannelDevice[ChannelIdx], TPM_PDD_EDGE_FALLING
 851              		.loc 1 441 0
 852 01fe 1049     		ldr	r1, .L49+4
 853 0200 FB1C     		add	r3, r7, #3
 854 0202 1B78     		ldrb	r3, [r3]
 855 0204 0F4A     		ldr	r2, .L49+8
 856 0206 D35C     		ldrb	r3, [r2, r3]
 857 0208 181C     		mov	r0, r3
 858 020a 0D4A     		ldr	r2, .L49+4
 859 020c FB1C     		add	r3, r7, #3
 860 020e 1B78     		ldrb	r3, [r3]
 861 0210 0C4C     		ldr	r4, .L49+8
 862 0212 E35C     		ldrb	r3, [r4, r3]
 863 0214 0133     		add	r3, r3, #1
 864 0216 DB00     		lsl	r3, r3, #3
 865 0218 D318     		add	r3, r2, r3
 866 021a 5B68     		ldr	r3, [r3, #4]
 867 021c 8C22     		mov	r2, #140
 868 021e 9343     		bic	r3, r2
 869 0220 0822     		mov	r2, #8
 870 0222 1A43     		orr	r2, r3
 871 0224 431C     		add	r3, r0, #1
 872 0226 DB00     		lsl	r3, r3, #3
 873 0228 CB18     		add	r3, r1, r3
 874 022a 5A60     		str	r2, [r3, #4]
 442:../Generated_Code/TU2.c ****       break;
 875              		.loc 1 442 0
 876 022c 01E0     		b	.L45
 877              	.L48:
 443:../Generated_Code/TU2.c ****     default:
 444:../Generated_Code/TU2.c ****       return ERR_NOTAVAIL;
 878              		.loc 1 444 0
 879 022e 0923     		mov	r3, #9
 880 0230 00E0     		b	.L32
 881              	.L45:
 445:../Generated_Code/TU2.c ****   }
 446:../Generated_Code/TU2.c ****   return ERR_OK;                       /* OK */
 882              		.loc 1 446 0
 883 0232 0023     		mov	r3, #0
 884              	.L32:
 447:../Generated_Code/TU2.c **** }
 885              		.loc 1 447 0
 886 0234 181C     		mov	r0, r3
 887 0236 BD46     		mov	sp, r7
 888 0238 03B0     		add	sp, sp, #12
 889              		@ sp needed for prologue
 890 023a 90BD     		pop	{r4, r7, pc}
 891              	.L50:
 892              		.align	2
 893              	.L49:
 894 023c 00000000 		.word	ChannelMode
 895 0240 00900340 		.word	1073975296
 896 0244 00000000 		.word	ChannelDevice
 897              		.cfi_endproc
 898              	.LFE6:
 900              		.section	.text.TU2_Interrupt,"ax",%progbits
 901              		.align	2
 902              		.global	TU2_Interrupt
 903              		.code	16
 904              		.thumb_func
 906              	TU2_Interrupt:
 907              	.LFB7:
 448:../Generated_Code/TU2.c **** 
 449:../Generated_Code/TU2.c **** /*
 450:../Generated_Code/TU2.c **** ** ===================================================================
 451:../Generated_Code/TU2.c **** **     Method      :  TU2_Interrupt (component TimerUnit_LDD)
 452:../Generated_Code/TU2.c **** **
 453:../Generated_Code/TU2.c **** **     Description :
 454:../Generated_Code/TU2.c **** **         The method services the interrupt of the selected peripheral(s)
 455:../Generated_Code/TU2.c **** **         and eventually invokes event(s) of the component.
 456:../Generated_Code/TU2.c **** **         This method is internal. It is used by Processor Expert only.
 457:../Generated_Code/TU2.c **** ** ===================================================================
 458:../Generated_Code/TU2.c **** */
 459:../Generated_Code/TU2.c **** PE_ISR(TU2_Interrupt)
 460:../Generated_Code/TU2.c **** {
 908              		.loc 1 460 0
 909              		.cfi_startproc
 910 0000 80B5     		push	{r7, lr}
 911              	.LCFI21:
 912              		.cfi_def_cfa_offset 8
 913              		.cfi_offset 7, -8
 914              		.cfi_offset 14, -4
 915 0002 82B0     		sub	sp, sp, #8
 916              	.LCFI22:
 917              		.cfi_def_cfa_offset 16
 918 0004 00AF     		add	r7, sp, #0
 919              	.LCFI23:
 920              		.cfi_def_cfa_register 7
 461:../Generated_Code/TU2.c ****   /* {Default RTOS Adapter} ISR parameter is passed through the global variable */
 462:../Generated_Code/TU2.c ****   TU2_TDeviceDataPtr DeviceDataPrv = INT_TPM1__DEFAULT_RTOS_ISRPARAM;
 921              		.loc 1 462 0
 922 0006 144B     		ldr	r3, .L54
 923 0008 1B68     		ldr	r3, [r3]
 924 000a 3B60     		str	r3, [r7]
 463:../Generated_Code/TU2.c **** 
 464:../Generated_Code/TU2.c ****   LDD_TEventMask State = 0U;
 925              		.loc 1 464 0
 926 000c 0023     		mov	r3, #0
 927 000e 7B60     		str	r3, [r7, #4]
 465:../Generated_Code/TU2.c **** 
 466:../Generated_Code/TU2.c ****   if ((TPM_PDD_GetOverflowInterruptFlag(TPM1_BASE_PTR)) != 0U) { /* Is the overflow interrupt flag 
 928              		.loc 1 466 0
 929 0010 124B     		ldr	r3, .L54+4
 930 0012 1B68     		ldr	r3, [r3]
 931 0014 1A1C     		mov	r2, r3
 932 0016 8023     		mov	r3, #128
 933 0018 1340     		and	r3, r2
 934 001a 04D0     		beq	.L52
 467:../Generated_Code/TU2.c ****     State |= LDD_TIMERUNIT_ON_COUNTER_RESTART; /* and set mask */
 935              		.loc 1 467 0
 936 001c 7B68     		ldr	r3, [r7, #4]
 937 001e 8022     		mov	r2, #128
 938 0020 5200     		lsl	r2, r2, #1
 939 0022 1343     		orr	r3, r2
 940 0024 7B60     		str	r3, [r7, #4]
 941              	.L52:
 468:../Generated_Code/TU2.c ****   }
 469:../Generated_Code/TU2.c ****   State &= DeviceDataPrv->EnEvents;    /* Handle only enabled interrupts */
 942              		.loc 1 469 0
 943 0026 3B68     		ldr	r3, [r7]
 944 0028 1A68     		ldr	r2, [r3]
 945 002a 7B68     		ldr	r3, [r7, #4]
 946 002c 1340     		and	r3, r2
 947 002e 7B60     		str	r3, [r7, #4]
 470:../Generated_Code/TU2.c ****   if (State & LDD_TIMERUNIT_ON_COUNTER_RESTART) { /* Is the overflow interrupt flag pending? */
 948              		.loc 1 470 0
 949 0030 7A68     		ldr	r2, [r7, #4]
 950 0032 8023     		mov	r3, #128
 951 0034 5B00     		lsl	r3, r3, #1
 952 0036 1340     		and	r3, r2
 953 0038 0AD0     		beq	.L51
 471:../Generated_Code/TU2.c ****     TPM_PDD_ClearOverflowInterruptFlag(TPM1_BASE_PTR); /* Clear flag */
 954              		.loc 1 471 0
 955 003a 084B     		ldr	r3, .L54+4
 956 003c 074A     		ldr	r2, .L54+4
 957 003e 1268     		ldr	r2, [r2]
 958 0040 8021     		mov	r1, #128
 959 0042 0A43     		orr	r2, r1
 960 0044 1A60     		str	r2, [r3]
 472:../Generated_Code/TU2.c ****     TU2_OnCounterRestart(DeviceDataPrv->UserDataPtr); /* Invoke OnCounterRestart event */
 961              		.loc 1 472 0
 962 0046 3B68     		ldr	r3, [r7]
 963 0048 9B68     		ldr	r3, [r3, #8]
 964 004a 181C     		mov	r0, r3
 965 004c FFF7FEFF 		bl	TU2_OnCounterRestart
 966              	.L51:
 473:../Generated_Code/TU2.c ****   }
 474:../Generated_Code/TU2.c **** }
 967              		.loc 1 474 0
 968 0050 BD46     		mov	sp, r7
 969 0052 02B0     		add	sp, sp, #8
 970              		@ sp needed for prologue
 971 0054 80BD     		pop	{r7, pc}
 972              	.L55:
 973 0056 C046     		.align	2
 974              	.L54:
 975 0058 00000000 		.word	INT_TPM1__DEFAULT_RTOS_ISRPARAM
 976 005c 00900340 		.word	1073975296
 977              		.cfi_endproc
 978              	.LFE7:
 980              		.text
 981              	.Letext0:
 982              		.file 2 "C:/Freescale/CW MCU v10.3/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 983              		.file 3 "../Generated_Code/IO_Map.h"
 984              		.file 4 "../Generated_Code/PE_LDD.h"
 985              		.file 5 "../Generated_Code/TU2.h"
DEFINED SYMBOLS
                            *ABS*:00000000 TU2.c
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccazdgAa.s:18     .rodata.ChannelDevice:00000000 $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccazdgAa.s:21     .rodata.ChannelDevice:00000000 ChannelDevice
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccazdgAa.s:24     .rodata.ChannelMode:00000000 $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccazdgAa.s:27     .rodata.ChannelMode:00000000 ChannelMode
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccazdgAa.s:30     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccazdgAa.s:33     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 DeviceDataPrv__DEFAULT_RTOS_ALLOC
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccazdgAa.s:36     .bss.INT_TPM1__DEFAULT_RTOS_ISRPARAM:00000000 $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccazdgAa.s:39     .bss.INT_TPM1__DEFAULT_RTOS_ISRPARAM:00000000 INT_TPM1__DEFAULT_RTOS_ISRPARAM
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccazdgAa.s:42     .text.TU2_Init:00000000 $t
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccazdgAa.s:47     .text.TU2_Init:00000000 TU2_Init
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccazdgAa.s:200    .text.TU2_Init:000000dc $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccazdgAa.s:215    .text.TU2_Deinit:00000000 $t
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccazdgAa.s:220    .text.TU2_Deinit:00000000 TU2_Deinit
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccazdgAa.s:276    .text.TU2_Deinit:0000003c $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccazdgAa.s:282    .text.TU2_GetPeriodTicks:00000000 $t
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccazdgAa.s:287    .text.TU2_GetPeriodTicks:00000000 TU2_GetPeriodTicks
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccazdgAa.s:335    .text.TU2_GetPeriodTicks:00000038 $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccazdgAa.s:340    .text.TU2_GetCounterValue:00000000 $t
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccazdgAa.s:345    .text.TU2_GetCounterValue:00000000 TU2_GetCounterValue
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccazdgAa.s:374    .text.TU2_GetCounterValue:00000018 $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccazdgAa.s:379    .text.TU2_SetOffsetTicks:00000000 $t
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccazdgAa.s:384    .text.TU2_SetOffsetTicks:00000000 TU2_SetOffsetTicks
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccazdgAa.s:448    .text.TU2_SetOffsetTicks:0000004c $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccazdgAa.s:455    .text.TU2_GetOffsetTicks:00000000 $t
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccazdgAa.s:460    .text.TU2_GetOffsetTicks:00000000 TU2_GetOffsetTicks
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccazdgAa.s:529    .text.TU2_GetOffsetTicks:00000058 $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccazdgAa.s:536    .text.TU2_SelectOutputAction:00000000 $t
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccazdgAa.s:541    .text.TU2_SelectOutputAction:00000000 TU2_SelectOutputAction
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccazdgAa.s:894    .text.TU2_SelectOutputAction:0000023c $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccazdgAa.s:901    .text.TU2_Interrupt:00000000 $t
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccazdgAa.s:906    .text.TU2_Interrupt:00000000 TU2_Interrupt
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccazdgAa.s:975    .text.TU2_Interrupt:00000058 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
PE_LDD_DeviceDataList
TU2_OnCounterRestart

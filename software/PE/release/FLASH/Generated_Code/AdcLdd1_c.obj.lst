   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"AdcLdd1.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.rodata.ChannelToPin,"a",%progbits
  18              		.align	2
  21              	ChannelToPin:
  22 0000 09       		.byte	9
  23 0001 0C       		.byte	12
  24 0002 0D       		.byte	13
  25 0003 07       		.byte	7
  26              		.section	.bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC,"aw",%nobits
  27              		.align	2
  30              	DeviceDataPrv__DEFAULT_RTOS_ALLOC:
  31 0000 00000000 		.space	8
  31      00000000 
  32              		.section	.text.AdcLdd1_Init,"ax",%progbits
  33              		.align	2
  34              		.global	AdcLdd1_Init
  35              		.code	16
  36              		.thumb_func
  38              	AdcLdd1_Init:
  39              	.LFB0:
  40              		.file 1 "../Generated_Code/AdcLdd1.c"
   1:../Generated_Code/AdcLdd1.c **** /** ###################################################################
   2:../Generated_Code/AdcLdd1.c **** **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
   3:../Generated_Code/AdcLdd1.c **** **     Filename    : AdcLdd1.c
   4:../Generated_Code/AdcLdd1.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/AdcLdd1.c **** **     Processor   : MKL25Z128VLK4
   6:../Generated_Code/AdcLdd1.c **** **     Component   : ADC_LDD
   7:../Generated_Code/AdcLdd1.c **** **     Version     : Component 01.115, Driver 01.07, CPU db: 3.00.000
   8:../Generated_Code/AdcLdd1.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/AdcLdd1.c **** **     Date/Time   : 2013-05-15, 17:26, # CodeGen: 51
  10:../Generated_Code/AdcLdd1.c **** **     Abstract    :
  11:../Generated_Code/AdcLdd1.c **** **         This device "ADC_LDD" implements an A/D converter,
  12:../Generated_Code/AdcLdd1.c **** **         its control methods and interrupt/event handling procedure.
  13:../Generated_Code/AdcLdd1.c **** **     Settings    :
  14:../Generated_Code/AdcLdd1.c **** **          Component name                                 : AdcLdd1
  15:../Generated_Code/AdcLdd1.c **** **          A/D converter                                  : ADC0
  16:../Generated_Code/AdcLdd1.c **** **          Discontinuous mode                             : no
  17:../Generated_Code/AdcLdd1.c **** **          Converter mode                                 : Sequential
  18:../Generated_Code/AdcLdd1.c **** **          Interrupt service/event                        : Disabled
  19:../Generated_Code/AdcLdd1.c **** **          A/D channel list                               : 4
  20:../Generated_Code/AdcLdd1.c **** **            Channel 0                                    : 
  21:../Generated_Code/AdcLdd1.c **** **              Channel mode                               : Single Ended
  22:../Generated_Code/AdcLdd1.c **** **                Input                                    : 
  23:../Generated_Code/AdcLdd1.c **** **                  A/D channel (pin)                      : ADC0_SE9/TSI0_CH6/PTB1/I2C0_SDA/TPM1_C
  24:../Generated_Code/AdcLdd1.c **** **                  A/D channel (pin) signal               : 
  25:../Generated_Code/AdcLdd1.c **** **            Channel 1                                    : 
  26:../Generated_Code/AdcLdd1.c **** **              Channel mode                               : Single Ended
  27:../Generated_Code/AdcLdd1.c **** **                Input                                    : 
  28:../Generated_Code/AdcLdd1.c **** **                  A/D channel (pin)                      : ADC0_SE12/TSI0_CH7/PTB2/I2C0_SCL/TPM2_
  29:../Generated_Code/AdcLdd1.c **** **                  A/D channel (pin) signal               : 
  30:../Generated_Code/AdcLdd1.c **** **            Channel 2                                    : 
  31:../Generated_Code/AdcLdd1.c **** **              Channel mode                               : Single Ended
  32:../Generated_Code/AdcLdd1.c **** **                Input                                    : 
  33:../Generated_Code/AdcLdd1.c **** **                  A/D channel (pin)                      : ADC0_SE13/TSI0_CH8/PTB3/I2C0_SDA/TPM2_
  34:../Generated_Code/AdcLdd1.c **** **                  A/D channel (pin) signal               : 
  35:../Generated_Code/AdcLdd1.c **** **            Channel 3                                    : 
  36:../Generated_Code/AdcLdd1.c **** **              Channel mode                               : Single Ended
  37:../Generated_Code/AdcLdd1.c **** **                Input                                    : 
  38:../Generated_Code/AdcLdd1.c **** **                  A/D channel (pin)                      : ADC0_SE7b/PTD6/LLWU_P15/SPI1_MOSI/UART
  39:../Generated_Code/AdcLdd1.c **** **                  A/D channel (pin) signal               : 
  40:../Generated_Code/AdcLdd1.c **** **          Static sample groups                           : Disabled
  41:../Generated_Code/AdcLdd1.c **** **          A/D resolution                                 : Autoselect
  42:../Generated_Code/AdcLdd1.c **** **          Low-power mode                                 : Disabled
  43:../Generated_Code/AdcLdd1.c **** **          High-speed conversion mode                     : Enabled
  44:../Generated_Code/AdcLdd1.c **** **          Asynchro clock output                          : Disabled
  45:../Generated_Code/AdcLdd1.c **** **          Sample time                                    : 4 clock periods
  46:../Generated_Code/AdcLdd1.c **** **          Number of conversions                          : 1
  47:../Generated_Code/AdcLdd1.c **** **          Conversion time                                : 1.125 ?s
  48:../Generated_Code/AdcLdd1.c **** **          ADC clock                                      : 23.999 MHz (41.667 ns)
  49:../Generated_Code/AdcLdd1.c **** **          Single conversion time - Single-ended          : 1.541 us
  50:../Generated_Code/AdcLdd1.c **** **          Single conversion time - Differential          : 1.916 us
  51:../Generated_Code/AdcLdd1.c **** **          Additional conversion time - Single-ended      : 1.125 us
  52:../Generated_Code/AdcLdd1.c **** **          Additional conversion time - Differential      : 1.5 us
  53:../Generated_Code/AdcLdd1.c **** **          Result type                                    : unsigned 16 bits, right justified
  54:../Generated_Code/AdcLdd1.c **** **          Trigger                                        : Disabled
  55:../Generated_Code/AdcLdd1.c **** **          Voltage reference                              : 
  56:../Generated_Code/AdcLdd1.c **** **            High voltage reference                       : 
  57:../Generated_Code/AdcLdd1.c **** **              Volt. ref. pin                             : VREFH
  58:../Generated_Code/AdcLdd1.c **** **              Volt. ref pin signal                       : 
  59:../Generated_Code/AdcLdd1.c **** **            Low voltage reference                        : 
  60:../Generated_Code/AdcLdd1.c **** **              Volt. ref. pin                             : VREFL
  61:../Generated_Code/AdcLdd1.c **** **              Volt. ref pin signal                       : 
  62:../Generated_Code/AdcLdd1.c **** **          Initialization                                 : 
  63:../Generated_Code/AdcLdd1.c **** **            Enabled in init. code                        : yes
  64:../Generated_Code/AdcLdd1.c **** **            Auto initialization                          : no
  65:../Generated_Code/AdcLdd1.c **** **            Event mask                                   : 
  66:../Generated_Code/AdcLdd1.c **** **              OnMeasurementComplete                      : Disabled
  67:../Generated_Code/AdcLdd1.c **** **          CPU clock/configuration selection              : 
  68:../Generated_Code/AdcLdd1.c **** **            Clock configuration 0                        : This component enabled
  69:../Generated_Code/AdcLdd1.c **** **            Clock configuration 1                        : This component disabled
  70:../Generated_Code/AdcLdd1.c **** **            Clock configuration 2                        : This component disabled
  71:../Generated_Code/AdcLdd1.c **** **            Clock configuration 3                        : This component enabled
  72:../Generated_Code/AdcLdd1.c **** **            Clock configuration 4                        : This component enabled
  73:../Generated_Code/AdcLdd1.c **** **            Clock configuration 5                        : This component enabled
  74:../Generated_Code/AdcLdd1.c **** **            Clock configuration 6                        : This component enabled
  75:../Generated_Code/AdcLdd1.c **** **            Clock configuration 7                        : This component enabled
  76:../Generated_Code/AdcLdd1.c **** **     Contents    :
  77:../Generated_Code/AdcLdd1.c **** **         Init                         - LDD_TDeviceData* AdcLdd1_Init(LDD_TUserData *UserDataPtr)
  78:../Generated_Code/AdcLdd1.c **** **         StartSingleMeasurement       - LDD_TError AdcLdd1_StartSingleMeasurement(LDD_TDeviceData
  79:../Generated_Code/AdcLdd1.c **** **         CreateSampleGroup            - LDD_TError AdcLdd1_CreateSampleGroup(LDD_TDeviceData *Dev
  80:../Generated_Code/AdcLdd1.c **** **         GetMeasuredValues            - LDD_TError AdcLdd1_GetMeasuredValues(LDD_TDeviceData *Dev
  81:../Generated_Code/AdcLdd1.c **** **         GetMeasurementCompleteStatus - bool AdcLdd1_GetMeasurementCompleteStatus(LDD_TDeviceData
  82:../Generated_Code/AdcLdd1.c **** **         StartCalibration             - LDD_TError AdcLdd1_StartCalibration(LDD_TDeviceData *Devi
  83:../Generated_Code/AdcLdd1.c **** **         GetCalibrationResultStatus   - LDD_TError AdcLdd1_GetCalibrationResultStatus(LDD_TDevice
  84:../Generated_Code/AdcLdd1.c **** **
  85:../Generated_Code/AdcLdd1.c **** **     Copyright : 1997 - 2012 Freescale, Inc. All Rights Reserved.
  86:../Generated_Code/AdcLdd1.c **** **     
  87:../Generated_Code/AdcLdd1.c **** **     http      : www.freescale.com
  88:../Generated_Code/AdcLdd1.c **** **     mail      : support@freescale.com
  89:../Generated_Code/AdcLdd1.c **** ** ###################################################################*/
  90:../Generated_Code/AdcLdd1.c **** 
  91:../Generated_Code/AdcLdd1.c **** /* MODULE AdcLdd1. */
  92:../Generated_Code/AdcLdd1.c **** 
  93:../Generated_Code/AdcLdd1.c **** #include "AdcLdd1.h"
  94:../Generated_Code/AdcLdd1.c **** /* {Default RTOS Adapter} No RTOS includes */
  95:../Generated_Code/AdcLdd1.c **** 
  96:../Generated_Code/AdcLdd1.c **** #define AdcLdd1_AVAILABLE_CHANNEL0_31_PIN_MASK (LDD_ADC_CHANNEL_0_PIN | LDD_ADC_CHANNEL_1_PIN | LDD
  97:../Generated_Code/AdcLdd1.c **** #define AdcLdd1_AVAILABLE_CHANNEL32_63_PIN_MASK 0x00U /* Mask of all allocated channel pins from 32
  98:../Generated_Code/AdcLdd1.c **** #define AdcLdd1_AVAILABLE_TRIGGER_PIN_MASK 0x00U /* Mask of all allocated trigger pins */
  99:../Generated_Code/AdcLdd1.c **** #define AdcLdd1_AVAILABLE_VOLT_REF_PIN_MASK (LDD_ADC_LOW_VOLT_REF_PIN | LDD_ADC_HIGH_VOLT_REF_PIN) 
 100:../Generated_Code/AdcLdd1.c **** 
 101:../Generated_Code/AdcLdd1.c **** static const uint8_t ChannelToPin[] = { /* Channel to pin conversion table */
 102:../Generated_Code/AdcLdd1.c ****   /* ADC0_SC1A: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 103:../Generated_Code/AdcLdd1.c ****   0x09U,                               /* Status and control register value */
 104:../Generated_Code/AdcLdd1.c ****   /* ADC0_SC1A: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 105:../Generated_Code/AdcLdd1.c ****   0x0CU,                               /* Status and control register value */
 106:../Generated_Code/AdcLdd1.c ****   /* ADC0_SC1A: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 107:../Generated_Code/AdcLdd1.c ****   0x0DU,                               /* Status and control register value */
 108:../Generated_Code/AdcLdd1.c ****   /* ADC0_SC1A: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 109:../Generated_Code/AdcLdd1.c ****   0x07U                                /* Status and control register value */
 110:../Generated_Code/AdcLdd1.c **** };
 111:../Generated_Code/AdcLdd1.c **** 
 112:../Generated_Code/AdcLdd1.c **** typedef struct {
 113:../Generated_Code/AdcLdd1.c ****   uint8_t SampleCount;                 /* Number of samples in the last selected/created sample gro
 114:../Generated_Code/AdcLdd1.c ****   uint8_t FirstSample;                 /* First sample of group store */
 115:../Generated_Code/AdcLdd1.c ****   LDD_TUserData *UserData;             /* RTOS device data structure */
 116:../Generated_Code/AdcLdd1.c **** } AdcLdd1_TDeviceData;                 /* Device data structure type */
 117:../Generated_Code/AdcLdd1.c **** 
 118:../Generated_Code/AdcLdd1.c **** typedef AdcLdd1_TDeviceData* AdcLdd1_TDeviceDataPtr ; /* Pointer to the device data structure. */
 119:../Generated_Code/AdcLdd1.c **** 
 120:../Generated_Code/AdcLdd1.c **** /* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
 121:../Generated_Code/AdcLdd1.c **** static AdcLdd1_TDeviceData DeviceDataPrv__DEFAULT_RTOS_ALLOC;
 122:../Generated_Code/AdcLdd1.c **** /*
 123:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 124:../Generated_Code/AdcLdd1.c **** **     Method      :  AdcLdd1_Init (component ADC_LDD)
 125:../Generated_Code/AdcLdd1.c **** **
 126:../Generated_Code/AdcLdd1.c **** **     Description :
 127:../Generated_Code/AdcLdd1.c **** **         Initializes the device. Allocates memory for the device data
 128:../Generated_Code/AdcLdd1.c **** **         structure, allocates interrupt vectors and sets interrupt
 129:../Generated_Code/AdcLdd1.c **** **         priority, sets pin routing, sets timing, etc.
 130:../Generated_Code/AdcLdd1.c **** **         If the "Enable in init. code" is set to "yes" value then the
 131:../Generated_Code/AdcLdd1.c **** **         device is also enabled(see the description of the Enable()
 132:../Generated_Code/AdcLdd1.c **** **         method). In this case the Enable() method is not necessary
 133:../Generated_Code/AdcLdd1.c **** **         and needn't to be generated. 
 134:../Generated_Code/AdcLdd1.c **** **         This method can be called only once. Before the second call
 135:../Generated_Code/AdcLdd1.c **** **         of Init() the Deinit() must be called first.
 136:../Generated_Code/AdcLdd1.c **** **     Parameters  :
 137:../Generated_Code/AdcLdd1.c **** **         NAME            - DESCRIPTION
 138:../Generated_Code/AdcLdd1.c **** **       * UserDataPtr     - Pointer to the user or
 139:../Generated_Code/AdcLdd1.c **** **                           RTOS specific data. This pointer will be
 140:../Generated_Code/AdcLdd1.c **** **                           passed as an event or callback parameter.
 141:../Generated_Code/AdcLdd1.c **** **     Returns     :
 142:../Generated_Code/AdcLdd1.c **** **         ---             - Device data structure pointer.
 143:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 144:../Generated_Code/AdcLdd1.c **** */
 145:../Generated_Code/AdcLdd1.c **** LDD_TDeviceData* AdcLdd1_Init(LDD_TUserData *UserDataPtr)
 146:../Generated_Code/AdcLdd1.c **** {
  41              		.loc 1 146 0
  42              		.cfi_startproc
  43 0000 80B5     		push	{r7, lr}
  44              	.LCFI0:
  45              		.cfi_def_cfa_offset 8
  46              		.cfi_offset 7, -8
  47              		.cfi_offset 14, -4
  48 0002 84B0     		sub	sp, sp, #16
  49              	.LCFI1:
  50              		.cfi_def_cfa_offset 24
  51 0004 00AF     		add	r7, sp, #0
  52              	.LCFI2:
  53              		.cfi_def_cfa_register 7
  54 0006 7860     		str	r0, [r7, #4]
 147:../Generated_Code/AdcLdd1.c ****   /* Allocate LDD device structure */
 148:../Generated_Code/AdcLdd1.c ****   AdcLdd1_TDeviceDataPtr DeviceDataPrv;
 149:../Generated_Code/AdcLdd1.c **** 
 150:../Generated_Code/AdcLdd1.c ****   /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer 
 151:../Generated_Code/AdcLdd1.c ****   DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;
  55              		.loc 1 151 0
  56 0008 254B     		ldr	r3, .L2
  57 000a FB60     		str	r3, [r7, #12]
 152:../Generated_Code/AdcLdd1.c ****   DeviceDataPrv->UserData = UserDataPtr; /* Store the RTOS device structure */
  58              		.loc 1 152 0
  59 000c FB68     		ldr	r3, [r7, #12]
  60 000e 7A68     		ldr	r2, [r7, #4]
  61 0010 5A60     		str	r2, [r3, #4]
 153:../Generated_Code/AdcLdd1.c ****   DeviceDataPrv->SampleCount = 0U;     /* Initializing SampleCount for right access of some methods
  62              		.loc 1 153 0
  63 0012 FB68     		ldr	r3, [r7, #12]
  64 0014 0022     		mov	r2, #0
  65 0016 1A70     		strb	r2, [r3]
 154:../Generated_Code/AdcLdd1.c ****   /* SIM_SCGC6: ADC0=1 */
 155:../Generated_Code/AdcLdd1.c ****   SIM_SCGC6 |= SIM_SCGC6_ADC0_MASK;                                                   
  66              		.loc 1 155 0
  67 0018 224A     		ldr	r2, .L2+4
  68 001a 2249     		ldr	r1, .L2+4
  69 001c 224B     		ldr	r3, .L2+8
  70 001e CB58     		ldr	r3, [r1, r3]
  71 0020 8021     		mov	r1, #128
  72 0022 0905     		lsl	r1, r1, #20
  73 0024 1943     		orr	r1, r3
  74 0026 204B     		ldr	r3, .L2+8
  75 0028 D150     		str	r1, [r2, r3]
 156:../Generated_Code/AdcLdd1.c ****   /* PORTB_PCR1: ISF=0,MUX=0 */
 157:../Generated_Code/AdcLdd1.c ****   PORTB_PCR1 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));                   
  76              		.loc 1 157 0
  77 002a 204B     		ldr	r3, .L2+12
  78 002c 1F4A     		ldr	r2, .L2+12
  79 002e 5268     		ldr	r2, [r2, #4]
  80 0030 111C     		mov	r1, r2
  81 0032 1F4A     		ldr	r2, .L2+16
  82 0034 0A40     		and	r2, r1
  83 0036 5A60     		str	r2, [r3, #4]
 158:../Generated_Code/AdcLdd1.c ****   /* PORTB_PCR2: ISF=0,MUX=0 */
 159:../Generated_Code/AdcLdd1.c ****   PORTB_PCR2 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));                   
  84              		.loc 1 159 0
  85 0038 1C4B     		ldr	r3, .L2+12
  86 003a 1C4A     		ldr	r2, .L2+12
  87 003c 9268     		ldr	r2, [r2, #8]
  88 003e 111C     		mov	r1, r2
  89 0040 1B4A     		ldr	r2, .L2+16
  90 0042 0A40     		and	r2, r1
  91 0044 9A60     		str	r2, [r3, #8]
 160:../Generated_Code/AdcLdd1.c ****   /* PORTB_PCR3: ISF=0,MUX=0 */
 161:../Generated_Code/AdcLdd1.c ****   PORTB_PCR3 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));                   
  92              		.loc 1 161 0
  93 0046 194B     		ldr	r3, .L2+12
  94 0048 184A     		ldr	r2, .L2+12
  95 004a D268     		ldr	r2, [r2, #12]
  96 004c 111C     		mov	r1, r2
  97 004e 184A     		ldr	r2, .L2+16
  98 0050 0A40     		and	r2, r1
  99 0052 DA60     		str	r2, [r3, #12]
 162:../Generated_Code/AdcLdd1.c ****   /* PORTD_PCR6: ISF=0,MUX=0 */
 163:../Generated_Code/AdcLdd1.c ****   PORTD_PCR6 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));                   
 100              		.loc 1 163 0
 101 0054 174B     		ldr	r3, .L2+20
 102 0056 174A     		ldr	r2, .L2+20
 103 0058 9269     		ldr	r2, [r2, #24]
 104 005a 111C     		mov	r1, r2
 105 005c 144A     		ldr	r2, .L2+16
 106 005e 0A40     		and	r2, r1
 107 0060 9A61     		str	r2, [r3, #24]
 164:../Generated_Code/AdcLdd1.c ****   /* ADC0_CFG2: MUXSEL=1 */
 165:../Generated_Code/AdcLdd1.c ****   ADC0_CFG2 |= ADC_CFG2_MUXSEL_MASK;                                                   
 108              		.loc 1 165 0
 109 0062 154B     		ldr	r3, .L2+24
 110 0064 144A     		ldr	r2, .L2+24
 111 0066 D268     		ldr	r2, [r2, #12]
 112 0068 1021     		mov	r1, #16
 113 006a 0A43     		orr	r2, r1
 114 006c DA60     		str	r2, [r3, #12]
 166:../Generated_Code/AdcLdd1.c ****   /* ADC0_CFG1: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 167:../Generated_Code/AdcLdd1.c ****   ADC0_CFG1 = ADC_CFG1_MODE(0x03);                                                   
 115              		.loc 1 167 0
 116 006e 124B     		ldr	r3, .L2+24
 117 0070 0C22     		mov	r2, #12
 118 0072 9A60     		str	r2, [r3, #8]
 168:../Generated_Code/AdcLdd1.c ****   /* ADC0_CFG2: ADACKEN=0,ADHSC=1,ADLSTS=0 */
 169:../Generated_Code/AdcLdd1.c ****   ADC0_CFG2 = (uint32_t)((ADC0_CFG2 & (uint32_t)~(uint32_t)(
 119              		.loc 1 169 0
 120 0074 104B     		ldr	r3, .L2+24
 121 0076 104A     		ldr	r2, .L2+24
 122 0078 D268     		ldr	r2, [r2, #12]
 123 007a 0F21     		mov	r1, #15
 124 007c 8A43     		bic	r2, r1
 125 007e 0421     		mov	r1, #4
 126 0080 0A43     		orr	r2, r1
 127 0082 DA60     		str	r2, [r3, #12]
 170:../Generated_Code/AdcLdd1.c ****                ADC_CFG2_ADACKEN_MASK |
 171:../Generated_Code/AdcLdd1.c ****                ADC_CFG2_ADLSTS(0x03)
 172:../Generated_Code/AdcLdd1.c ****               )) | (uint32_t)(
 173:../Generated_Code/AdcLdd1.c ****                ADC_CFG2_ADHSC_MASK
 174:../Generated_Code/AdcLdd1.c ****               ));                                                  
 175:../Generated_Code/AdcLdd1.c ****   /* ADC0_SC2: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0
 176:../Generated_Code/AdcLdd1.c ****   ADC0_SC2 = 0x00U;                                                   
 128              		.loc 1 176 0
 129 0084 0C4B     		ldr	r3, .L2+24
 130 0086 0022     		mov	r2, #0
 131 0088 1A62     		str	r2, [r3, #32]
 177:../Generated_Code/AdcLdd1.c ****   /* ADC0_SC3: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0
 178:../Generated_Code/AdcLdd1.c ****   ADC0_SC3 = ADC_SC3_CALF_MASK;                                                   
 132              		.loc 1 178 0
 133 008a 0B4B     		ldr	r3, .L2+24
 134 008c 4022     		mov	r2, #64
 135 008e 5A62     		str	r2, [r3, #36]
 179:../Generated_Code/AdcLdd1.c ****   /* Registration of the device structure */
 180:../Generated_Code/AdcLdd1.c ****   PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_AdcLdd1_ID,DeviceDataPrv);
 136              		.loc 1 180 0
 137 0090 0A4B     		ldr	r3, .L2+28
 138 0092 FA68     		ldr	r2, [r7, #12]
 139 0094 DA61     		str	r2, [r3, #28]
 181:../Generated_Code/AdcLdd1.c ****   return ((LDD_TDeviceData *)DeviceDataPrv); /* Return pointer to the data data structure */
 140              		.loc 1 181 0
 141 0096 FB68     		ldr	r3, [r7, #12]
 182:../Generated_Code/AdcLdd1.c **** }
 142              		.loc 1 182 0
 143 0098 181C     		mov	r0, r3
 144 009a BD46     		mov	sp, r7
 145 009c 04B0     		add	sp, sp, #16
 146              		@ sp needed for prologue
 147 009e 80BD     		pop	{r7, pc}
 148              	.L3:
 149              		.align	2
 150              	.L2:
 151 00a0 00000000 		.word	DeviceDataPrv__DEFAULT_RTOS_ALLOC
 152 00a4 00700440 		.word	1074032640
 153 00a8 3C100000 		.word	4156
 154 00ac 00A00440 		.word	1074044928
 155 00b0 FFF8FFFE 		.word	-16779009
 156 00b4 00C00440 		.word	1074053120
 157 00b8 00B00340 		.word	1073983488
 158 00bc 00000000 		.word	PE_LDD_DeviceDataList
 159              		.cfi_endproc
 160              	.LFE0:
 162              		.section	.text.AdcLdd1_StartSingleMeasurement,"ax",%progbits
 163              		.align	2
 164              		.global	AdcLdd1_StartSingleMeasurement
 165              		.code	16
 166              		.thumb_func
 168              	AdcLdd1_StartSingleMeasurement:
 169              	.LFB1:
 183:../Generated_Code/AdcLdd1.c **** 
 184:../Generated_Code/AdcLdd1.c **** /*
 185:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 186:../Generated_Code/AdcLdd1.c **** **     Method      :  AdcLdd1_StartSingleMeasurement (component ADC_LDD)
 187:../Generated_Code/AdcLdd1.c **** **
 188:../Generated_Code/AdcLdd1.c **** **     Description :
 189:../Generated_Code/AdcLdd1.c **** **         This method starts one measurement of the selected group of
 190:../Generated_Code/AdcLdd1.c **** **         samples and exits immediately. The group of samples for
 191:../Generated_Code/AdcLdd1.c **** **         measurement is specified by preceding call to
 192:../Generated_Code/AdcLdd1.c **** **         <SelectSampleGroup()> or <SelectSampleGroup()> method. The
 193:../Generated_Code/AdcLdd1.c **** **         <OnMeasurementComplete() > event is invoked after the
 194:../Generated_Code/AdcLdd1.c **** **         measurement is done and the event is enabled. The state of
 195:../Generated_Code/AdcLdd1.c **** **         the measurement can be also polled by the
 196:../Generated_Code/AdcLdd1.c **** **         <GetMeasurementCompleteStatus()> method. Results of the
 197:../Generated_Code/AdcLdd1.c **** **         measurement can be read by the <GetMeasuredValues()> method.
 198:../Generated_Code/AdcLdd1.c **** **         The <Discontinuous mode> doesn't support this method.
 199:../Generated_Code/AdcLdd1.c **** **     Parameters  :
 200:../Generated_Code/AdcLdd1.c **** **         NAME            - DESCRIPTION
 201:../Generated_Code/AdcLdd1.c **** **       * DeviceDataPtr   - Device data structure
 202:../Generated_Code/AdcLdd1.c **** **                           pointer returned by <Init> method.
 203:../Generated_Code/AdcLdd1.c **** **     Returns     :
 204:../Generated_Code/AdcLdd1.c **** **         ---             - Error code, possible codes:
 205:../Generated_Code/AdcLdd1.c **** **                           ERR_OK - OK
 206:../Generated_Code/AdcLdd1.c **** **                           ERR_SPEED - The device doesn't work in the
 207:../Generated_Code/AdcLdd1.c **** **                           active clock configuration
 208:../Generated_Code/AdcLdd1.c **** **                           ERR_DISABLED - Component is disabled
 209:../Generated_Code/AdcLdd1.c **** **                           ERR_BUSY - A measurement is in progress 
 210:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 211:../Generated_Code/AdcLdd1.c **** */
 212:../Generated_Code/AdcLdd1.c **** LDD_TError AdcLdd1_StartSingleMeasurement(LDD_TDeviceData *DeviceDataPtr)
 213:../Generated_Code/AdcLdd1.c **** {
 170              		.loc 1 213 0
 171              		.cfi_startproc
 172 0000 80B5     		push	{r7, lr}
 173              	.LCFI3:
 174              		.cfi_def_cfa_offset 8
 175              		.cfi_offset 7, -8
 176              		.cfi_offset 14, -4
 177 0002 82B0     		sub	sp, sp, #8
 178              	.LCFI4:
 179              		.cfi_def_cfa_offset 16
 180 0004 00AF     		add	r7, sp, #0
 181              	.LCFI5:
 182              		.cfi_def_cfa_register 7
 183 0006 7860     		str	r0, [r7, #4]
 214:../Generated_Code/AdcLdd1.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 215:../Generated_Code/AdcLdd1.c ****   if ((ADC_PDD_GetConversionActiveFlag(ADC0_BASE_PTR) != 0U)) { /* Last measurement still pending? 
 184              		.loc 1 215 0
 185 0008 0E4B     		ldr	r3, .L7
 186 000a 1B6A     		ldr	r3, [r3, #32]
 187 000c 1A1C     		mov	r2, r3
 188 000e 8023     		mov	r3, #128
 189 0010 1340     		and	r3, r2
 190 0012 01D0     		beq	.L5
 216:../Generated_Code/AdcLdd1.c ****     return ERR_BUSY;                   /* Yes, return ERR_BUSY */
 191              		.loc 1 216 0
 192 0014 0823     		mov	r3, #8
 193 0016 10E0     		b	.L6
 194              	.L5:
 217:../Generated_Code/AdcLdd1.c ****   }
 218:../Generated_Code/AdcLdd1.c ****   ADC_PDD_SetContinuousMode(ADC0_BASE_PTR, ADC_PDD_ONE_CONVERSION); /* Set one conversion mode */
 195              		.loc 1 218 0
 196 0018 0A4B     		ldr	r3, .L7
 197 001a 0A4A     		ldr	r2, .L7
 198 001c 526A     		ldr	r2, [r2, #36]
 199 001e 0821     		mov	r1, #8
 200 0020 8A43     		bic	r2, r1
 201 0022 5A62     		str	r2, [r3, #36]
 219:../Generated_Code/AdcLdd1.c ****   ADC_PDD_SetConversionTriggerType(ADC0_BASE_PTR, ADC_PDD_SW_TRIGGER); /* Select SW triggering */
 202              		.loc 1 219 0
 203 0024 074B     		ldr	r3, .L7
 204 0026 074A     		ldr	r2, .L7
 205 0028 126A     		ldr	r2, [r2, #32]
 206 002a 4021     		mov	r1, #64
 207 002c 8A43     		bic	r2, r1
 208 002e 1A62     		str	r2, [r3, #32]
 220:../Generated_Code/AdcLdd1.c ****   ADC_PDD_WriteStatusControl1Reg(ADC0_BASE_PTR, 0U, ((AdcLdd1_TDeviceDataPtr)DeviceDataPtr)->FirstS
 209              		.loc 1 220 0
 210 0030 044B     		ldr	r3, .L7
 211 0032 7A68     		ldr	r2, [r7, #4]
 212 0034 5278     		ldrb	r2, [r2, #1]
 213 0036 1A60     		str	r2, [r3]
 221:../Generated_Code/AdcLdd1.c ****   return ERR_OK;                       /* OK */
 214              		.loc 1 221 0
 215 0038 0023     		mov	r3, #0
 216              	.L6:
 222:../Generated_Code/AdcLdd1.c **** }
 217              		.loc 1 222 0
 218 003a 181C     		mov	r0, r3
 219 003c BD46     		mov	sp, r7
 220 003e 02B0     		add	sp, sp, #8
 221              		@ sp needed for prologue
 222 0040 80BD     		pop	{r7, pc}
 223              	.L8:
 224 0042 C046     		.align	2
 225              	.L7:
 226 0044 00B00340 		.word	1073983488
 227              		.cfi_endproc
 228              	.LFE1:
 230              		.section	.text.AdcLdd1_CreateSampleGroup,"ax",%progbits
 231              		.align	2
 232              		.global	AdcLdd1_CreateSampleGroup
 233              		.code	16
 234              		.thumb_func
 236              	AdcLdd1_CreateSampleGroup:
 237              	.LFB2:
 223:../Generated_Code/AdcLdd1.c **** 
 224:../Generated_Code/AdcLdd1.c **** /*
 225:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 226:../Generated_Code/AdcLdd1.c **** **     Method      :  AdcLdd1_CreateSampleGroup (component ADC_LDD)
 227:../Generated_Code/AdcLdd1.c **** **
 228:../Generated_Code/AdcLdd1.c **** **     Description :
 229:../Generated_Code/AdcLdd1.c **** **         This method prepares HW for next measurement according to
 230:../Generated_Code/AdcLdd1.c **** **         array of samples defined during run-time. The array of
 231:../Generated_Code/AdcLdd1.c **** **         samples should be prepared prior to calling this method.
 232:../Generated_Code/AdcLdd1.c **** **         Pointer to the array is passed into this method in parameter
 233:../Generated_Code/AdcLdd1.c **** **         SampleGroupPtr. The number of samples is defined by
 234:../Generated_Code/AdcLdd1.c **** **         parameter SampleCount. Once any group is prepared, the
 235:../Generated_Code/AdcLdd1.c **** **         measurement can be started multiple times. Note: This method
 236:../Generated_Code/AdcLdd1.c **** **         works only with the sample groups defined during run-time.
 237:../Generated_Code/AdcLdd1.c **** **         For design-time defined groups use <SelectSampleGroup()>
 238:../Generated_Code/AdcLdd1.c **** **         method.
 239:../Generated_Code/AdcLdd1.c **** **     Parameters  :
 240:../Generated_Code/AdcLdd1.c **** **         NAME            - DESCRIPTION
 241:../Generated_Code/AdcLdd1.c **** **       * DeviceDataPtr   - Device data structure
 242:../Generated_Code/AdcLdd1.c **** **                           pointer returned by <Init> method.
 243:../Generated_Code/AdcLdd1.c **** **       * SampleGroupPtr  - Pointer to the
 244:../Generated_Code/AdcLdd1.c **** **                           sample definition array. This array can be
 245:../Generated_Code/AdcLdd1.c **** **                           released as soon as the method ends.
 246:../Generated_Code/AdcLdd1.c **** **         SampleCount     - Number of items in the
 247:../Generated_Code/AdcLdd1.c **** **                           sample definition array. Must be less than
 248:../Generated_Code/AdcLdd1.c **** **                           or equal to
 249:../Generated_Code/AdcLdd1.c **** **                           ComponentName_MAX_HW_SAMPLE_COUNT.
 250:../Generated_Code/AdcLdd1.c **** **     Returns     :
 251:../Generated_Code/AdcLdd1.c **** **         ---             - Error code, possible codes:
 252:../Generated_Code/AdcLdd1.c **** **                           ERR_OK - OK
 253:../Generated_Code/AdcLdd1.c **** **                           ERR_SPEED - The device doesn't work in the
 254:../Generated_Code/AdcLdd1.c **** **                           active clock configuration
 255:../Generated_Code/AdcLdd1.c **** **                           ERR_DISABLED - Component is disabled
 256:../Generated_Code/AdcLdd1.c **** **                           ERR_PARAM_INDEX - Channel index in
 257:../Generated_Code/AdcLdd1.c **** **                           SampleGroup structure is out of range
 258:../Generated_Code/AdcLdd1.c **** **                           ERR_PARAM_SAMPLE_COUNT - SampleCount
 259:../Generated_Code/AdcLdd1.c **** **                           variable value is out of range
 260:../Generated_Code/AdcLdd1.c **** **                           ERR_BUSY - Measurement is in progress 
 261:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 262:../Generated_Code/AdcLdd1.c **** */
 263:../Generated_Code/AdcLdd1.c **** LDD_TError AdcLdd1_CreateSampleGroup(LDD_TDeviceData *DeviceDataPtr, LDD_ADC_TSample *SampleGroupPt
 264:../Generated_Code/AdcLdd1.c **** {
 238              		.loc 1 264 0
 239              		.cfi_startproc
 240 0000 80B5     		push	{r7, lr}
 241              	.LCFI6:
 242              		.cfi_def_cfa_offset 8
 243              		.cfi_offset 7, -8
 244              		.cfi_offset 14, -4
 245 0002 86B0     		sub	sp, sp, #24
 246              	.LCFI7:
 247              		.cfi_def_cfa_offset 32
 248 0004 00AF     		add	r7, sp, #0
 249              	.LCFI8:
 250              		.cfi_def_cfa_register 7
 251 0006 F860     		str	r0, [r7, #12]
 252 0008 B960     		str	r1, [r7, #8]
 253 000a FB1D     		add	r3, r7, #7
 254 000c 1A70     		strb	r2, [r3]
 265:../Generated_Code/AdcLdd1.c ****   AdcLdd1_TDeviceDataPtr DeviceDataPrv = (AdcLdd1_TDeviceDataPtr)DeviceDataPtr;
 255              		.loc 1 265 0
 256 000e FB68     		ldr	r3, [r7, #12]
 257 0010 7B61     		str	r3, [r7, #20]
 266:../Generated_Code/AdcLdd1.c **** 
 267:../Generated_Code/AdcLdd1.c ****   /* Sample count test - this test can be disabled by setting the "Ignore range checking"
 268:../Generated_Code/AdcLdd1.c ****      property to the "yes" value in the "Configuration inspector" */
 269:../Generated_Code/AdcLdd1.c ****   if ((SampleCount > AdcLdd1_MAX_HW_SAMPLE_COUNT) || (SampleCount == 0U)) { /* Is number of sample 
 258              		.loc 1 269 0
 259 0012 FB1D     		add	r3, r7, #7
 260 0014 1B78     		ldrb	r3, [r3]
 261 0016 012B     		cmp	r3, #1
 262 0018 03D8     		bhi	.L10
 263              		.loc 1 269 0 is_stmt 0 discriminator 1
 264 001a FB1D     		add	r3, r7, #7
 265 001c 1B78     		ldrb	r3, [r3]
 266 001e 002B     		cmp	r3, #0
 267 0020 01D1     		bne	.L11
 268              	.L10:
 270:../Generated_Code/AdcLdd1.c ****     return ERR_PARAM_SAMPLE_COUNT;     /* Yes, return ERR_PARAM_SAMPLE_COUNT */
 269              		.loc 1 270 0 is_stmt 1
 270 0022 9623     		mov	r3, #150
 271 0024 18E0     		b	.L12
 272              	.L11:
 271:../Generated_Code/AdcLdd1.c ****   }
 272:../Generated_Code/AdcLdd1.c ****   if ((ADC_PDD_GetConversionActiveFlag(ADC0_BASE_PTR) != 0U)) { /* Last measurement still pending? 
 273              		.loc 1 272 0
 274 0026 0E4B     		ldr	r3, .L15
 275 0028 1B6A     		ldr	r3, [r3, #32]
 276 002a 1A1C     		mov	r2, r3
 277 002c 8023     		mov	r3, #128
 278 002e 1340     		and	r3, r2
 279 0030 01D0     		beq	.L13
 273:../Generated_Code/AdcLdd1.c ****     return ERR_BUSY;                   /* Yes, return ERR_BUSY */
 280              		.loc 1 273 0
 281 0032 0823     		mov	r3, #8
 282 0034 10E0     		b	.L12
 283              	.L13:
 274:../Generated_Code/AdcLdd1.c ****   }
 275:../Generated_Code/AdcLdd1.c ****   DeviceDataPrv->SampleCount = SampleCount; /* Remember sample count */
 284              		.loc 1 275 0
 285 0036 7B69     		ldr	r3, [r7, #20]
 286 0038 FA1D     		add	r2, r7, #7
 287 003a 1278     		ldrb	r2, [r2]
 288 003c 1A70     		strb	r2, [r3]
 276:../Generated_Code/AdcLdd1.c ****   /* Channel index test - this test can be disabled by setting the "Ignore range checking"
 277:../Generated_Code/AdcLdd1.c ****      property to the "yes" value in the "Configuration inspector" */
 278:../Generated_Code/AdcLdd1.c ****   if (SampleGroupPtr[0].ChannelIdx >= AdcLdd1_CHANNEL_COUNT) { /* Is channel index out of range? */
 289              		.loc 1 278 0
 290 003e BB68     		ldr	r3, [r7, #8]
 291 0040 1B78     		ldrb	r3, [r3]
 292 0042 032B     		cmp	r3, #3
 293 0044 01D9     		bls	.L14
 279:../Generated_Code/AdcLdd1.c ****     return ERR_PARAM_INDEX;            /* Yes, return ERR_PARAM_INDEX */
 294              		.loc 1 279 0
 295 0046 8223     		mov	r3, #130
 296 0048 06E0     		b	.L12
 297              	.L14:
 280:../Generated_Code/AdcLdd1.c ****   }
 281:../Generated_Code/AdcLdd1.c ****   DeviceDataPrv->FirstSample = ChannelToPin[SampleGroupPtr[0].ChannelIdx]; /* Remember first sample
 298              		.loc 1 281 0
 299 004a BB68     		ldr	r3, [r7, #8]
 300 004c 1B78     		ldrb	r3, [r3]
 301 004e 054A     		ldr	r2, .L15+4
 302 0050 D25C     		ldrb	r2, [r2, r3]
 303 0052 7B69     		ldr	r3, [r7, #20]
 304 0054 5A70     		strb	r2, [r3, #1]
 282:../Generated_Code/AdcLdd1.c ****   return ERR_OK;                       /* OK */
 305              		.loc 1 282 0
 306 0056 0023     		mov	r3, #0
 307              	.L12:
 283:../Generated_Code/AdcLdd1.c **** }
 308              		.loc 1 283 0
 309 0058 181C     		mov	r0, r3
 310 005a BD46     		mov	sp, r7
 311 005c 06B0     		add	sp, sp, #24
 312              		@ sp needed for prologue
 313 005e 80BD     		pop	{r7, pc}
 314              	.L16:
 315              		.align	2
 316              	.L15:
 317 0060 00B00340 		.word	1073983488
 318 0064 00000000 		.word	ChannelToPin
 319              		.cfi_endproc
 320              	.LFE2:
 322              		.section	.text.AdcLdd1_GetMeasuredValues,"ax",%progbits
 323              		.align	2
 324              		.global	AdcLdd1_GetMeasuredValues
 325              		.code	16
 326              		.thumb_func
 328              	AdcLdd1_GetMeasuredValues:
 329              	.LFB3:
 284:../Generated_Code/AdcLdd1.c **** 
 285:../Generated_Code/AdcLdd1.c **** /*
 286:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 287:../Generated_Code/AdcLdd1.c **** **     Method      :  AdcLdd1_GetMeasuredValues (component ADC_LDD)
 288:../Generated_Code/AdcLdd1.c **** **
 289:../Generated_Code/AdcLdd1.c **** **     Description :
 290:../Generated_Code/AdcLdd1.c **** **         This method copies results of the last measurement to the
 291:../Generated_Code/AdcLdd1.c **** **         user supplied buffer. Data size depends on the size of
 292:../Generated_Code/AdcLdd1.c **** **         measured sample group (see <SelectSampleGroup()> or
 293:../Generated_Code/AdcLdd1.c **** **         <CreateSampleGroup()> method). Data representation is
 294:../Generated_Code/AdcLdd1.c **** **         defined by the <Result type> property. Typically this method
 295:../Generated_Code/AdcLdd1.c **** **         is called from <OnMeasurementComplete> event to get results
 296:../Generated_Code/AdcLdd1.c **** **         of the last measurement.
 297:../Generated_Code/AdcLdd1.c **** **     Parameters  :
 298:../Generated_Code/AdcLdd1.c **** **         NAME            - DESCRIPTION
 299:../Generated_Code/AdcLdd1.c **** **       * DeviceDataPtr   - Device data structure
 300:../Generated_Code/AdcLdd1.c **** **                           pointer returned by <Init> method.
 301:../Generated_Code/AdcLdd1.c **** **       * BufferPtr       - Pointer to the start of the
 302:../Generated_Code/AdcLdd1.c **** **                           buffer for new results. Count of stored
 303:../Generated_Code/AdcLdd1.c **** **                           measured values equals to the count of the
 304:../Generated_Code/AdcLdd1.c **** **                           samples in the active sample group. It is
 305:../Generated_Code/AdcLdd1.c **** **                           in the user responsibility to provide
 306:../Generated_Code/AdcLdd1.c **** **                           buffer with appropriate size.
 307:../Generated_Code/AdcLdd1.c **** **     Returns     :
 308:../Generated_Code/AdcLdd1.c **** **         ---             - Error code, possible codes:
 309:../Generated_Code/AdcLdd1.c **** **                           ERR_OK - OK
 310:../Generated_Code/AdcLdd1.c **** **                           ERR_SPEED - The device doesn't work in the
 311:../Generated_Code/AdcLdd1.c **** **                           active clock configuration
 312:../Generated_Code/AdcLdd1.c **** **                           ERR_DISABLED - Component is disabled
 313:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 314:../Generated_Code/AdcLdd1.c **** */
 315:../Generated_Code/AdcLdd1.c **** LDD_TError AdcLdd1_GetMeasuredValues(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr)
 316:../Generated_Code/AdcLdd1.c **** {
 330              		.loc 1 316 0
 331              		.cfi_startproc
 332 0000 80B5     		push	{r7, lr}
 333              	.LCFI9:
 334              		.cfi_def_cfa_offset 8
 335              		.cfi_offset 7, -8
 336              		.cfi_offset 14, -4
 337 0002 84B0     		sub	sp, sp, #16
 338              	.LCFI10:
 339              		.cfi_def_cfa_offset 24
 340 0004 00AF     		add	r7, sp, #0
 341              	.LCFI11:
 342              		.cfi_def_cfa_register 7
 343 0006 7860     		str	r0, [r7, #4]
 344 0008 3960     		str	r1, [r7]
 317:../Generated_Code/AdcLdd1.c ****   uint8_t Sample;
 318:../Generated_Code/AdcLdd1.c ****   AdcLdd1_TResultData *pBuffer = (AdcLdd1_TResultData *)BufferPtr;
 345              		.loc 1 318 0
 346 000a 3B68     		ldr	r3, [r7]
 347 000c BB60     		str	r3, [r7, #8]
 319:../Generated_Code/AdcLdd1.c **** 
 320:../Generated_Code/AdcLdd1.c ****   /* Copy values from result registers defined in the active sample
 321:../Generated_Code/AdcLdd1.c ****      group to the user supplied buffer */
 322:../Generated_Code/AdcLdd1.c ****   for (Sample = 0U; Sample < ((AdcLdd1_TDeviceDataPtr)DeviceDataPtr)->SampleCount; Sample++) {
 348              		.loc 1 322 0
 349 000e 3B1C     		mov	r3, r7
 350 0010 0F33     		add	r3, r3, #15
 351 0012 0022     		mov	r2, #0
 352 0014 1A70     		strb	r2, [r3]
 353 0016 15E0     		b	.L18
 354              	.L19:
 323:../Generated_Code/AdcLdd1.c ****     pBuffer[Sample] = (uint16_t)(ADC_PDD_GetResultValueRaw(ADC0_BASE_PTR, Sample));
 355              		.loc 1 323 0 discriminator 2
 356 0018 3B1C     		mov	r3, r7
 357 001a 0F33     		add	r3, r3, #15
 358 001c 1B78     		ldrb	r3, [r3]
 359 001e 5B00     		lsl	r3, r3, #1
 360 0020 BA68     		ldr	r2, [r7, #8]
 361 0022 D318     		add	r3, r2, r3
 362 0024 0D4A     		ldr	r2, .L20
 363 0026 391C     		mov	r1, r7
 364 0028 0F31     		add	r1, r1, #15
 365 002a 0978     		ldrb	r1, [r1]
 366 002c 0431     		add	r1, r1, #4
 367 002e 8900     		lsl	r1, r1, #2
 368 0030 8A58     		ldr	r2, [r1, r2]
 369 0032 92B2     		uxth	r2, r2
 370 0034 1A80     		strh	r2, [r3]
 322:../Generated_Code/AdcLdd1.c ****   for (Sample = 0U; Sample < ((AdcLdd1_TDeviceDataPtr)DeviceDataPtr)->SampleCount; Sample++) {
 371              		.loc 1 322 0 discriminator 2
 372 0036 3B1C     		mov	r3, r7
 373 0038 0F33     		add	r3, r3, #15
 374 003a 3A1C     		mov	r2, r7
 375 003c 0F32     		add	r2, r2, #15
 376 003e 1278     		ldrb	r2, [r2]
 377 0040 0132     		add	r2, r2, #1
 378 0042 1A70     		strb	r2, [r3]
 379              	.L18:
 322:../Generated_Code/AdcLdd1.c ****   for (Sample = 0U; Sample < ((AdcLdd1_TDeviceDataPtr)DeviceDataPtr)->SampleCount; Sample++) {
 380              		.loc 1 322 0 is_stmt 0 discriminator 1
 381 0044 7B68     		ldr	r3, [r7, #4]
 382 0046 1B78     		ldrb	r3, [r3]
 383 0048 3A1C     		mov	r2, r7
 384 004a 0F32     		add	r2, r2, #15
 385 004c 1278     		ldrb	r2, [r2]
 386 004e 9A42     		cmp	r2, r3
 387 0050 E2D3     		bcc	.L19
 324:../Generated_Code/AdcLdd1.c ****   }
 325:../Generated_Code/AdcLdd1.c ****   return ERR_OK;                       /* OK */
 388              		.loc 1 325 0 is_stmt 1
 389 0052 0023     		mov	r3, #0
 326:../Generated_Code/AdcLdd1.c **** }
 390              		.loc 1 326 0
 391 0054 181C     		mov	r0, r3
 392 0056 BD46     		mov	sp, r7
 393 0058 04B0     		add	sp, sp, #16
 394              		@ sp needed for prologue
 395 005a 80BD     		pop	{r7, pc}
 396              	.L21:
 397              		.align	2
 398              	.L20:
 399 005c 00B00340 		.word	1073983488
 400              		.cfi_endproc
 401              	.LFE3:
 403              		.section	.text.AdcLdd1_GetMeasurementCompleteStatus,"ax",%progbits
 404              		.align	2
 405              		.global	AdcLdd1_GetMeasurementCompleteStatus
 406              		.code	16
 407              		.thumb_func
 409              	AdcLdd1_GetMeasurementCompleteStatus:
 410              	.LFB4:
 327:../Generated_Code/AdcLdd1.c **** 
 328:../Generated_Code/AdcLdd1.c **** /*
 329:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 330:../Generated_Code/AdcLdd1.c **** **     Method      :  AdcLdd1_GetMeasurementCompleteStatus (component ADC_LDD)
 331:../Generated_Code/AdcLdd1.c **** **
 332:../Generated_Code/AdcLdd1.c **** **     Description :
 333:../Generated_Code/AdcLdd1.c **** **         Returns whether the measurement is done and the results can
 334:../Generated_Code/AdcLdd1.c **** **         be read by the user. It can be used to poll the state of
 335:../Generated_Code/AdcLdd1.c **** **         measurement if <Interrupt service/event> is disabled or if
 336:../Generated_Code/AdcLdd1.c **** **         <OnMeasurementComplete> event is disabled by the
 337:../Generated_Code/AdcLdd1.c **** **         <SetEventMask()> methods.
 338:../Generated_Code/AdcLdd1.c **** **     Parameters  :
 339:../Generated_Code/AdcLdd1.c **** **         NAME            - DESCRIPTION
 340:../Generated_Code/AdcLdd1.c **** **       * DeviceDataPtr   - Device data structure
 341:../Generated_Code/AdcLdd1.c **** **                           pointer returned by <Init> method.
 342:../Generated_Code/AdcLdd1.c **** **     Returns     :
 343:../Generated_Code/AdcLdd1.c **** **         ---             - Error code
 344:../Generated_Code/AdcLdd1.c **** **                           true - Measurement is done
 345:../Generated_Code/AdcLdd1.c **** **                           false - Measurement is in progress
 346:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 347:../Generated_Code/AdcLdd1.c **** */
 348:../Generated_Code/AdcLdd1.c **** bool AdcLdd1_GetMeasurementCompleteStatus(LDD_TDeviceData *DeviceDataPtr)
 349:../Generated_Code/AdcLdd1.c **** {
 411              		.loc 1 349 0
 412              		.cfi_startproc
 413 0000 80B5     		push	{r7, lr}
 414              	.LCFI12:
 415              		.cfi_def_cfa_offset 8
 416              		.cfi_offset 7, -8
 417              		.cfi_offset 14, -4
 418 0002 84B0     		sub	sp, sp, #16
 419              	.LCFI13:
 420              		.cfi_def_cfa_offset 24
 421 0004 00AF     		add	r7, sp, #0
 422              	.LCFI14:
 423              		.cfi_def_cfa_register 7
 424 0006 7860     		str	r0, [r7, #4]
 350:../Generated_Code/AdcLdd1.c ****   uint32_t Status;
 351:../Generated_Code/AdcLdd1.c **** 
 352:../Generated_Code/AdcLdd1.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 353:../Generated_Code/AdcLdd1.c ****   Status = ADC_PDD_GetConversionCompleteFlag(ADC0_BASE_PTR, 0U); /* Get conversion complete flag fr
 425              		.loc 1 353 0
 426 0008 084B     		ldr	r3, .L25
 427 000a 1B68     		ldr	r3, [r3]
 428 000c 1A1C     		mov	r2, r3
 429 000e 8023     		mov	r3, #128
 430 0010 1340     		and	r3, r2
 431 0012 FB60     		str	r3, [r7, #12]
 354:../Generated_Code/AdcLdd1.c ****   if (Status) {
 432              		.loc 1 354 0
 433 0014 FB68     		ldr	r3, [r7, #12]
 434 0016 002B     		cmp	r3, #0
 435 0018 03D0     		beq	.L23
 355:../Generated_Code/AdcLdd1.c ****     (void)ADC_PDD_GetResultValueRaw(ADC0_BASE_PTR, 0U); /* Clear conversion complete flag */
 436              		.loc 1 355 0
 437 001a 044B     		ldr	r3, .L25
 438 001c 1B69     		ldr	r3, [r3, #16]
 356:../Generated_Code/AdcLdd1.c ****     return (bool)(TRUE);               /* Return TRUE if measurement has been done */
 439              		.loc 1 356 0
 440 001e 0123     		mov	r3, #1
 441 0020 00E0     		b	.L24
 442              	.L23:
 357:../Generated_Code/AdcLdd1.c ****   }
 358:../Generated_Code/AdcLdd1.c ****   return (bool)(FALSE);                /* Return FALSE if measurement has not been done */
 443              		.loc 1 358 0
 444 0022 0023     		mov	r3, #0
 445              	.L24:
 359:../Generated_Code/AdcLdd1.c **** }
 446              		.loc 1 359 0
 447 0024 181C     		mov	r0, r3
 448 0026 BD46     		mov	sp, r7
 449 0028 04B0     		add	sp, sp, #16
 450              		@ sp needed for prologue
 451 002a 80BD     		pop	{r7, pc}
 452              	.L26:
 453              		.align	2
 454              	.L25:
 455 002c 00B00340 		.word	1073983488
 456              		.cfi_endproc
 457              	.LFE4:
 459              		.section	.text.AdcLdd1_StartCalibration,"ax",%progbits
 460              		.align	2
 461              		.global	AdcLdd1_StartCalibration
 462              		.code	16
 463              		.thumb_func
 465              	AdcLdd1_StartCalibration:
 466              	.LFB5:
 360:../Generated_Code/AdcLdd1.c **** 
 361:../Generated_Code/AdcLdd1.c **** /*
 362:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 363:../Generated_Code/AdcLdd1.c **** **     Method      :  AdcLdd1_StartCalibration (component ADC_LDD)
 364:../Generated_Code/AdcLdd1.c **** **
 365:../Generated_Code/AdcLdd1.c **** **     Description :
 366:../Generated_Code/AdcLdd1.c **** **         This method starts self calibration process. Calibration is
 367:../Generated_Code/AdcLdd1.c **** **         typically used to remove the effects of the gain and offset
 368:../Generated_Code/AdcLdd1.c **** **         from a specific reading.
 369:../Generated_Code/AdcLdd1.c **** **     Parameters  :
 370:../Generated_Code/AdcLdd1.c **** **         NAME            - DESCRIPTION
 371:../Generated_Code/AdcLdd1.c **** **       * DeviceDataPtr   - Device data structure
 372:../Generated_Code/AdcLdd1.c **** **                           pointer returned by <Init> method.
 373:../Generated_Code/AdcLdd1.c **** **     Returns     :
 374:../Generated_Code/AdcLdd1.c **** **         ---             - Error code
 375:../Generated_Code/AdcLdd1.c **** **                           ERR_OK - OK
 376:../Generated_Code/AdcLdd1.c **** **                           ERR_SPEED - The device doesn't work in the
 377:../Generated_Code/AdcLdd1.c **** **                           active clock configuration
 378:../Generated_Code/AdcLdd1.c **** **                           ERR_DISABLED - Component is disabled
 379:../Generated_Code/AdcLdd1.c **** **                           ERR_BUSY - A conversion is already running 
 380:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 381:../Generated_Code/AdcLdd1.c **** */
 382:../Generated_Code/AdcLdd1.c **** LDD_TError AdcLdd1_StartCalibration(LDD_TDeviceData *DeviceDataPtr)
 383:../Generated_Code/AdcLdd1.c **** {
 467              		.loc 1 383 0
 468              		.cfi_startproc
 469 0000 80B5     		push	{r7, lr}
 470              	.LCFI15:
 471              		.cfi_def_cfa_offset 8
 472              		.cfi_offset 7, -8
 473              		.cfi_offset 14, -4
 474 0002 82B0     		sub	sp, sp, #8
 475              	.LCFI16:
 476              		.cfi_def_cfa_offset 16
 477 0004 00AF     		add	r7, sp, #0
 478              	.LCFI17:
 479              		.cfi_def_cfa_register 7
 480 0006 7860     		str	r0, [r7, #4]
 384:../Generated_Code/AdcLdd1.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 385:../Generated_Code/AdcLdd1.c ****   if ((ADC_PDD_GetConversionActiveFlag(ADC0_BASE_PTR) != 0U)) { /* Last measurement still pending? 
 481              		.loc 1 385 0
 482 0008 0D4B     		ldr	r3, .L30
 483 000a 1B6A     		ldr	r3, [r3, #32]
 484 000c 1A1C     		mov	r2, r3
 485 000e 8023     		mov	r3, #128
 486 0010 1340     		and	r3, r2
 487 0012 01D0     		beq	.L28
 386:../Generated_Code/AdcLdd1.c ****     return ERR_BUSY;                   /* Yes, return ERR_BUSY */
 488              		.loc 1 386 0
 489 0014 0823     		mov	r3, #8
 490 0016 0FE0     		b	.L29
 491              	.L28:
 387:../Generated_Code/AdcLdd1.c ****   }
 388:../Generated_Code/AdcLdd1.c ****   ADC_PDD_SetConversionTriggerType(ADC0_BASE_PTR, ADC_PDD_SW_TRIGGER); /* Select SW triggering */
 492              		.loc 1 388 0
 493 0018 094B     		ldr	r3, .L30
 494 001a 094A     		ldr	r2, .L30
 495 001c 126A     		ldr	r2, [r2, #32]
 496 001e 4021     		mov	r1, #64
 497 0020 8A43     		bic	r2, r1
 498 0022 1A62     		str	r2, [r3, #32]
 389:../Generated_Code/AdcLdd1.c ****   ADC_PDD_WriteStatusControl1Reg(ADC0_BASE_PTR, 0U, ADC_PDD_MODULE_DISABLED); /* Set Control 1 regi
 499              		.loc 1 389 0
 500 0024 064B     		ldr	r3, .L30
 501 0026 1F22     		mov	r2, #31
 502 0028 1A60     		str	r2, [r3]
 390:../Generated_Code/AdcLdd1.c ****   ADC_PDD_StartCalibration(ADC0_BASE_PTR); /* Set one conversion mode */
 503              		.loc 1 390 0
 504 002a 054B     		ldr	r3, .L30
 505 002c 044A     		ldr	r2, .L30
 506 002e 526A     		ldr	r2, [r2, #36]
 507 0030 8021     		mov	r1, #128
 508 0032 0A43     		orr	r2, r1
 509 0034 5A62     		str	r2, [r3, #36]
 391:../Generated_Code/AdcLdd1.c ****   return ERR_OK;
 510              		.loc 1 391 0
 511 0036 0023     		mov	r3, #0
 512              	.L29:
 392:../Generated_Code/AdcLdd1.c **** }
 513              		.loc 1 392 0
 514 0038 181C     		mov	r0, r3
 515 003a BD46     		mov	sp, r7
 516 003c 02B0     		add	sp, sp, #8
 517              		@ sp needed for prologue
 518 003e 80BD     		pop	{r7, pc}
 519              	.L31:
 520              		.align	2
 521              	.L30:
 522 0040 00B00340 		.word	1073983488
 523              		.cfi_endproc
 524              	.LFE5:
 526              		.section	.text.AdcLdd1_GetCalibrationResultStatus,"ax",%progbits
 527              		.align	2
 528              		.global	AdcLdd1_GetCalibrationResultStatus
 529              		.code	16
 530              		.thumb_func
 532              	AdcLdd1_GetCalibrationResultStatus:
 533              	.LFB6:
 393:../Generated_Code/AdcLdd1.c **** 
 394:../Generated_Code/AdcLdd1.c **** /*
 395:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 396:../Generated_Code/AdcLdd1.c **** **     Method      :  AdcLdd1_GetCalibrationResultStatus (component ADC_LDD)
 397:../Generated_Code/AdcLdd1.c **** **
 398:../Generated_Code/AdcLdd1.c **** **     Description :
 399:../Generated_Code/AdcLdd1.c **** **         This method should be used for check the last calibration
 400:../Generated_Code/AdcLdd1.c **** **         result. If calibration completed normally the method finish
 401:../Generated_Code/AdcLdd1.c **** **         calibration process by writing gain calibration values.
 402:../Generated_Code/AdcLdd1.c **** **     Parameters  :
 403:../Generated_Code/AdcLdd1.c **** **         NAME            - DESCRIPTION
 404:../Generated_Code/AdcLdd1.c **** **       * DeviceDataPtr   - Device data structure
 405:../Generated_Code/AdcLdd1.c **** **                           pointer returned by <Init> method.
 406:../Generated_Code/AdcLdd1.c **** **     Returns     :
 407:../Generated_Code/AdcLdd1.c **** **         ---             - Error code
 408:../Generated_Code/AdcLdd1.c **** **                           ERR_OK - OK 
 409:../Generated_Code/AdcLdd1.c **** **                           ERR_FAILED - Last calibration hasn't been
 410:../Generated_Code/AdcLdd1.c **** **                           finished correctly
 411:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 412:../Generated_Code/AdcLdd1.c **** */
 413:../Generated_Code/AdcLdd1.c **** LDD_TError AdcLdd1_GetCalibrationResultStatus(LDD_TDeviceData *DeviceDataPtr)
 414:../Generated_Code/AdcLdd1.c **** {
 534              		.loc 1 414 0
 535              		.cfi_startproc
 536 0000 80B5     		push	{r7, lr}
 537              	.LCFI18:
 538              		.cfi_def_cfa_offset 8
 539              		.cfi_offset 7, -8
 540              		.cfi_offset 14, -4
 541 0002 84B0     		sub	sp, sp, #16
 542              	.LCFI19:
 543              		.cfi_def_cfa_offset 24
 544 0004 00AF     		add	r7, sp, #0
 545              	.LCFI20:
 546              		.cfi_def_cfa_register 7
 547 0006 7860     		str	r0, [r7, #4]
 415:../Generated_Code/AdcLdd1.c ****   uint32_t GainValue;
 416:../Generated_Code/AdcLdd1.c **** 
 417:../Generated_Code/AdcLdd1.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 418:../Generated_Code/AdcLdd1.c ****   if (ADC_PDD_GetCalibrationFailedStatusFlag(ADC0_BASE_PTR)) {
 548              		.loc 1 418 0
 549 0008 2B4B     		ldr	r3, .L35
 550 000a 5B6A     		ldr	r3, [r3, #36]
 551 000c 1A1C     		mov	r2, r3
 552 000e 4023     		mov	r3, #64
 553 0010 1340     		and	r3, r2
 554 0012 01D0     		beq	.L33
 419:../Generated_Code/AdcLdd1.c ****     return ERR_FAILED;
 555              		.loc 1 419 0
 556 0014 1B23     		mov	r3, #27
 557 0016 4AE0     		b	.L34
 558              	.L33:
 420:../Generated_Code/AdcLdd1.c ****   }
 421:../Generated_Code/AdcLdd1.c ****   /* If calibration is successfully passed place calibrated value into gain registers */
 422:../Generated_Code/AdcLdd1.c ****   /* Cumulated gradually because of undefined behavior: the order of volatile accesses is undefined
 423:../Generated_Code/AdcLdd1.c ****   GainValue = ADC_PDD_GetPlus0CalibrationValue(ADC0_BASE_PTR); /* Find plus gain value */
 559              		.loc 1 423 0
 560 0018 274B     		ldr	r3, .L35
 561 001a DB6C     		ldr	r3, [r3, #76]
 562 001c FB60     		str	r3, [r7, #12]
 424:../Generated_Code/AdcLdd1.c ****   GainValue += ADC_PDD_GetPlus1CalibrationValue(ADC0_BASE_PTR);
 563              		.loc 1 424 0
 564 001e 264B     		ldr	r3, .L35
 565 0020 9B6C     		ldr	r3, [r3, #72]
 566 0022 FA68     		ldr	r2, [r7, #12]
 567 0024 D318     		add	r3, r2, r3
 568 0026 FB60     		str	r3, [r7, #12]
 425:../Generated_Code/AdcLdd1.c ****   GainValue += ADC_PDD_GetPlus2CalibrationValue(ADC0_BASE_PTR);
 569              		.loc 1 425 0
 570 0028 234B     		ldr	r3, .L35
 571 002a 5B6C     		ldr	r3, [r3, #68]
 572 002c FA68     		ldr	r2, [r7, #12]
 573 002e D318     		add	r3, r2, r3
 574 0030 FB60     		str	r3, [r7, #12]
 426:../Generated_Code/AdcLdd1.c ****   GainValue += ADC_PDD_GetPlus3CalibrationValue(ADC0_BASE_PTR);
 575              		.loc 1 426 0
 576 0032 214B     		ldr	r3, .L35
 577 0034 1B6C     		ldr	r3, [r3, #64]
 578 0036 FA68     		ldr	r2, [r7, #12]
 579 0038 D318     		add	r3, r2, r3
 580 003a FB60     		str	r3, [r7, #12]
 427:../Generated_Code/AdcLdd1.c ****   GainValue += ADC_PDD_GetPlus4CalibrationValue(ADC0_BASE_PTR);
 581              		.loc 1 427 0
 582 003c 1E4B     		ldr	r3, .L35
 583 003e DB6B     		ldr	r3, [r3, #60]
 584 0040 FA68     		ldr	r2, [r7, #12]
 585 0042 D318     		add	r3, r2, r3
 586 0044 FB60     		str	r3, [r7, #12]
 428:../Generated_Code/AdcLdd1.c ****   GainValue += ADC_PDD_GetPlusSCalibrationValue(ADC0_BASE_PTR);
 587              		.loc 1 428 0
 588 0046 1C4B     		ldr	r3, .L35
 589 0048 9B6B     		ldr	r3, [r3, #56]
 590 004a FA68     		ldr	r2, [r7, #12]
 591 004c D318     		add	r3, r2, r3
 592 004e FB60     		str	r3, [r7, #12]
 429:../Generated_Code/AdcLdd1.c ****   GainValue = (GainValue >> 1U) | 0x8000U;
 593              		.loc 1 429 0
 594 0050 FB68     		ldr	r3, [r7, #12]
 595 0052 5B08     		lsr	r3, r3, #1
 596 0054 8022     		mov	r2, #128
 597 0056 1202     		lsl	r2, r2, #8
 598 0058 1343     		orr	r3, r2
 599 005a FB60     		str	r3, [r7, #12]
 430:../Generated_Code/AdcLdd1.c ****   ADC_PDD_SetPlusGainValue(ADC0_BASE_PTR,GainValue); /* Set plus gain value */
 600              		.loc 1 430 0
 601 005c 164B     		ldr	r3, .L35
 602 005e FA68     		ldr	r2, [r7, #12]
 603 0060 DA62     		str	r2, [r3, #44]
 431:../Generated_Code/AdcLdd1.c ****   GainValue = ADC_PDD_GetMinus0CalibrationValue(ADC0_BASE_PTR); /* Find minus gain value */
 604              		.loc 1 431 0
 605 0062 154B     		ldr	r3, .L35
 606 0064 DB6E     		ldr	r3, [r3, #108]
 607 0066 FB60     		str	r3, [r7, #12]
 432:../Generated_Code/AdcLdd1.c ****   GainValue += ADC_PDD_GetMinus1CalibrationValue(ADC0_BASE_PTR);
 608              		.loc 1 432 0
 609 0068 134B     		ldr	r3, .L35
 610 006a 9B6E     		ldr	r3, [r3, #104]
 611 006c FA68     		ldr	r2, [r7, #12]
 612 006e D318     		add	r3, r2, r3
 613 0070 FB60     		str	r3, [r7, #12]
 433:../Generated_Code/AdcLdd1.c ****   GainValue += ADC_PDD_GetMinus2CalibrationValue(ADC0_BASE_PTR);
 614              		.loc 1 433 0
 615 0072 114B     		ldr	r3, .L35
 616 0074 5B6E     		ldr	r3, [r3, #100]
 617 0076 FA68     		ldr	r2, [r7, #12]
 618 0078 D318     		add	r3, r2, r3
 619 007a FB60     		str	r3, [r7, #12]
 434:../Generated_Code/AdcLdd1.c ****   GainValue += ADC_PDD_GetMinus3CalibrationValue(ADC0_BASE_PTR);
 620              		.loc 1 434 0
 621 007c 0E4B     		ldr	r3, .L35
 622 007e 1B6E     		ldr	r3, [r3, #96]
 623 0080 FA68     		ldr	r2, [r7, #12]
 624 0082 D318     		add	r3, r2, r3
 625 0084 FB60     		str	r3, [r7, #12]
 435:../Generated_Code/AdcLdd1.c ****   GainValue += ADC_PDD_GetMinus4CalibrationValue(ADC0_BASE_PTR);
 626              		.loc 1 435 0
 627 0086 0C4B     		ldr	r3, .L35
 628 0088 DB6D     		ldr	r3, [r3, #92]
 629 008a FA68     		ldr	r2, [r7, #12]
 630 008c D318     		add	r3, r2, r3
 631 008e FB60     		str	r3, [r7, #12]
 436:../Generated_Code/AdcLdd1.c ****   GainValue += ADC_PDD_GetMinusSCalibrationValue(ADC0_BASE_PTR);
 632              		.loc 1 436 0
 633 0090 094B     		ldr	r3, .L35
 634 0092 9B6D     		ldr	r3, [r3, #88]
 635 0094 FA68     		ldr	r2, [r7, #12]
 636 0096 D318     		add	r3, r2, r3
 637 0098 FB60     		str	r3, [r7, #12]
 437:../Generated_Code/AdcLdd1.c ****   GainValue =  (GainValue >> 1U) | 0x8000U;
 638              		.loc 1 437 0
 639 009a FB68     		ldr	r3, [r7, #12]
 640 009c 5B08     		lsr	r3, r3, #1
 641 009e 8022     		mov	r2, #128
 642 00a0 1202     		lsl	r2, r2, #8
 643 00a2 1343     		orr	r3, r2
 644 00a4 FB60     		str	r3, [r7, #12]
 438:../Generated_Code/AdcLdd1.c ****   ADC_PDD_SetMinusGainValue(ADC0_BASE_PTR,GainValue); /* Set minus gain value */
 645              		.loc 1 438 0
 646 00a6 044B     		ldr	r3, .L35
 647 00a8 FA68     		ldr	r2, [r7, #12]
 648 00aa 1A63     		str	r2, [r3, #48]
 439:../Generated_Code/AdcLdd1.c ****   return ERR_OK;
 649              		.loc 1 439 0
 650 00ac 0023     		mov	r3, #0
 651              	.L34:
 440:../Generated_Code/AdcLdd1.c **** }
 652              		.loc 1 440 0
 653 00ae 181C     		mov	r0, r3
 654 00b0 BD46     		mov	sp, r7
 655 00b2 04B0     		add	sp, sp, #16
 656              		@ sp needed for prologue
 657 00b4 80BD     		pop	{r7, pc}
 658              	.L36:
 659 00b6 C046     		.align	2
 660              	.L35:
 661 00b8 00B00340 		.word	1073983488
 662              		.cfi_endproc
 663              	.LFE6:
 665              		.text
 666              	.Letext0:
 667              		.file 2 "C:/Freescale/CW MCU v10.3/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 668              		.file 3 "../Generated_Code/PE_Types.h"
 669              		.file 4 "../Generated_Code/IO_Map.h"
 670              		.file 5 "../Generated_Code/PE_LDD.h"
 671              		.file 6 "../Generated_Code/AdcLdd1.h"
DEFINED SYMBOLS
                            *ABS*:00000000 AdcLdd1.c
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccEXyGDv.s:18     .rodata.ChannelToPin:00000000 $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccEXyGDv.s:21     .rodata.ChannelToPin:00000000 ChannelToPin
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccEXyGDv.s:27     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccEXyGDv.s:30     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 DeviceDataPrv__DEFAULT_RTOS_ALLOC
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccEXyGDv.s:33     .text.AdcLdd1_Init:00000000 $t
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccEXyGDv.s:38     .text.AdcLdd1_Init:00000000 AdcLdd1_Init
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccEXyGDv.s:151    .text.AdcLdd1_Init:000000a0 $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccEXyGDv.s:163    .text.AdcLdd1_StartSingleMeasurement:00000000 $t
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccEXyGDv.s:168    .text.AdcLdd1_StartSingleMeasurement:00000000 AdcLdd1_StartSingleMeasurement
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccEXyGDv.s:226    .text.AdcLdd1_StartSingleMeasurement:00000044 $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccEXyGDv.s:231    .text.AdcLdd1_CreateSampleGroup:00000000 $t
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccEXyGDv.s:236    .text.AdcLdd1_CreateSampleGroup:00000000 AdcLdd1_CreateSampleGroup
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccEXyGDv.s:317    .text.AdcLdd1_CreateSampleGroup:00000060 $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccEXyGDv.s:323    .text.AdcLdd1_GetMeasuredValues:00000000 $t
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccEXyGDv.s:328    .text.AdcLdd1_GetMeasuredValues:00000000 AdcLdd1_GetMeasuredValues
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccEXyGDv.s:399    .text.AdcLdd1_GetMeasuredValues:0000005c $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccEXyGDv.s:404    .text.AdcLdd1_GetMeasurementCompleteStatus:00000000 $t
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccEXyGDv.s:409    .text.AdcLdd1_GetMeasurementCompleteStatus:00000000 AdcLdd1_GetMeasurementCompleteStatus
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccEXyGDv.s:455    .text.AdcLdd1_GetMeasurementCompleteStatus:0000002c $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccEXyGDv.s:460    .text.AdcLdd1_StartCalibration:00000000 $t
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccEXyGDv.s:465    .text.AdcLdd1_StartCalibration:00000000 AdcLdd1_StartCalibration
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccEXyGDv.s:522    .text.AdcLdd1_StartCalibration:00000040 $d
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccEXyGDv.s:527    .text.AdcLdd1_GetCalibrationResultStatus:00000000 $t
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccEXyGDv.s:532    .text.AdcLdd1_GetCalibrationResultStatus:00000000 AdcLdd1_GetCalibrationResultStatus
C:\DOCUME~1\chenty\LOCALS~1\Temp\ccEXyGDv.s:661    .text.AdcLdd1_GetCalibrationResultStatus:000000b8 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
PE_LDD_DeviceDataList
